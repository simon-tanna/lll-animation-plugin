# Gsap-Expert - V3

**Pages:** 152

---

## Physics2D

**URL:** https://gsap.com/docs/v3/Plugins/Physics2DPlugin.md

**Contents:**
    - CDN Link
    - Minimal usage
- Description[‚Äã](#description "Direct link to Description")
    - loading...
- **Config Object**[‚Äã](#config-object "Direct link to config-object")
- Usage[‚Äã](#usage "Direct link to Usage")
- **Demos**[‚Äã](#demos "Direct link to demos")

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/YzdOVbK?default-tab=result\&theme-id=41164)

Provides simple physics functionality for tweening an Object's `x` and `y` coordinates (or `left` and `top`) based on a combination of `velocity`, `angle`, `gravity`, `acceleration`, `accelerationAngle`, and/or `friction`. It is not intended to replace a full-blown physics engine and does not offer collision detection, but serves as a way to easily create interesting physics-based effects with the GreenSock Animation Platform.

Number - The initial velocity of the object measured in pixels per time unit. Default: `0`.

* #### angle[](#angle)

Number - The initial angle (in degrees) at which the object should travel. This only matters when a `velocity` is defined. For example, if the object should start out traveling at -60 degrees (towards the upper right), the `angle` would be `-60`. Default: `0`.

* #### gravity[](#gravity)

Number - The amount of downward acceleration applied to the object, measured in pixels per second. You can either use `gravity` or `acceleration`, not both because `gravity` is the same thing as `acceleration` applied at an `accelerationAngle` of `90`. Think of gravity as a convenience property that automatically sets the `accelerationAngle` for you. Default: `null`.

* #### acceleration[](#acceleration)

Number - The amount of acceleration applied to the object, measured in pixels per second, it would be measured per frame). To apply the acceleration in a specific direction that is different than the angle, use the `accelerationAngle` property. You can either use `gravity` or `acceleration`, not both because `gravity` is the same thing as `acceleration` applied at an `accelerationAngle` of `90`. Default: `null`.

* #### accelerationAngle[](#accelerationAngle)

Number - The angle at which acceleration is applied (if any), measured in degrees. So if, for example, you want the object to accelerate towards the left side of the screen, you‚Äôd use an `accelerationAngle` of `180`. If you define a `gravity` value, it will automatically set the `accelerationAngle` to `90` (downward). Default: `null`.

* #### friction[](#friction)

Number - A value between 0 and 1 where 0 is no friction, 0.08 is a small amount of friction, and 1 will completely prevent any movement. This is not meant to be precise or scientific in any way, but it serves as an easy way to apply a friction-like physics effect to your tween. Generally it is best to experiment with this number a bit - start with very small values like 0.02. Also note that friction requires more processing than physics tweens without any friction. Default: `0`.

* #### xProp[](#xProp)

String - By default, the `x` property of the target object is used to control x-axis movement, but if you‚Äôd prefer to use a different property name, use `xProp` like `xProp: "left"`. Default: `"x"`.

* #### yProp[](#yProp)

String - By default, the `y` property of the target object is used to control y-axis movement, but if you‚Äôd prefer to use a different property name, use `yProp` like `yProp: "top"`. Default: `"y"`.

Parameters are not intended to be dynamically updateable, but one unique convenience is that everything is reverseable. So if you spawn a bunch of particle tweens, for example, and throw them into a timeline, you could simply call `reverse()` on the timeline to watch the particles retrace their steps right back to the beginning. Keep in mind that any easing equation you define for your tween will be completely ignored for these properties.

Check out more [Physics2D demos on codepen](https://codepen.io/collection/AORzWx)

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(Physics2DPlugin)
```

Example 2 (unknown):
```unknown
gsap.to(element, {
  duration: 2,
  physics2D: { velocity: 300, angle: -60, gravity: 400 },
});
```

Example 3 (unknown):
```unknown
gsap.to(element, {
  duration: 2,
  physics2D: { velocity: 300, angle: -60, gravity: 400 },
});
//or
gsap.to(element, {
  duration: 2,
  physics2D: { velocity: 300, angle: -60, friction: 0.1 },
});
//or
gsap.to(element, {
  duration: 2,
  physics2D: {
    velocity: 300,
    angle: -60,
    acceleration: 50,
    accelerationAngle: 180,
  },
});
```

---

## data

**URL:** https://gsap.com/docs/v3/GSAP/Tween/data.md

**Contents:**
  - data : \*
  - Details[‚Äã](#details "Direct link to Details")

A place to store any data you want (initially populated with `vars.data` if it exists).

A place to store any data you want (initially populated with `vars.data` if it exists).

---

## Observer.isTouch

**URL:** https://gsap.com/docs/v3/Plugins/Observer/static.isTouch.md

**Contents:**
  - Observer.isTouch : Number
  - Details[‚Äã](#details "Direct link to Details")

A way to discern the touch capabilities of the current device - `0` is mouse/pointer only (no touch), `1` is touch-only, `2` accommodates both.

A way to discern the touch capabilities of the device:

* `0` - **no touch** (pointer/mouse only)
* `1` - **touch-only** device (like a phone)
* `2` - device can accept **touch** input and **mouse/pointer** (like Windows tablets)

**Examples:**

Example 1 (unknown):
```unknown
if (Observer.isTouch) {
  // any touch-capable device...
}

// or get more specific:
if (Observer.isTouch === 1) {
  // touch-only device
}
```

---

## Modifiers

**URL:** https://gsap.com/docs/v3/GSAP/CorePlugins/Modifiers.md

**Contents:**
  - Description[‚Äã](#description "Direct link to Description")
  - value, target[‚Äã](#value-target "Direct link to value, target")
  - Snap rotation[‚Äã](#snap-rotation "Direct link to Snap rotation")
    - loading...
  - Clamp with Modulus[‚Äã](#clamp-with-modulus "Direct link to Clamp with Modulus")
    - loading...
    - loading...
  - Carousel Wrap[‚Äã](#carousel-wrap "Direct link to Carousel Wrap")
    - loading...
  - Advanced demos[‚Äã](#advanced-demos "Direct link to Advanced demos")

What are internal plugins?

ModifiersPlugin is an internal plugin, It is **automatically included in GSAP's core** and **doesn't have to be loaded using gsap.registerPlugin()**.

You can think of internal plugins as just a part of GSAP.

You can define a "modifier" function for almost any property. This modifier intercepts the value that GSAP would normally apply on each update ("tick"), feeds it to your function as the first parameter and lets you run custom logic, returning a new value that GSAP should then apply. This is perfect for tasks like snapping, clamping, wrapping, or other dynamic effects.

The modifier functions are passed two parameters:

1. `value` (*number* | *string*) - The about-to-be-applied value from the regular tween. This is often a number, but could be a string based on whatever the property requires. For example if you're animating the `x` property, it would be a number, but if you're animating the `left` property it could be something like `"212px"`, or for the `boxShadow` property it could be `"10px 5px 10px rgb(255,0,0)"`.

2. target (*object*) - The target itself.

For example, change the `x` of one object based on the `y` of another object or change `rotation` based on the `direction` it is moving. Below are some examples that will help you get familiarized with the syntax.

The tween below animates 360 degrees but the modifier function forces the value to jump to the closest 45-degree increment. Take note how the modifier function gets passed the value of the property that is being modified, in this case a `rotation` number.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/BzJxBB?default-tab=result\&theme-id=41164)

If snapping is all that you're wanting to do, we recommend using the [SnapPlugin](/docs/v3/GSAP/CorePlugins/Snap.md) that is built into GSAP's core.

The tween below animates `x` to 500 but the modifier function forces the value to wrap so that it's always between 0 and 100.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/rLJmOv?default-tab=result\&theme-id=41164)

Here's the same sort of technique but using GSAP's [wrap utility function](/docs/v3/GSAP/UtilityMethods/wrap\(\).md):

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/5364a46c2767c6258132f7805ea0035e?default-tab=result\&theme-id=41164)

Have you ever built a carousel and wrestled with making it loop seamlessly? Perhaps you duplicated each asset or wrote some code that moved each item back to the beginning when it reached the end. With ModifiersPlugin you can get a seamless repeating carousel with a single `.to()` with a `stagger`! The example below tweens each box to a relative `x` position of `"+=500"`. Click the "show overflow" button to see each box get reset to `x: 0` when it goes beyond 500.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/QEdpLe?default-tab=result\&theme-id=41164)

We've only scratched the surface of what ModifiersPlugin can do. Our moderator [Blake Bowen](https://gsap.com/community/profile/21420-osublake/) has been putting this plugin to the test and has an [impressive collection of demos](https://codepen.io/collection/AWxOyk/) that will surely inspire you.

* To modify CSS transform's `scale`, use `scaleX` and `scaleY` (since it's a shortcut for those). And use `rotation`, not `rotationZ`.

* RoundPropsPlugin and SnapPlugin tap into the same mechanism internally as ModifiersPlugin (to maximize efficiency, minimize memory, and keep kb down). Think of a `roundProps` tween as just a shortcut that creates a modifier that applies `Math.round()`, thus you cannot do *both*`roundProps` and a modifier on the same property. It's easy to get that functionality, though, by just doing `Math.round()` inside the modifier function.

Simply load GSAP's core - ModifiersPlugin is included automatically!

Nope. ModifiersPlugin and other core plugins are built into the core and don't have to be registered.

---

## Draggable

**URL:** https://gsap.com/docs/v3/Plugins/Draggable.md

**Contents:**
    - CDN Link
    - Minimal usage
    - loading...
- Features[‚Äã](#features "Direct link to Features")
- Usage[‚Äã](#usage "Direct link to Usage")
- **Config Object**[‚Äã](#config-object "Direct link to config-object")
- Snapping[‚Äã](#snapping "Direct link to Snapping")
  - As an array of snap-to values[‚Äã](#as-an-array-of-snap-to-values "Direct link to As an array of snap-to values")
  - As a function with custom logic[‚Äã](#as-a-function-with-custom-logic "Direct link to As a function with custom logic")
- Getting the velocity[‚Äã](#getting-the-velocity "Direct link to Getting the velocity")

Provides a surprisingly simple way to make virtually any DOM element draggable, spinnable, tossable, and even flick-scrollable using mouse and/or touch events

Inertia effects Draggable integrates beautifully with [InertiaPlugin](/docs/v3/Plugins/InertiaPlugin/.md) so that the user can flick and have the motion decelerate smoothly based on momentum. :::

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/yLGqXzZ?default-tab=result\&theme-id=41164)

* **Touch enabled** - Works great on tablets, phones, and desktop browsers.
* **Incredibly smooth** - GPU-accelerated and `requestAnimationFrame`-driven for ultimate performance. Compared to other options out there, Draggable just feels far more natural and fluid, particularly when imposing bounds and momentum.
* **Momentum-based animation** - If you have InertiaPlugin loaded, you can simply set `inertia: true` in the `config` object and it'll automatically apply natural, momentum-based movement after the mouse/touch is released, causing the object to glide gracefully to a stop. You can even control the amount of `resistance`, maximum or minimum `duration`, etc.

* **Impose bounds** - Tell a draggable element to stay within the bounds of another DOM element (a container) as in `bounds: "#container"` or define bounds as coordinates like `bounds: {top: 100, left: 0, width: 1000, height: 800}` or specific maximum and minimum values like `bounds: {minRotation: 0, maxRotation: 270}`.
* **Sense overlaps with `hitTest()`** - See if one element is overlapping another and even set a tolerance threshold (like at least 20 pixels or 25% of either element's total surface area) using the super-flexible `Draggable.hitTest()` method. Feed it a mouse event and it'll tell you if the mouse is over the element. See [this CodePen](https://codepen.io/GreenSock/pen/GFBvn) for a simple example.
* **Define a trigger element** - Maybe you want only a certain area to trigger the dragging (like the top bar of a window) - it's as simple as `trigger: "#topBar"`, for example.
* \*\*Drag position or rotation \*\*- Lots of drag types to choose from: \[`"x,y"` | `"top,left"` | `"rotation"` | `"x"` | `"y"` | `"top"` | `"left"`]
* **Lock movement along a certain axis** - Set `lockAxis: true` and Draggable will watch the direction the user starts to drag and then restrict it to that axis. Or if you only want to allow vertical or horizontal movement, that's easy using the type (`"top"` or `"y"` to only allow vertical movement; `"x"`, or `"left"` to only allow horizontal movement).
* **Rotation honors transform origin** - By default, spinnable elements will rotate around their center, but you can set `transformOrigin` to something else to make the pivot point be elsewhere. For example, if you call `gsap.set(yourElement, {transformOrigin: "top left"})` before dragging, it will rotate around its top left corner. Or use `%` or `px`. Whatever is set in the element's CSS will be honored.
* **Rich callback system and event dispatching** - You can use any of the following callbacks: `onPress`, `onDragStart`, `onDrag`, `onDragEnd`, `onRelease`, `onLockAxis`, and `onClick`. Inside the callbacks, `this` refers to the Draggable instance itself, so you can easily access its `target` or `bounds`, etc. If you prefer event listeners instead, Draggable dispatches events too so you can do things like `yourDraggable.addEventListener("dragend", yourFunc);`
* **Works great with SVG.**
* **Even works in transformed containers!** - Got a Draggable inside a rotated or scaled container? No problem. No other tool handles this properly that we've seen.
* **Auto-scrolling, even in multiple containers** - Set `autoScroll: 1` for normal-speed auto scrolling, or `autoScroll: 2` would scroll twice as fast, etc. The closer you move toward the edge, the faster scrolling gets. See a [demo here](https://codepen.io/GreenSock/pen/YPvdYv/?editors=001).
* **Sense clicks when the element moves less than 3 pixels** - A common challenge is figuring out when a user is trying to click or tap an object rather than drag it, so if the mouse/touch moves less than 3 pixels from its starting position, it will be interpreted as a click and the `onClick` callback will be called (and a `"click"` event dispatched) without actually moving the element. You can define a different threshold using `minimumMovement` config property, like `minimumMovement: 6` for 6 pixels.

In its simplest form, you can make an element draggable (vertically and horizontally) like this:

This will simply find the element with the ID `"yourID"` and make it draggable with no bounds or any kinetic motion after release. You don't need to use selector text either - you can pass the element itself or even an array of objects.

Use the `vars` parameter to define various other configuration options. For example, to make the object scroll only vertically using the `y` transform and stay within the bounds of a DOM element with an ID of `"container"`, and call a function when clicked and another when the drag ends and make it have momentum-based motion (assuming you loaded InertiaPlugin), do this:

Or to make something **spinnable** (dragging rotates the element), you could simply do:

And to add the ability to snap to 90-degree increments after the mouse/touch is released (like flick-spinning that always lands on 90-degree increments), use the snap option:

String - The cursor‚Äôs CSS value that should be used between the time they press and then release the pointer/mouse. This can be different than the regular `cursor` value, like: `cursor: "grab", activeCursor: "grabbing"`.

* #### allowContextMenu[](#allowContextMenu)

Boolean - If `true`, Draggable will allow context menus (like if a user right-clicks or long-touches). Normally this is suppressed because it can get in the way of dragging (especially on touch devices). Default: `false`.

* #### allowEventDefault[](#allowEventDefault)

Boolean - If `true`, `preventDefault()` won‚Äôt be called on the original mouse/pointer/touch event. This can be useful if you want to permit the default behavior like touch-scrolling. Typically, however, it‚Äôs best to let Draggable call `preventDefault()` on the events in order to deliver the best usability with dragging. Default: `false`.

* #### allowNativeTouchScrolling[](#allowNativeTouchScrolling)

Boolean - By default, allows you to native touch-scroll in the opposite direction as Draggables that are limited to one axis . For example, a Draggable of `type: "x"` or `"left"` would permit native touch-scrolling in the vertical direction, and `type: "y"` or `"top"` would permit native horizontal touch-scrolling. Default: `true`.

* #### autoScroll[](#autoScroll)

Number - To enable auto-scrolling when a Draggable is dragged within 40px of an edge of a scrollable container, set autoScroll to a non-zero value, where 1 is normal speed, 2 is double-speed, etc. (you can use any number). For a more intuitive or natural feel, it will scroll faster as the mouse/touch gets closer to the edge. The default value is 0 (no auto-scrolling). See [this CodePen](//codepen.io/GreenSock/pen/YPvdYv/?editors=001) for a demo.

* #### bounds[](#bounds)

\[*Element* | *String* | *Object*] - To cause the draggable element to stay within the bounds of another DOM element (like a container), you can pass the element like `bounds: document.getElementById("container")` or even selector text like `"#container"`. If you prefer, you can define bounds as a rectangle instead, like `bounds: {top: 100, left: 0, width: 1000, height: 800}` which is based on the parent‚Äôs coordinate system (top and left would be from the upper left corner of the parent). Or you can define specific maximum and minimum values like `bounds: {minX: 10, maxX: 300, minY: 50, maxY: 500}` or `bounds: {minRotation: 0, maxRotation: 270}`.

* #### callbackScope[](#callbackScope)

Object - The scope to be used for all of the callbacks (`onDrag`, `onDragEnd`, `onDragStart`, etc). The scope is what `this` refers to inside any of the callbacks. The older callback-specific scope properties are deprecated but still work.

* #### clickableTest[](#clickableTest)

Function - Your Draggable may contain child elements that are ‚Äúclickable‚Äù, like links `<a>` tags, `<button/>` or `<input>` elements, etc. By default, it treats clicks and taps on those elements differently, not allowing the user to drag them. You can set `dragClickables: true` to override that, but it still may be handy to control exactly what Draggable considers to be a ‚Äúclickable‚Äù element, so you can use your own function that accepts the clicked-on element as the only parameter and returns true or false accordingly. Draggable will call this function whenever the user presses their mouse or finger down on a Draggable, and the target of that event will be passed to your clickableTest function.

* #### cursor[](#cursor)

String - By default (except for `type: "rotation"`), the cursor CSS property of the element is set to `move` so that when the mouse rolls over it, there‚Äôs a visual cue indicating that it‚Äôs moveable, but you may define a different cursor if you prefer (as described at <https://devdocs.io/css/cursor>) like `cursor: "pointer"`.

* #### dragClickables[](#dragClickables)

Boolean - By default, Draggable will work on pretty much any element, but sometimes you might want clicks on `<a>`, `<input>`, `<select>`, `<button>`, and `<textarea>` elements (as well as any element that has a `data-clickable="true"` attribute) NOT to trigger dragging so that the browser‚Äôs default behavior fires (like clicking on an input would give it focus and drop the cursor there to begin typing), so if you want Draggable to ignore those clicks and allow the default behavior instead, set `dragClickables: false`.

* #### dragResistance[](#dragResistance)

Number - A number between 0 and 1 that controls the degree to which resistance is constantly applied to the element as it is dragged, where 1 won‚Äôt allow it to be dragged at all, 0.75 applies a lot of resistance (making the object travel at quarter-speed), and 0.5 would be half-speed, etc. This can even apply to rotation.

* #### edgeResistance[](#edgeResistance)

Number - A number between 0 and 1 that controls the degree to which resistance is applied to the element as it goes outside the bounds (if any are applied), where 1 won‚Äôt allow it to be dragged past the bounds at all, 0.75 applies a lot of resistance (making the object travel at quarter-speed beyond the border while dragging), and 0.5 would be half-speed beyond the border, etc. This can even apply to rotation.

* #### force3D[](#force3D)

Boolean - By default, 3D transforms are used (when the browser supports them) in order to force the element onto its own layer on the GPU, thus speeding compositing. Typically this provides the best performance, but you can disable it by setting `force3D: false`. This may be a good idea if the element that you‚Äôre dragging contains child elements that are animating.

* #### inertia[](#inertia)

\[*Boolean* | *Object*] - InertiaPlugin is the key to getting the momentum-based motion after the users‚Äô mouse (or touch) is released. To have Draggable auto-apply an InertiaPlugin tween to the element when the mouse is released (or touch ends), you can set `inertia: true` (`inertia` also works). Or for advanced effects, you can define the actual inertia object that will get fed into tween, like `inertia: {top: {min: 0, max: 1000, end: [0,200,400,600]}}`. However, if you want ultimate control over the InertiaPlugin tween, you can simply use an `onDragEnd` to call your own function that creates the tween. If `inertia: true` is defined, you may also use any of the following configuration properties that apply to the movement after the mouse/touch is released...

* **snap** : \[*Function* | *Object* | *Array*] - Allows you to define rules for where the element can land after it gets released. For example, maybe you want the rotation to always end at a 90-degree increment or you want the `x` and `y` values to be exactly on a grid (whichever cell is closest to the natural landing spot) or maybe you want it to land on a very specific value. You can define the snap in any of the following ways:

* **As a function** - This function will be passed one numeric parameter, the natural ending value. The function must return whatever the new ending value should be (you run whatever logic you want inside the function and spit back the value). For example, to make the value snap to the closest increment of 50, you‚Äôd do `snap: function(endValue) { return Math.round(endValue / 50) * 50; }`.
    * **As an Array** - If you use an array of values, InertiaPlugin will first plot the natural landing position and then loop through the array and find the closest number (as long as it‚Äôs not outside any bounds you defined). For example, to have it choose the closest number from 10, 50, 200, and 450, you‚Äôd do `snap: [10,50,200,450]`.
    * **As an object** - If you‚Äôd like to use different logic for each property, like if `type` is `"x,y"` and you‚Äôd like to have the `x` part snap to one set of values, and the `y` part snap to a different set of values, you can use an object that has matching properties, like: `snap:{x: [5,20,80,400], y: [10,60,80,500]}` or if `type` is `"top,left"` and you want to use a different function for each, you could do something like `snap: {top: function(endValue) { return Math.round(endValue / 50) * 50; }, left: function(endValue) { return Math.round(endValue / 100) * 100; }}`. You can define a points property inside this object that combines both `x` and `y`, like `liveSnap: {points: [{x: 0, y: 0},{x: 100, y: 0}], radius: 20}` which will snap to any point in the array when it‚Äôs within 20px (distance). Or you can even use a function-based value to run your own snapping logic, like `liveSnap: {points: function(point) { //run custom logic and return a new point }}`. See the [snapping section](#snapping) of this page for examples.

* **onThrowUpdate** : *Function* - A function that should be called each time the InertiaPlugin tween updates/renders (basically on each ‚Äútick‚Äù of the engine while the tween is active). This only applies to the tween that gets generated after the user releases their mouse/touch - the function is not called while the user is dragging the element (that‚Äôs what `onDrag` is for). By default, the scope of the `onThrowUpdate` is the Draggable instance itself, but you may define an `callbackScope` if you prefer, just like any other tween.

* **onThrowComplete** : *Function* - A function that should be called when the InertiaPlugin tween finishes. This only applies to the tween that gets generated after the user releases their mouse/touch - the function is not called immediately when the user releases their mouse/touch - that‚Äôs what `onDragEnd` is for. By default, the scope of the `onThrowComplete` is the Draggable instance itself, but you may define an `callbackScope` if you prefer, just like any other tween.

* **throwResistance** : *Number* - A number (`1000` by default) that controls how much resistance or friction there is when the mouse/touch is released and momentum-based motion is enabled (by setting `inertia: true`). The larger the number, the more resistance and the quicker the motion decelerates. (requires InertiaPlugin and setting `inertia: true`, otherwise `throwResistance` will simply be ignored.)

* **maxDuration** : *Number* - The maximum duration (in seconds) that the kinetic-based inertia tween can last. InertiaPlugin will automatically analyze the velocity and bounds and determine an appropriate duration (faster movements would typically result in longer tweens to decelerate), but you can cap the duration by defining a `maxDuration`. The default is 10 seconds. This has nothing to do with the maximum amount of time that the user can drag the object - it‚Äôs only the inertia tween that results after they release the mouse/touch. (requires InertiaPlugin and setting `inertia: true`, otherwise `maxDuration` will simply be ignored.)

* **minDuration** : *Number* - The minimum duration (in seconds) that the kinetic-based inertia tween should last. InertiaPlugin will automatically analyze the velocity and bounds and determine an appropriate duration (faster movements would typically result in longer tweens to decelerate), but you can force the tween to take at least a certain amount of time by defining a `minDuration`. The default is 0.2 seconds. This has nothing to do with the minimum amount of time that the user can drag the object - it‚Äôs only the inertia tween that results after they release the mouse/touch. (requires InertiaPlugin and setting `inertia: true`, otherwise minDuration will simply be ignored.)

* **overshootTolerance** : *Number* - Affects how much overshooting is allowed before smoothly returning to the resting position at the end of the tween. This can happen when the initial velocity from the flick would normally cause it to exceed the bounds/min/max. The larger the `overshootTolerance` the more leeway the tween has to temporarily shoot past the max/min if necessary. The default is `1`. If you don‚Äôt want to allow any overshooting, you can set it to `0`.

* #### liveSnap[](#liveSnap)

\[*Function* | *Boolean* | *Array* | *Object*] - Allows you to define rules that get applied **WHILE** the element is being dragged (whereas regular snap affects only the end value(s), where the element lands after the drag is released). For example, maybe you want the rotation to snap to 10-degree increments while dragging or you want the x and y values to snap to a grid (whichever cell is closest). You can define the `liveSnap` in any of the following ways:

* **As a function** - This function will be passed one numeric parameter, the natural (unaltered) value. The function must return whatever the new value should be (you run whatever logic you want inside your function and spit back the value). For example, to make the value snap to the closest increment of 50, you‚Äôd do `liveSnap: function(value) { return Math.round(value / 50) * 50; }`.
  * **As an array** - If you use an array of values, Draggable will loop through the array and find the closest number (as long as it‚Äôs not outside any bounds you defined). For example, to have it choose the closest number from 10, 50, 200, and 450, you‚Äôd do `liveSnap: [10,50,200,450]`.
  * **As an object** - If you‚Äôd like to use different logic for each property, like if `type` is `"x,y"` and you‚Äôd like to have the ‚Äúx‚Äù part snap to one set of values, and the ‚Äúy‚Äù part snap to a different set of values, you can use an object that has matching properties, like: `liveSnap: {x: [5,20,80,400], y: [10,60,80,500]}`. Or if `type` is `"top,left"` and you want to use a different function for each, you‚Äôd do something like `liveSnap: {top: function(value) { return Math.round(value / 50) * 50; }, left: function(value) { return Math.round(value / 100) * 100; }}`. You can define a `points` property inside this object that combines both x and y, like `liveSnap: {points:[{x: 0, y: 0}, {x: 100, y: 0}], radius: 20}` which will snap to any point in the array when it‚Äôs within 20px (distance). Or you can even use a function-based value to run your own snapping logic, like `liveSnap: {points: function(point) { //run custom logic and return a new point }}`. See the [snapping section](#snapping) of this page for examples.
  * **As a boolean (`true`)** - Live snapping will use whatever is defined for the `snap` (so that instead of only applying to the end value(s), it will apply it ‚Äúlive‚Äù while dragging too).

* #### lockAxis[](#lockAxis)

Boolean - If `true`, dragging more than 2 pixels in either direction (horizontally or vertically) will lock movement into that axis so that the element can only be dragged that direction (horizontally or vertically, whichever had the most initial movement) during that drag. No diagonal movement will be allowed. Obviously this is only applicable for Draggables with a `type` of `"x,y"`, or `"top,left"`. If you only want to allow vertical movement, you should set the `type` to `"y"` or `"top"`. If you only want to allow horizontal movement, you should set the `type` to `"x"` or `"left"`.

* #### minimumMovement[](#minimumMovement)

Number - By default, Draggable requires that the Draggable element moves more than 2 pixels in order to be interpreted as a drag, but you can change that threshold using `minimumMovement`. So `minimumMovement: 6` would require that the Draggable element moves more than 6 pixels to be interpreted as a drag.

* #### onClick[](#onClick)

Function - A function that should be called only when the mouse/touch is pressed on the element and released without moving 3 pixels or more. This makes it easier to discern the user‚Äôs intent (click or drag). Inside that function, `this` refers to the Draggable instance (unless you specifically set the scope using `callbackScope`), making it easy to access the target element (`this.target`) or the boundary coordinates (`this.maxX`, `this.minX`, `this.maxY`, and `this.minY`). By default, the `pointerEvent` (last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access its `pageX`, `pageY`, `target`, `currentTarget`, etc.

* #### onClickParams[](#onClickParams)

Array - An optional array of parameters to feed the `onClick` callback. For example, `onClickParams: ["clicked", 5]` would work with this code: `onClick: function(message, num) { console.log("message: " + message + ", num: " + num); }`.

* #### onDrag[](#onDrag)

Function - A function that should be called every time the mouse (or touch) moves during the drag. Inside that function, `this` refers to the Draggable instance (unless you specifically set the scope using `callbackScope`), making it easy to access the target element (`this.target`) or the boundary coordinates (`this.maxX`, `this.minX`, `this.maxY`, and `this.minY`). By default, the `pointerEvent` (last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access its `pageX`, `pageY`, `target`, `currentTarget`, etc. This is only called once per requestAnimationFrame.

* #### onDragParams[](#onDragParams)

Array - An optional array of parameters to feed the `onDrag` callback. For example, `onDragParams: ["dragged", 5]` would work with this code: `onDrag: function(message, num) { console.log("message: " + message + ", num: " + num); }`.

* #### onDragEnd[](#onDragEnd)

Function - A function that should be called as soon as the mouse (or touch) is **released** after the drag. Even if nothing is moved, the `onDragEnd` will always fire, whereas the `onClick` callback only fires if the mouse/touch moves is less than 3 pixels. Inside that function, `this` refers to the Draggable instance (unless you specifically set the scope using `callbackScope`), making it easy to access the target element (`this.target`) or the boundary coordinates (`this.maxX`, `this.minX`, `this.maxY`, and `this.minY`). By default, the `pointerEvent` (last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access `pageX`, `pageY`, `target`, `currentTarget`, etc.

* #### onDragEndParams[](#onDragEndParams)

Array - An optional array of parameters to feed the `onDragEnd` callback. For example, `onDragEndParams: ["drag ended", 5]` would work with this code: `onDragEnd: function(message, num) { console.log("message: " + message + ", num: " + num); }`.

* #### onDragStart[](#onDragStart)

Function - A function that should be called as soon as the mouse (or touch) moves more than 2 pixels, meaning that dragging has begun. Inside that function, `this` refers to the Draggable instance (unless you specifically set the scope using `callbackScope`), making it easy to access the target element (`this.target`) or the boundary coordinates (`this.maxX`, `this.minX`, `this.maxY`, and `this.minY`). By default, the `pointerEvent` (last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access `pageX`, `pageY`, `target`, `currentTarget`, etc.

* #### onDragStartParams[](#onDragStartParams)

Array - An optional array of parameters to feed the `onDragStart` callback. For example, `onDragStartParams: ["drag started", 5]` would work with this code: `onDragStart: function(message, num) { console.log("message: " + message + ", num: " + num); }`.

* #### onLockAxis[](#onLockAxis)

Function - A function that should be called as soon as movement is locked into the horizontal or vertical axis. This happens when `lockAxis` is `true` and the user drags enough for Draggable to determine which axis to lock. It also happens on touch-enabled devices when you have a Draggable whose type only permits it to drag along one axis (like `type: "x"`, `type: "y"`, `type: "left"`, or `type: "top"`) and the user touch-drags and Draggable determines the direction, either allowing native touch-scrolling or Draggable-induced dragging. Inside the function, `this` refers to the Draggable instance, making it easy to access the locked axis (`this.lockedAxis` which will either be `"x"` or `"y"`), or the target element (`this.target`), etc. By default, the `pointerEvent` (last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access `pageX`, `pageY`, `target`, `currentTarget`, etc.

* #### onMove[](#onMove)

Function - A function that should be called every time the mouse (or touch) moves during the drag. Inside that function, `this` refers to the Draggable instance (unless you specifically set the scope using `callbackScope`), making it easy to access the target element (`this.target`) or the boundary coordinates (`this.maxX`, `this.minX`, `this.maxY`, and `this.minY`). By default, the `pointerEvent` (last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access its `pageX`, `pageY`, `target`, `currentTarget`, etc. This is different than `onDrag` in that it can fire multiple times per requestAnimationFrame. In general, it is better to use `onDrag`, but this is available if, for some reason, need to `.stopPropogation` or `.stopImmediatePropogation` on the drag event.

* #### onPress[](#onPress)

Function - A function that should be called as soon as the mouse (or touch) presses down on the element. Inside that function, `this` refers to the Draggable instance (unless you specifically set the scope using `callbackScope`), making it easy to access the target element (`this.target`) or the boundary coordinates (`this.maxX`, `this.minX`, `this.maxY`, and `this.minY`). By default, the `pointerEvent` (last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access `pageX`, `pageY`, `target`, `currentTarget`, etc.

* #### onPressInit[](#onPressInit)

Function - A function that should be called before the starting values are recorded in the `onPress`, allowing you to make changes before any dragging occurs. `onPressInit` always fires BEFORE `onPress`. [See demo](//codepen.io/GreenSock/pen/62fd4014cf86a9a87e632c8b4f967ed4/?editors=0010).

* #### onPressParams[](#onPressParams)

Array - An optional array of parameters to feed the `onPress` callback. For example, `onPressParams: ["drag started", 5]` would work with this code: `onPress: function(message, num) { console.log("message: " + message + ", num: " + num); }`.

* #### onRelease[](#onRelease)

Function - A function that should be called as soon as the mouse (or touch) is released after having been pressed on the target element, regardless of whether or not anything was dragged. Inside that function, `this` refers to the Draggable instance (unless you specifically set the scope using `callbackScope`), making it easy to access the target element (`this.target`) or the boundary coordinates (`this.maxX`, `this.minX`, `this.maxY`, and `this.minY`). By default, the `pointerEvent` (last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access `pageX`, `pageY`, `target`, `currentTarget`, etc.

* #### onReleaseParams[](#onReleaseParams)

Array - An optional array of parameters to feed the `onRelease` callback. For example, `onReleaseParams: ["drag ended", 5]` would work with this code: `onRelease: function(message, num) { console.log("message: " + message + ", num: " + num); }`.

* #### trigger[](#trigger)

\[*Element* | *String* | *Object*] - If you want only a certain area to trigger the dragging (like the top bar of a window) instead of the entire element, you can define a child element as the trigger, like `trigger: yourElement`, `trigger: "#topBar"`, or `trigger: $("#yourID")`. You may define the trigger as an element or a selector string

String - Indicates the type of dragging (the properties that the dragging should affect). Any of the following work: \[`"x,y"` (basically the `translateX` and `translateY` of transform) | `"left,top"` | `"rotation"` |`"x"` | `"y"` | `"top"` | `"left"`]. The default is `"x,y"`.

* #### zIndexBoost[](#zIndexBoost)

Boolean - By default, for vertical or horizontal dragging, when an element is pressed/touched, it has its `zIndex` set to a high value (`1000` by default) and that number gets incremented and applied to each new element that gets pressed/touched so that the stacking order looks correct (newly pressed objects rise to the top), but if you prefer to skip this behavior set `zIndexBoost: false`.

Draggable has advanced snapping capabilities. You can define a `snap` value in the `config` object to control where the Draggable will snap **AFTER** it is released, or you can define a `liveSnap` value where the Draggable should snap **WHILE** dragging. You can define these values in any of the following ways:

`points` is a special property that allows you to combine both `x` and `y` logic into a single place. You can also use separate per-property arrays:

Or use separate per-property functions:

It's just as simple for a rotation Draggable:

As long as you've loaded InertiaPlugin and set `inertia: true` on your Draggable, you can tap into the `InertiaPlugin.getVelocity()` method. Draggable will automatically start tracking the velocity of the necessary properties based on whatever its `type` is (`type: "x,y"` will track `x` and `y`, `type: "rotation"` will track rotation, etc.).

* In most cases, [`.pointerX`](/docs/v3/Plugins/Draggable/pointerX.md) and [`.pointerY`](/docs/v3/Plugins/Draggable/pointerY.md) should be used instead of using the event's positioning (like `.pageX`/`.pageY` or something like that) because GSAP tries to normalize positioning across all browsers.

* If you want a particular element to be "clickable", thus ignored by Draggable, simply add a `data-clickable="true"` attribute to it, or an `onclick`. By default, Draggable automatically ignores clicks on `<a>`, `<input>`, `<select>`, `<button>`, and `<textarea>` elements. If you prefer to run your own logic to determine if an object should be considered "clickable", you can set the `clickableTest` config property to a function of your choosing that returns `true` or `false`.

* Draggable can be used without InertiaPlugin, but doing so will disable any momentum-based motion (like being able to flick objects and have them continue while decelerating). These two tools go together perfectly ü´∂.

* In order to make things moveable via their `top` and `left` CSS properties, you must make sure that the elements have their `position` CSS property set to either `relative` or `absolute` (that's just how CSS works).

* By default, all callback functions and `snap` functions and `liveSnap` functions are scoped to the associated Draggable instance, so `this` refers to the Draggable instance. You can get the current horizontal or vertical values using `this.x` and `this.y` inside those functions. And if you applied bounds, you can also get the maximum and minimum "legal" values for that particular instance using `this.maxX`, `this.minX`, `this.maxY`, and `this.minY`.

* Having trouble with momentum-based motion? Make sure you have [InertiaPlugin](/docs/v3/Plugins/InertiaPlugin/.md) loaded! To use it, set `inertia: true` in the `vars` config object, like `Draggable.create(yourObject, {inertia: true});`.

* If you use an element for the bounds, it should not be rotated differently than the target element.

* If you are mixing timelines and draggable, you may need to use a proxy element. For more information see [this demo](https://codepen.io/GreenSock/pen/WNedayo).

|                                                                          |                                                                                                                                                                                                                                                              |
| ------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| #### [autoScroll](/docs/v3/Plugins/Draggable/autoScroll.md) : Number     | How fast to scroll the container element when `autoScroll` is `true`.                                                                                                                                                                                        |
| #### [deltaX](/docs/v3/Plugins/Draggable/deltaX.md) : Number             | The change in the x-related value since the last drag event.                                                                                                                                                                                                 |
| #### [deltaY](/docs/v3/Plugins/Draggable/deltaY.md) : Number             | The change in the y-related value since the last drag event.                                                                                                                                                                                                 |
| #### [endRotation](/docs/v3/Plugins/Draggable/endRotation.md) : Number   | \[read-only] \[only applies to type:"rotation"] The ending rotation of the Draggable instance which is calculated as soon as the mouse/touch is released after a drag, meaning you can use it to predict precisely where it'll land after a `inertia` flick. |
| #### [endX](/docs/v3/Plugins/Draggable/endX.md) : Number                 | \[read-only] The ending x (horizontal) position of the Draggable instance which is calculated as soon as the mouse/touch is released after a drag, meaning you can use it to predict precisely where it'll land after an `inertia` flick.                    |
| #### [endY](/docs/v3/Plugins/Draggable/endY.md) : Number                 | \[read-only] The ending y (vertical) position of the Draggable instance which is calculated as soon as the mouse/touch is released after a drag, meaning you can use it to predict precisely where it'll land after a `inertia` flick.                       |
| #### [isPressed](/docs/v3/Plugins/Draggable/isPressed.md) : Boolean      | If the Draggable is being pressed, this will be `true`                                                                                                                                                                                                       |
| #### [isThrowing](/docs/v3/Plugins/Draggable/isThrowing.md) : Boolean    | Reports if the target of a Draggable is being thrown using a InertiaPlugin tween.                                                                                                                                                                            |
| #### [lockAxis](/docs/v3/Plugins/Draggable/lockAxis.md) : Boolean        | Locks movement to one axis based on the how it is moved initially.                                                                                                                                                                                           |
| #### [lockedAxis](/docs/v3/Plugins/Draggable/lockedAxis.md) : String     |                                                                                                                                                                                                                                                              |
| #### [maxRotation](/docs/v3/Plugins/Draggable/maxRotation.md) : Number   | When bounds are applied, `maxRotation` refers to the maximum "legal" rotation.                                                                                                                                                                               |
| #### [maxX](/docs/v3/Plugins/Draggable/maxX.md) : Number                 | When bounds are applied, `maxX` refers to the maximum "legal" horizontal property.                                                                                                                                                                           |
| #### [maxY](/docs/v3/Plugins/Draggable/maxY.md) : Number                 | When bounds are applied, `maxY` refers to the maximum "legal" vertical property.                                                                                                                                                                             |
| #### [minRotation](/docs/v3/Plugins/Draggable/minRotation.md) : Number   | When bounds are applied, `minRotation` refers to the minimum "legal" rotation property.                                                                                                                                                                      |
| #### [minX](/docs/v3/Plugins/Draggable/minX.md) : Number                 | When bounds are applied, `minX` refers to the minimum "legal" horizontal property.                                                                                                                                                                           |
| #### [minY](/docs/v3/Plugins/Draggable/minY.md) : Number                 | When bounds are applied, `minY` refers to the minimum "legal" vertical property.                                                                                                                                                                             |
| #### [pointerEvent](/docs/v3/Plugins/Draggable/pointerEvent.md) : Object | \[read-only] The last pointer event (either a mouse event or touch event) that affected the Draggable instance.                                                                                                                                              |
| #### [pointerX](/docs/v3/Plugins/Draggable/pointerX.md) : Number         | \[read-only] The x (horizontal) position of the pointer (mouse or touch) associated with the Draggable's last event (like event.pageX).                                                                                                                      |
| #### [pointerY](/docs/v3/Plugins/Draggable/pointerY.md) : Number         | \[read-only] The y (vertical) position of the pointer (mouse or touch) associated with the Draggable's last event (like event.pageY).                                                                                                                        |
| #### [rotation](/docs/v3/Plugins/Draggable/rotation.md) : Number         | \[read-only] \[only applies to `type: "rotation"`] The current rotation (in degrees) of the Draggable instance.                                                                                                                                              |
| #### [startX](/docs/v3/Plugins/Draggable/startX.md) : Number             | \[read-only] The starting `x` (horizontal) position of the Draggable instance when the most recent drag began.                                                                                                                                               |
| #### [startY](/docs/v3/Plugins/Draggable/startY.md) : Number             | \[read-only] The starting `y` (vertical) position of the Draggable instance when the most recent drag began.                                                                                                                                                 |
| #### [target](/docs/v3/Plugins/Draggable/target.md) : Object             | The object that is being dragged.                                                                                                                                                                                                                            |
| #### [tween](/docs/v3/Plugins/Draggable/tween.md) : Tween                | \[read-only] The Tween instance that gets created as soon as the mouse (or touch) is released (when `inertia` is `true`). This allows you to check its `duration`, `.pause()` or `.resume()` it, change its `timeScale`, or whatever you want.               |
| #### [vars](/docs/v3/Plugins/Draggable/vars.md) : Object                 | The `vars` object passed into the constructor which stores configuration variables like `type`, `bounds`, `onPress`, `onDrag`, etc.                                                                                                                          |
| #### [x](/docs/v3/Plugins/Draggable/x.md) : Number                       | \[read-only] The current x (horizontal) position of the Draggable instance.                                                                                                                                                                                  |
| #### [y](/docs/v3/Plugins/Draggable/y.md) : Number                       | \[read-only] The current y (vertical) position of the Draggable instance.                                                                                                                                                                                    |
| #### [zIndex](/docs/v3/Plugins/Draggable/zIndex.md) : Number             | \[static] The starting zIndex that gets applied by default when an element is pressed/touched (for positional types, like `"x,y"`, `"top,left"`, etc.                                                                                                        |

|                                                                                                                                          |                                                                                                                                                                                                                                                                                                    |
| ---------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| #### [addEventListener](/docs/v3/Plugins/Draggable/addEventListener\(\).md)( ) ;                                                         |                                                                                                                                                                                                                                                                                                    |
| #### [applyBounds](/docs/v3/Plugins/Draggable/applyBounds\(\).md)( bounds:Element \| String \| Object ) ;                                | Applies new bounds to the Draggable.                                                                                                                                                                                                                                                               |
| #### [Draggable.create](/docs/v3/Plugins/Draggable/static.create\(\).md)( target:Object, vars:Object ) : Array                           | \[static] A more flexible way to create Draggable instances than the constructor (`new Draggable(...)`).                                                                                                                                                                                           |
| #### [disable](/docs/v3/Plugins/Draggable/disable\(\).md)( ) : Draggable                                                                 | Disables the Draggable instance so that it cannot be dragged anymore (unless `enable()` is called).                                                                                                                                                                                                |
| #### [enable](/docs/v3/Plugins/Draggable/enable\(\).md)( ) : Draggable                                                                   | Enables the Draggable instance.                                                                                                                                                                                                                                                                    |
| #### [enabled](/docs/v3/Plugins/Draggable/enabled\(\).md)( value:Boolean ) : Boolean                                                     | Gets or sets the enabled state.                                                                                                                                                                                                                                                                    |
| #### [endDrag](/docs/v3/Plugins/Draggable/endDrag\(\).md)( event:Object ) : void                                                         | You may force the Draggable to immediately stop interactively dragging by calling `endDrag()` and passing it the original mouse or touch event that initiated the stop - this is necessary because Draggable must inspect that event for various information like `pageX`, `pageY`, `target`, etc. |
| #### [Draggable.get](/docs/v3/Plugins/Draggable/static.get\(\).md)( target:Object ) : Draggable                                          | \[static] Provides an easy way to get the Draggable instance that's associated with a particular DOM element.                                                                                                                                                                                      |
| #### [getDirection](/docs/v3/Plugins/Draggable/getDirection\(\).md)( from:String \| Element ) : String                                   | Returns the `direction` (`"right"` \| `"left"` \| `"up"` \| `"down"` \| `"left-up"` \| `"left-down"` \| `"right-up"` \| `"right-down"`) as measured from either where the drag started (the default) or the moment-by-moment velocity, or its proximity to another element that you define.        |
| #### [Draggable.hitTest](/docs/v3/Plugins/Draggable/static.hitTest\(\).md)( testObject:Object, threshold:\[Number \| String] ) : Boolean | Provides an easy way to test whether or not the target element overlaps with a particular element (or the mouse position) according to whatever threshold you \[optionally] define.                                                                                                                |
| #### [kill](/docs/v3/Plugins/Draggable/kill\(\).md)( ) : Draggable                                                                       | Disables the Draggable instance and removes it from the internal lookup table so that it is made eligible for garbage collection and it cannot be dragged anymore (unless `enable()` is called).                                                                                                   |
| #### [startDrag](/docs/v3/Plugins/Draggable/startDrag\(\).md)( event:Object, align:Boolean ) : void                                      | Forces the Draggable to begin dragging.                                                                                                                                                                                                                                                            |
| #### [Draggable.timeSinceDrag](/docs/v3/Plugins/Draggable/static.timeSinceDrag\(\).md)( ) : Number                                       | Returns the time (in seconds) that has elapsed since the last drag ended.                                                                                                                                                                                                                          |
| #### [update](/docs/v3/Plugins/Draggable/update\(\).md)( applyBounds:Boolean, sticky:Boolean ) : Draggable                               | Updates the Draggable's x/y properties to reflect the target element's current position.                                                                                                                                                                                                           |

Check out the full collection of [How-to demos](https://codepen.io/collection/AtuHb) and our favourite [inspiring community demos](https://codepen.io/collection/DrQGpM) on CodePen.

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(Draggable)
```

Example 2 (unknown):
```unknown
Draggable.create('#yourID', {
	type: 'x'
});
```

Example 3 (unknown):
```unknown
Draggable.create('#yourID');
```

Example 4 (unknown):
```unknown
Draggable.create('#yourID', {
	type: 'y',
	bounds: document.getElementById('container'),
	inertia: true,
	onClick: function () {
		console.log('clicked');
	},
	onDragEnd: function () {
		console.log('drag ended');
	}
});
```

---

## SplitText

**URL:** https://gsap.com/docs/v3/Plugins/SplitText.md

**Contents:**
    - CDN Link
    - Minimal usage
- Features[‚Äã](#features "Direct link to Features")
- Splitting[‚Äã](#splitting "Direct link to Splitting")
  - Basic Usage[‚Äã](#basic-usage "Direct link to Basic Usage")
  - Configuration[‚Äã](#configuration "Direct link to Configuration")
- **Config Object**[‚Äã](#config-object "Direct link to config-object")
- Animating[‚Äã](#animating "Direct link to Animating")
    - loading...
  - Responsive Line Splitting\*[‚Äã](#responsive-line-splitting "Direct link to Responsive Line Splitting*")

Or use the new `onSplit()` syntax available in v3.13.0+:

SplitText is a small JavaScript library that splits an HTML element's text into individual characters, words, and/or lines (each in its own, newly-created element), allowing you to create gorgeous staggered animations. It's highly configurable and smarter than other text splitting tools thanks to features like automatic screen reader accessibility, masking for reveal effects, responsive re-splitting, and much more.

Detailed Walkthrough - Major rewrite in `v3.13.0` - half the size, 14 new features!

[YouTube video player](https://www.youtube.com/embed/L1afzNAhI40?si=yt5g94qIK6vvEyH0)

The new v3.13.0+ features are marked below with "\*"

* **Screen reader Accessibility**\* - Adds `aria-label` to the split element(s) and `aria-hidden` to the freshly-created line/word/character elements.
* **Responsive re-splitting**\* - Avoid funky line breaks when resizing or when fonts load with `autoSplit` and `onSplit()`. Offers automatic cleanup and resuming of animations too!
* **Slice right through nested elements**\* - Elements like `<span>`, `<strong>`, and `<a>` that span multiple lines are handled effortlessly with `deepSlice` so they don't stretch lines vertically.
* **Masking**\* - Wrap characters, words or lines with an extra clipping element for easy mask/reveal effects.
* **Integrates seamlessly** with GSAP's [`context()`](/docs/v3/GSAP/gsap.context\(\).md), [`matchMedia()`](/docs/v3/GSAP/gsap.matchMedia\(\).md) and [`useGSAP()`](/resources/React.md)
* **Flexible targeting** - Apply your own class names to characters, words, or lines. Append `"++"` to auto-increment them (e.g. `word1`, `word2`, etc.). Enable `propIndex`\* to apply CSS variables like `--word: 3`.
* **Ignore certain elements**\* - Perhaps you'd like to leave `<sup>` elements unsplit, for example.
* **Supports emojis & more** - SplitText does an excellent job with foreign characters too.
* **Revert anytime** - Restore the element's original `innerHTML` anytime with `revert()`
* **Handle complex edge cases** with custom `RegExp`\* or `prepareText()`\*

Feed `SplitText.create()` the element(s) you'd like to split and it'll return a SplitText instance with `chars`, `words`, and `lines` properties where you can access the resulting elements.

By default, SplitText will split by `type: "lines, words, chars"` (meaning lines, words, **and** characters) but to maximize performance you should really only split what you need. Use the configuration object to control exactly which components are split apart, or to adjust accessibility settings, or apply your own classes or even apply masking effects.

"auto" | "hidden" | "none" - SplitText can automatically add `aria` attributes to the split element(s) as well as the line/word/character elements to improve accessibility. The options are:

* `"auto"` (the default) - adds an [aria label](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-label) to the split element(s), populated by its `textContent`, and also adds [aria hidden](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-hidden) to the line/word/character elements inside the split. This ensures that the text is accessible to the majority of screen readers. **This approach will not honor the semantics or functionality of nested elements.** If you need to ensure that links inside your text content are visible to screen readers, we recommend enabling `aria: "hidden"` and creating a duplicate screen reader-only copy of your text.
  * `"hidden"`: adds [aria hidden](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-hidden) to the split element and all of the line/word/character elements inside the split.
  * `"none"` - does not add any `aria` attributes to the split element or the line/word/character elements inside the split.

* #### autoSplit\*[](#autoSplit*)

Boolean - Helps avoid odd line breaks due to text reflow after the fonts finish loading or if the element's width changes. If `true`, SplitText will revert and re-split whenever the fonts finish loading or when **both** of the following conditions apply:

1. The width of the split element(s) changes
  2. `"lines"` are split.

SplitText will even `console.warn()` you if you try splitting before the fonts finish loading and you didn't set `autoSplit: true`

When using `autoSplit: true`, make sure to create any animations in an `onSplit()` callback so that the freshly-split line/word/character elements are the ones being animated. If you `return` the animation in the `onSplit()`, SplitText will automatically clean up and synchronize the animation on each re-split.

* #### charsClass[](#charsClass)

String - A CSS class applied to each character's `<div>`, making it easy to select. If you add `"++"` to the end of the class name, SplitText will also add a second class of that name but with an incremented number appended, starting at 1. For example, if `charsClass` is `"char++"`, the the first character would have `class="char char1"`, the next would have `class="char char2"`, then `class="char char3"`, etc. Default: `undefined`.

* #### deepSlice\*[](#deepSlice*)

Boolean - If a nested element like `<strong>` wraps onto multiple lines, SplitText subdivides it accordingly so that it doesn't expand the line vertically. So technically one nested element could be split up into multiple elements. This is only effective for splitting `lines`. Default: `true`.

* #### ignore\*[](#ignore*)

String | Element - Descendant elements to ignore when splitting (you may use selector text like `".split"` or an Array of elements). They will still exist - they simply won't be split [Demo here](https://codepen.io/GreenSock/pen/JojaebV) Default: `undefined`

* #### linesClass[](#linesClass)

String - A CSS class applied to each line's `<div>`, making it easy to select. If you add `"++"` to the end of the class name, SplitText will also add a second class of that name but with an incremented number appended, starting at 1. For example, if `linesClass` is `"line++"`, the the first line would have `class="line line1"`, the next would have `class="line line2"`, then `class="line line3"`, etc. Default: `undefined`.

* #### mask\*[](#mask*)

"lines" | "words" | "chars" - wraps every line or word or character in an *extra* element with `visibility: clip` for much simpler reveal effects. Access them in a "masks" Array on the SplitText instance. If you set a class name for the lines/words/chars, it'll append `"-mask"` for easy selecting. You cannot mask multiple types, so this value should be either "lines" or "words" or "chars" but not a combination. Default: `undefined`

* #### onRevert\*[](#onRevert*)

Function - A function that gets called whenever the SplitText instance reverts

* #### onSplit\*[](#onSplit*)

Function - A function that gets called whenever the SplitText instance finishes splitting, including when `autoSplit: true` causes it to re-split, like when the fonts finish loading or when the width of the split element(s) changes (which often makes lines reflow). If you return a GSAP animation (tween or timeline), it will automatically save its `totalTime()` and `revert()` it when the SplitText reverts, and set the new animation's `totalTime()` that's returned in the `onSplit`, making it appear relatively seamless!

* #### prepareText\*[](#prepareText*)

Function - A function that gets called for each block of text as the split occurs, allowing you to modify each chunk of text right before SplitText runs its splitting logic. For example, you might want to insert some special characters marking where word breaks should occur. The `prepareText()` function receives the raw text as the first argument, and the parent element as the second argument. You should **return** the modified text. This can be useful for non-Latin languages like Chinese, where there are no spaces between words. [Demo here](https://codepen.io/GreenSock/pen/VYYvwoq/f30d0213097fe1c8c5a0a09215a5568f)

* #### propIndex\*[](#propIndex*)

Boolean - adds a CSS variable to each split element with its index, like `--word: 1`, `--word: 2`, etc. It works for all types (line, word, and char). Default: `false`

* #### reduceWhiteSpace[](#reduceWhiteSpace)

Boolean - Collapses consecutivewhite space characters into one, as most browsers typically do. Set to `false` if you prefer to maintain multiple consecutive white space characters. Since **v3.13.0** reduceWhiteSpace will honor extra spaces and automatically insert `<br>` tags for line breaks which is useful for `<pre>` content. Default: `true`

* #### smartWrap\*[](#smartWrap*)

Boolean - If you split by `"chars"` only, you can end up with odd breaks at the very end of lines when characters in the middle of a word flow onto the next line, untethered by natural word-grouping. `smartWrap: true` will wrap words in a `<span>` that has `white-space: nowrap` to keep them grouped (only when you're not splitting by words or lines). This will be ignored if you're splitting by `"words"` or `"lines"`, as it's unnecessary. Default: `false`

String - By default, SplitText wraps things in `<div>` elements, but you can define any tag like `tag: "span"`. Note that browsers won't render transforms like rotation, scale, skew, etc. on inline elements.

String - A comma-delimited list of the split type(s) which can be any combination of the following: `chars`, `words`, or `lines`. This indicates the type of components you‚Äôd like split apart into distinct elements. For example, to split apart the characters and words (not lines), you‚Äôd use `type: "chars,words"` or to only split apart lines, you‚Äôd do `type: "lines"`. In order to avoid odd line breaks, it is best to not split by chars alone (always include words or lines too if you're splitting by characters) or just set `smartWrap: true`. Note: spaces are not considered characters. Default: `"chars,words,lines"`.

* #### wordDelimiter[](#wordDelimiter)

RegExp | "string" | Object - Normally, words are split at every space character. The `wordDelimiter` property allows you to specify your own custom delimiter for words. For example, if you want to split a hashtag like **#IReallyLoveGSAP** into words, you could insert a zero-width word joiner character (`&#8205;`) between each word like: `#&#8205;I&#8205;Really&#8205;Love&#8205;GSAP` and then set `wordDelimiter: String.fromCharCode(8205)` in the SplitText config object. Since **v3.13.0**, you can specify where to split using a RegExp and also what text to swap in at those spots for ultimate flexibility like

Default: `" "` (space)

* #### wordsClass[](#wordsClass)

String - A CSS class applied to each word's `<div>`, making it easy to select. If you add `"++"` to the end of the class name, SplitText will also add a second class of that name but with an incremented number appended, starting at 1. For example, if `wordsClass` is `"word++"`, the the first word would have `class="word word1"`, the next would have `class="word word2"`, then `class="word word3"`, etc. Default: `undefined`.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/xxmaNYj?default-tab=result\&theme-id=41164)

Once your text is split, you can animate each line, word, or character using GSAP:

Or use the new `onSplit()` syntax available in v3.13.0+ to do the exact same thing - the main benefit is that the code inside `onSplit()` will execute anytime the SplitText instance **re-splits** in the future (like if you set `autoSplit: true` or if you manually call `split()`):

If *only* words and/or characters are split, they reflow naturally when the container resizes but if you split by **lines**, each line element encloses around a specific set of words/characters. If the container then resizes narrower *or* if the font loads after the split, for example, the text may reflow causing some of the words to belong in *different* lines (the last word in a line may shift down to the next). The only way to avoid strange line breaks is to re-split (restore the original `innerHTML` and have SplitText run its splitting logic again) so that the line elements enclose the proper words.

Don't worry! SplitText's `autoSplit` saves the day! ü•≥ When enabled, it will revert and re-split when fonts finish loading or when **both** of the following conditions apply:

* The width of the split element(s) changes
* "lines" are split.

With `autoSplit` enabled, you should **always** create your animations in the `onSplit()` callback so that if it re-splits later, the resulting animations affect the freshly-created line/word/character elements instead of the ones from the previous split. If you **return** your [`tween`](/docs/v3/Plugins/SplitText/docs/v3/GSAP/Tween/) or [`timeline`](/docs/v3/Plugins/SplitText/docs/v3/GSAP/Timeline/) inside the `onSplit()` callback, your old animation will be safely `reverted()` before the new one is created and SplitText will automatically save the previous animation's `totalTime()` before reverting it, and apply it to the new one so that everything appears relatively seamless! The SplitText instance is passed to the `onSplit()` (below, we call it `self`) so you can access its properties:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/2f1edfd9d9462aa26150669eb528fb5f?default-tab=result\&theme-id=41164)

Masking wraps each line, word or character in an *extra* element with `visibility: clip` for fun reveal effects.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/a28f78aa1b47e6fa3ad56684564fdf81?default-tab=result\&theme-id=41164)

People who are blind or partially-sighted might use a screen reader which analyzes the content of a site and converts it into speech to help them navigate a website. A screen reader would see the following heading tag and read it out loud.

Most text splitting libraries simply divide the text into divs which screen readers verbalize **painfully** slowly, letter by letter...

To get around this issue, SplitText adds an [`aria-label`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-label) to the parent element and then hides the child elements with [`aria-hidden`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-hidden). This ensures that when visually impaired people navigate your site, screen readers will read the `aria-label` instead of the contents of the split elements. ü•≥ This approach works for the majority of use-cases and is enabled by default.

SplitText's built in `aria: "auto"` solution is ideal for most common scenarios, but it won't surface the functionality and meaning of nested elements (like links) to screen readers. If you have complex nested text, you can use the duplication approach described below. Exercise restraint here as duplicating lots of DOM elements can lead to performance lags.

Treat text splitting with care and ensure you test thoroughly!

In the example below, the link may not be recognized as such by some screen readers:

If you need to preserve the semantics and functionality of nested elements - like links, `<strong>` tags or `<em>` tags - we recommend disabling the default aria settings for the SplitText with `aria: "none"`\*, and creating a [screen reader-only](https://css-tricks.com/inclusively-hidden/) duplicate of your element instead. This way, sighted users will see the animated text, while visually impaired people will get the screenreader-only content announced to them.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/12697152a77fa81cefd0e6bb3d87c2da?default-tab=result\&theme-id=41164)

Performance-wise, it can be expensive for browsers to render a lot of nodes/elements, so it's often a good idea to `revert()` your split elements to their original state when you're done animating them. Simply call `revert()` on the SplitText instance to restore the original `innerHTML`:

* **Characters shift slightly when splitting?** - Some browsers apply kerning between certain characters which is lost when each character is put into its own element, thus the spacing shifts slightly. You can typically eliminate that shift by disabling the kerning with this CSS:

* **Custom Fonts** - If you split before your web fonts are ready, the layout may shift or misalign. To avoid this, either:

* Wait for the fonts to load before splitting by placing your code inside `document.fonts.ready.then(() => {...your code here...})`, or
  * Set `autoSplit: true` to have SplitText re-split once fonts finish loading. Don't forget to put your animation code inside the `onSplit()` callback!

* **Only split what you need** - Splitting thousands of elements can be expensive. If you‚Äôre only animating words or lines, skip splitting characters for better performance.

* **SEO** - If you split your main `<h1/>` element, ensure that your page has the appropriate title and description meta tags and your SplitText has `aria: "auto"` (default) enabled. Without these your split heading may appear in google search results in it's composite parts.

* **Avoid text-wrap: balance** - it interferes with clean text splitting.

* **SVG** - SplitText is not designed to work with SVG `<text>` nodes.

* **Standalone plugin** - SplitText is one of the only GSAP plugins that *can* be used **without** loading GSAP's core.

Check out the full collection of [text animation demos](https://codepen.io/collection/ExBwoK) on CodePen.

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(SplitText)
```

Example 2 (unknown):
```unknown
// split elements with the class "split" into words and characters
let split = SplitText.create(".split", { type: "words, chars" });

// now animate the characters in a staggered fashion
gsap.from(split.chars, {
  duration: 1, 
  y: 100,       // animate from 100px below
  autoAlpha: 0, // fade in from opacity: 0 and visibility: hidden
  stagger: 0.05 // 0.05 seconds between each
});
```

Example 3 (unknown):
```unknown
SplitText.create(".split", {
  type: "lines, words",
  mask: "lines",
  autoSplit: true,
  onSplit(self) {
    return gsap.from(self.words, {
      duration: 1, 
      y: 100, 
      autoAlpha: 0, 
      stagger: 0.05
    });
  }
});
```

Example 4 (unknown):
```unknown
// the target can be selector text, an element, or an Array of elements
let split = SplitText.create(".headline");

// Array of characters
split.chars

// Array of words
split.words

// Array of lines
split.lines
```

---

## .vars

**URL:** https://gsap.com/docs/v3/Plugins/SplitText/vars.md

**Contents:**
  - .vars : Object
  - Details[‚Äã](#details "Direct link to Details")
- Example[‚Äã](#example "Direct link to Example")

\[read-only] The vars configuration object used to create the SplitText instance

\[read-only] The vars configuration object used to create the SplitText instance.

You can store arbitrary data in the `vars` object if you want; SplitText will just ignore the properties it doesn't recognize. So, for example, you could add a "group" property so that you could group your Splits and then later to kill() all the SplitText instances from a particular group, you could do:

**Examples:**

Example 1 (unknown):
```unknown
let splitText = SplitText.create({
  type: "chars,words",
  wordsClass: "word++",
});

console.log(splitText.vars); // {type: "chars,words",wordsClass: "word++",}
```

Example 2 (unknown):
```unknown
// helper function (reusable):
let getGroup = (group) =>
  SplitText.getAll().filter((t) => t.vars.group === group);

// then, to kill() anything with a group of "my-group":
getGroup("my-group").forEach((t) => t.kill());
```

---

## track

**URL:** https://gsap.com/docs/v3/Plugins/InertiaPlugin/VelocityTracker/.track.md

**Contents:**
  - Returns : VelocityTracker[‚Äã](#returns--velocitytracker "Direct link to Returns : VelocityTracker")
- Details[‚Äã](#details "Direct link to Details")
- What kinds of properties can be tracked?[‚Äã](#what-kinds-of-properties-can-be-tracked "Direct link to What kinds of properties can be tracked?")

A VelocityTracker object that's responsible for doing the tracking.

Allows you to have the velocity of particular properties automatically tracked for you so that InertiaPlugin tweens can access that data internally instead of manually calculating it and feeding it into each tween. For example, let's say there's an object that the user interacts with by dragging it or maybe it is being tweened and then at some point you want to create a `throwProps` tween that smoothly continues that motion and glides to a rest. Normally, you'd need to write your own tracking code that records that object's `x` and `y` properties and the time stamps so that when it comes time to feed the `velocity` into the `throwProps` tween, you'd have the necessary data to calculate it. But let's face it: that can be cumbersome to do manually, and that's precisely why the `track()` method exists.

Just feed in the target and a comma-delimited list of its properties that you want tracked like this:

Then every time the core tweening engine updates (at whatever frame rate you're running), the `x` and `y` values (or whichever properties you define) will be recorded along with time stamps (it keeps a maximum of 2 of these values and continually writes over the previous ones, so don't worry about memory buildup). This even works with function-based properties like getters and setters.

Then, after at least 100ms and 2 "ticks" of the core engine have elapsed (so that some data has been recorded), you can create `throwProps` tweens for those properties and omit the `velocity` values and it will automatically populate them for you internally. For example:

Notice that `"auto"` is a valid option when you're tracking the properties too, but only for tracked properties.

Pretty much any numeric property of any object can be tracked, including function-based ones. For example, `obj.x` or `obj.rotation` or even `obj.myCustomProp()`. In fact, for getters and setters that start with the word "get" or "set" (like `getCustomProp()` and `setCustomProp()`), it will automatically find the matching counterpart method and use the getter appropriately, so you can track the getter or setter and it'll work. You cannot, however, track custom plugin-related values like `directionalRotation`, `autoAlpha`, or `physics2D` because those aren't real properties of the object. You should instead track the real properties that those plugins affect, like `rotation`, `alpha`, `x`, or `y`.

You should `untrack()` properties when you no longer need them tracked in order to maximize performance and ensure things are released for garbage collection. To untrack, simply use the [`untrack()`](/docs/v3/Plugins/InertiaPlugin/VelocityTracker/docs/v3/Plugins/InertiaPlugin/VelocityTracker/.untrack\(\)) method.

**Examples:**

Example 1 (unknown):
```unknown
InertiaPlugin.track(obj, "x,y");
```

Example 2 (unknown):
```unknown
//first, start tracking "x" and "y":
InertiaPlugin.track(obj, "x,y");

//then, after at least 100ms, let's smoothly tween to EXACTLY x:200, y:300
gsap.to(obj, {duration: 2, throwProps: {x: {end: 200}, y: {end: 300}}, ease: "Strong.easeOut"});

//and if you want things to use the defaults and have obj.x and obj.y glide to a stop based on the velocity rather than setting any destination values, just use "auto":
gsap.to(obj, {duration: 2, throwProps: {x: "auto", y: "auto"}, ease: "Strong.easeOut"});
```

---

## EndArray

**URL:** https://gsap.com/docs/v3/GSAP/CorePlugins/EndArray.md

What are internal plugins?

EndArrayPlugin is an internal plugin, It is **automatically included in GSAP's core** and **doesn't have to be loaded using gsap.registerPlugin()**.

You can think of internal plugins as just a part of GSAP.

The endArray plugin enables you to tween an Array of numeric values to a different Array of numeric values with easing applied.

If you have Arrays of uneven lengths, only the indexes that are in both Arrays will be animated.

**Examples:**

Example 1 (unknown):
```unknown
const arr = [1, 2, 3];

gsap.to(arr, {
  endArray: [5, 6, 7],
  onUpdate() {
    console.log(arr);
  },
});
```

---

## target

**URL:** https://gsap.com/docs/v3/Plugins/InertiaPlugin/VelocityTracker/.target.md

**Contents:**
  - Returns: Object[‚Äö√Ñ√£](#returns-object "Direct link to Returns: Object")

Returns the target object with which the VelocityTracker is associated.

---

## VelocityTracker

**URL:** https://gsap.com/docs/v3/Plugins/InertiaPlugin/VelocityTracker.md

**Contents:**
- Description[‚Äã](#description "Direct link to Description")
- What kinds of properties can be tracked?[‚Äã](#what-kinds-of-properties-can-be-tracked "Direct link to What kinds of properties can be tracked?")

Allows you to have the velocity of particular properties automatically tracked for you so that you can access them anytime using the VelocityTracker's `getVelocity()` method, like `myTracker.getVelocity("y")`.

For example, let's say there's an object that the user interacts with by dragging it or maybe it is being tweened and then at some point you want to create a tween based on that velocity. Normally, you'd need to write your own tracking code that records that object's `x` and `y` properties (as well as time stamps) so that when it comes time to feed the `velocity` into whatever other code you need to run, you'd have the necessary data to calculate it. But let's face it: that can be cumbersome to do manually, and that's precisely why VelocityTracker exists.

VelocityTracker is in the InertiaPlugin JavaScript file. You can access the important methods directly through InertiaPlugin, like `InertiaPlugin.track()`.

Use the static `VelocityTracker.track()` method to start tracking properties. *You generally should **not** use the VelocityTracker's constructor because there needs to only be one VelocityTracker instance associated with any particular object.* The `track()` method will return the instance that you can then use to `getVelocity()` like:

Pretty much any numeric property of any object can be tracked, including function-based ones. For example, `obj.x` or `obj.rotation` or even `obj.myCustomProp()`. In fact, for getters and setters that start with the word "get" or "set" (like `getCustomProp()` and `setCustomProp()`), it will automatically find the matching counterpart method and use the getter appropriately, so you can track the getter or setter and it'll work. You **cannot**, however, track custom plugin-related values like `directionalRotation`, `autoAlpha`, or `physics2D` because those aren't real properties of the object. You should instead track the real properties that those plugins affect, like `rotation`, `alpha`, `x`, or `y`.

This class is used in InertiaPlugin to make it easy to create velocity-based tweens that smoothly transition an object's movement (or rotation or whatever) and glide to a stop.

In order to report accurately, at least 100ms and 2 ticks of the core tweening engine must have been elapsed before you check velocity.

**Examples:**

Example 1 (unknown):
```unknown
// first, start tracking "x" and "y":
var tracker = VelocityTracker.track(obj, "x,y")[0];
//then, after at least 100ms and 2 "ticks", we can get the velocity of each property:
var vx = tracker.get("x");var vy = tracker.get("y");
```

---

## event

**URL:** https://gsap.com/docs/v3/Plugins/Observer/event.md

**Contents:**
  - event : Event
  - Details[‚Äã](#details "Direct link to Details")

The most recent Event object (could be a TouchEvent, PointerEvent, MouseEvent, WheelEvent, or ScrollEvent based on whatever `type` you define)

The most recent Event object (could be a TouchEvent, PointerEvent, MouseEvent, WheelEvent, or ScrollEvent based on whatever `type` you define). For example, if your Observer has `type: "touch,pointer"` and you press down and drag with your mouse, the `event` would be a PointerEvent or MouseEvent based on your browser/device. This allows you to get whatever information you need from that event like pageX, pageY, etc. For touch and pointer events, the event.clientX and event.clientY are automatically saved to the "x" and "y" properties of the Observer for convenience.

---

## Observer

**URL:** https://gsap.com/docs/v3/Plugins/Observer.md

**Contents:**
    - CDN Link
    - Minimal usage
  - Observer is included in ScrollTrigger too\![‚Äã](#observer-is-included-in-scrolltrigger-too "Direct link to Observer is included in ScrollTrigger too!")
- Demo[‚Äã](#demo "Direct link to Demo")
    - loading...
- **Config Object**[‚Äã](#config-object "Direct link to config-object")
- Callback data[‚Äã](#callback-data "Direct link to Callback data")
- Showcase & how-to demos[‚Äã](#showcase--how-to-demos "Direct link to Showcase & how-to demos")
- **Properties**[‚Äã](#properties "Direct link to properties")
- **Methods**[‚Äã](#methods "Direct link to methods")

added in v<!-- -->3.10.0

Super-flexible, unified way to sense meaningful events across all (touch/mouse/pointer) devices without wrestling with all the implementation details. Perhaps you want to respond to "scroll-like" user behavior which could be a mouse wheel spin, finger swipe on a touch device, a scrollbar drag, or a pointer press & drag...and of course you need directional data and velocity. No problem!

[YouTube video player](https://www.youtube.com/embed/spW7GsvQ_y0)

Tell Observer which event types to watch (wheel, touch, pointer, and/or scroll) and it will collect delta values over the course of each requestAnimationFrame tick ([debounced](https://css-tricks.com/debouncing-throttling-explained-examples/) for performance by default) and automatically determine the biggest delta and then trigger the appropriate callback(s) like `onUp`, `onDown`, `onDrag`, etc. (see the full list below).

Look how easy it is to trigger next()/previous() functions based on when the user swipes up/down or uses their mouse wheel:

There's a [ScrollTrigger.observe()](/docs/v3/Plugins/ScrollTrigger/static.observe\(\).md) method that's identical to `Observer.create()`. Since ScrollTrigger's [normalizeScroll()](/docs/v3/Plugins/ScrollTrigger/static.normalizeScroll\(\).md) functionality leverages Observer under the hood (thus it's included inside ScrollTrigger anyway), it made sense to expose its functionality so that you can avoid loading Observer as a separate file if you're already using ScrollTrigger in your project. You're welcome. üôÇ

Notice there's no actual scrolling in the demo below but you can use your mouse wheel (or swipe on touch devices) to initiate movement so it "feels" like a scroll:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/XWzRraJ?default-tab=result\&theme-id=41164)

* **Rich callback system** including onDown, onUp, onLeft, onRight, onDrag, onDragStart, onDragEnd, onHover, onHoverEnd, onToggleY, onToggleX, onChangeX, onChangeY, onChange, onClick, onPress, onRelease, onMove, onWheel, and onStop
* **Debounced** by default for maximum performance (you can set `debounce: false` if you prefer)
* **Cross-browser compatible** - automatically senses if TouchEvents, PointerEvents, or MouseEvents should be used.
* Automatically prioritizes the event with the **largest delta** (like if a wheel and scroll and touch event all occur during the same debounced period)

* Ignore certain elements, like `ignore: ".deadzone"`
* Get **velocity** (on x and y axis separately) as well as the clientX and clientY coordinates (for touch/pointer events)
* Set a **minimum threshold for dragging**. For example, dragMinimum: 5 would only fire the onDragStart/onDrag/onDragEnd callbacks if the user moved 5 pixels or more.
* Set a **tolerance** so that the movement-related callbacks only fire when a minimum delta is reached, so `tolerance: 50` would wait until there has been a change of at least 50 pixels, and then once that's reached it starts over.
* Set a **wheelSpeed** multiplier if you'd like to tweak the wheel-related deltas (speed them up or slow them down).
* Integrated with GSAP and [ScrollTrigger](/docs/v3/Plugins/ScrollTrigger/.md)
* Roughly **3.5kb gzipped**

The configuration object that is passed to `Observer.create()` can have any of the following optional properties:

string - when `lockAxis: true` is set, the first drag movement (with type: "pointer" and/or "touch") after each press will set the `axis` property to "x" or "y", depending on which direction the user moved. You can use the `onLockAxis()` callback to know when it gets set.

* #### capture[](#capture)

Boolean - if `true`, it will make the touch/pointer-related listeners use the capture phase. Like doing addEventListener("\[type]", func, {capture: true});

* #### debounce[](#debounce)

Boolean - by default, Observer will debounce events so that deltas are additive over the course of each requestAnimationFrame() tick in order to maximize performance, but you can disable that with `debounce: false` in which case it will check immediately on every event. The debounce affects all callbacks except `onPress`, `onRelease`, `onHover`, `onHoverEnd`, `onClick`, `onDragStart`, and `onDragEnd` because those aren't delta-related.

* #### dragMinimum[](#dragMinimum)

Number - the minimum distance (in pixels) necessary to be considered "dragging". This can help prevent tiny motions especially on touch devices from indicating intent. For example, just pressing down with a finger on a phone may register slight movement of a few pixels even though the user thinks their finger was stationary. dragMinimum only applies to the initial movement after pressing down, but continued dragging thereafter would only be subject to "tolerance" throttling.

String - an arbitrary string ID which an be used to get the Observer via [Observer.getById()](/docs/v3/Plugins/Observer/static.getById\(\).md).

* #### ignore[](#ignore)

Element | String | Array - elements that you'd like the observer to **IGNORE**, so that when a scroll/touch/pointer/mouse event is triggered by one of these elements, it gets ignored completely. It checks the `event.target` to discern if the event should be ignored. You can define `ignore` as an Element reference, selector text like `".ignore-me"`, or an Array of elements (it can be as many as you'd like).

* #### lockAxis[](#lockAxis)

Boolean - if `true`, the Observer will watch the direction of the very first drag move after each press (with type: "pointer" and/or "touch") and lock into that direction until the user releases the pointer/touch. So if the first drag is horizontal, then only the horizontal-related callbacks like `onChangeX()` will fire until the pointer/touch is released. There's even an `onLockAxis()` callback that you can tie into.

* #### onChange[](#onChange)

Function - function to call when there is movement on **either** the y-axis (vertically) **or** the x-axis (horizontally). It will keep calling the function as long as the movement continues (subject to any tolerance threshold).

* #### onChangeX[](#onChangeX)

Function - function to call when there is movement on the x-axis (horizontally). It will keep calling the function as long as the movement continues (subject to any tolerance threshold).

* #### onChangeY[](#onChangeY)

Function - function to call when there is movement on the y-axis (vertically). It will keep calling the function as long as the movement continues (subject to any tolerance threshold).

* #### onClick[](#onClick)

Function - function to call when the target is clicked.

* #### onDown[](#onDown)

Function - function to call when downward motion is detected, meaning the delta values increase (like dragging your finger/mouse DOWNWARD...which makes the `y` coordinate *increase*). If you want to invert only the mouse wheel delta, you can set `wheelSpeed: -1` because it's a multiplier.

* #### onDragStart[](#onDragStart)

Function - function to call when the user presses down on the target and then begins dragging (subject to `dragMinimum`). This only applies to "touch" and/or "pointer" types.

* #### onDrag[](#onDrag)

Function - function to call when the user moves the pointer/touch/mouse **while pressing** on the target element (only applies to "touch" and/or "pointer" types).

* #### onDragEnd[](#onDragEnd)

Function - function to call when the user stops dragging on the target element (only applies to "touch" and/or "pointer" types).

* #### onLeft[](#onLeft)

Function - function to call when motion is detected toward the left direction.

* #### onLockAxis[](#onLockAxis)

Function - function to call when the axis gets locked (requires `lockAxis: true`). You can check which axis via the Observer's `axis` property ("x" or "y").

* #### onHover[](#onHover)

Function - function to call when the pointer/mouse hovers over the target ("pointerenter"/"mouseenter" event).

* #### onHoverEnd[](#onHoverEnd)

Function - function to call when the pointer/mouse moves off the target ("pointerleave"/"mouseleave" event).

* #### onMove[](#onMove)

Function - function to call when the user moves the pointer/mouse while hovered over the target element (only applies to "pointer" types). It listens for "pointermove"/"mousemove" events internally. Use `onDrag` if you want it to fire only while pressing and dragging. Note that when you define an onMove, it causes the Observer to measure delta values **while hovering** over the target, consequently triggering the appropriate movement-related callbacks like onUp, onDown, onChange, etc. for any pointer/mouse movement while over the target. Normally the movement-related callbacks are only triggered when the user **presses and drags**.

* #### onPress[](#onPress)

Function - function to call when the user presses down on the target element (only applies to "touch" and/or "pointer" types).

* #### onRelease[](#onRelease)

Function - function to call when the touch/pointer is released after the `onPress` was called (only applies to "touch" and/or "pointer" types).

* #### onRight[](#onRight)

Function - function to call when motion is detected toward the right direction.

* #### onStop[](#onStop)

Function - function to call when changes have ceased for at least 0.25 seconds (configurable with `onStopDelay`)

* #### onStopDelay[](#onStopDelay)

Number - number of seconds to wait after changes have ceased firing before the `onStop` gets called (default: 0.25 seconds).

* #### onToggleX[](#onToggleX)

Function - function to call when motion **switches direction** on the x-axis (horizontally).

* #### onToggleY[](#onToggleY)

Function - function to call when motion **switches direction** on the y-axis (vertically).

Function - function to call when upward motion is detected, meaning the delta values decrease (like dragging your finger/mouse UPWARD...which makes the `y` coordinate decrease). If you want to invert only the mouse wheel delta, you can set `wheelSpeed: -1` because it's a multiplier.

* #### onWheel[](#onWheel)

Function - function to call when the mouse wheel is used.

* #### scrollSpeed[](#scrollSpeed)

Number - a multiplier for scroll delta values. This only applies to type `"scroll"`, meaning when the target dispatches a scroll event which is different than a wheel event. You could set `scrollSpeed: -1` to invert the delta values and have it call `onUp` instead of `onDown` (and vice versa). `scrollSpeed: 0.5` would make the delta values *half* of what they'd normally be. *Note: there's also a separate&#x20;*`wheelSpeed`*&#x20;option that only applies to wheel events.*

* #### target[](#target)

Element | String - the element whose events should be listened for. By default, it's the main viewport.

* #### tolerance[](#tolerance)

Number - the minimum distance (in pixels) necessary to trigger one of the callbacks like `onUp`, `onDown`, `onChangeY`, etc. So, for example, if the tolerance is 10 but the user only moves 8 pixels, no callback will be fired. Once the distance exceeds the tolerance amount, it fires the callbacks and resets, waiting for that distance to be exceeded again before firing the callback(s).

String - a comma-delimited list of the types of actions you'd like to listen for which can include any (or all) of the following: `"wheel,touch,scroll,pointer"`. "touch" works on any touch devices regardless of browser (iOS/Android may use TouchEvents under the hood whereas Microsoft may use PointerEvents but Observer includes them both in "touch"). "pointer" covers any non-touch pointer/mouse press/drag/swipe movements. "wheel" is for mouse wheel movements, and "scroll" is for scroll events. *Default is* `"wheel,touch,pointer"`

* #### wheelSpeed[](#wheelSpeed)

Number - a multiplier for wheel delta values. By default, it merely passes along the wheel event's delta that the browser reports but perhaps it seems faster/slower than when you press/drag with the pointer and you need a way to make them more similar. To make the wheel delta values half of what they normally are, for example, you'd do `wheelSpeed: 0.5`. You could set `wheelSpeed: -1` to invert the delta values and have it call `onUp` instead of `onDown` (and vice versa). *Note: there's also a separate&#x20;*`scrollSpeed`*&#x20;option that only applies to scroll events.*

Each callback is passed the Observer instance itself as the only parameter so that you can easily access data like `self.velocityX`, `self.velocityY`, `self.deltaX`, `self.deltaY`, `self.x`, `self.y`, etc. (see the sidebar to the left for a list of all the available properties) like:

There's a list of properties in the nav bar to the left.

* [Observer showcase](https://codepen.io/collection/KpNYOd/b1f3f64ef53f0b3dc1c7d5fb6203ebc7)

|                                                                               |                                                                                                                                                                                                                                                                                                                                                                             |
| ----------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| #### [deltaX](/docs/v3/Plugins/Observer/deltaX.md) : Number                   | The amount of change (in pixels) horizontally since the last time a callback was fired on that axis. For example, `onChangeX` or `onRight`                                                                                                                                                                                                                                  |
| #### [deltaY](/docs/v3/Plugins/Observer/deltaY.md) : Number                   | The amount of change (in pixels) vertically since the last time a callback was fired on that axis. For example, `onChangeY` or `onDown`                                                                                                                                                                                                                                     |
| #### [event](/docs/v3/Plugins/Observer/event.md) : Event                      | The most recent Event object (could be a TouchEvent, PointerEvent, MouseEvent, WheelEvent, or ScrollEvent based on whatever `type` you define)                                                                                                                                                                                                                              |
| #### [isDragging](/docs/v3/Plugins/Observer/isDragging.md) : Boolean          | When the user presses on the `target` and drags more than the `dragMinimum` (0 by default), `isDragging` is set to `true` until the touch/pointer is released (even if the user continues dragging *outside the bounds of the target*).                                                                                                                                     |
| #### [isEnabled](/docs/v3/Plugins/Observer/isEnabled.md) : Boolean            | Indicates whether or not the Observer is enabled. Use the `enable()` and `disable()` methods to set the state. When an Observer is disabled, it removes all of its event listeners from the target and obviously won't trigger any callbacks. There are `onEnable` and `onDisable` callbacks, though, which of course would be called when you enable/disable the Observer. |
| #### [isPressed](/docs/v3/Plugins/Observer/isPressed.md) : Boolean            | Set to `true` while the user presses on the target (only applies to `type` of "pointer" and "touch")                                                                                                                                                                                                                                                                        |
| #### [startX](/docs/v3/Plugins/Observer/startX.md) : Number                   | The `clientX` from the most recent `onPress` touch/pointer event, which refers to the horizontal distance from the left edge of the viewport. This only gets updated if you set the `type` to include "touch" and/or "pointer". It's quite useful for dragging logic.                                                                                                       |
| #### [startY](/docs/v3/Plugins/Observer/startY.md) : Number                   | The `clientY` from the most recent `onPress` touch/pointer event, which refers to the vertical distance from the top edge of the viewport. This only gets updated if you set the `type` to include "touch" and/or "pointer". It's quite useful for dragging logic.                                                                                                          |
| #### [Observer.isTouch](/docs/v3/Plugins/Observer/static.isTouch.md) : Number | A way to discern the touch capabilities of the current device - `0` is mouse/pointer only (no touch), `1` is touch-only, `2` accommodates both.                                                                                                                                                                                                                             |
| #### [target](/docs/v3/Plugins/Observer/target.md) : Element                  | The target Element                                                                                                                                                                                                                                                                                                                                                          |
| #### [vars](/docs/v3/Plugins/Observer/vars.md) : Object                       | The configuration object that was originally passed in to the Observer.create().                                                                                                                                                                                                                                                                                            |
| #### [velocityX](/docs/v3/Plugins/Observer/velocityX.md) : Number             | The horizontal velocity (in pixels per second).                                                                                                                                                                                                                                                                                                                             |
| #### [velocityY](/docs/v3/Plugins/Observer/velocityY.md) : Number             | The vertical velocity (in pixels per second).                                                                                                                                                                                                                                                                                                                               |
| #### [x](/docs/v3/Plugins/Observer/x.md) : Number                             | the `clientX` from the most recent touch/pointer event, which refers to the horizontal distance from the left edge of the viewport. This only gets updated if you set the `type` to include "touch" and/or "pointer".                                                                                                                                                       |
| #### [y](/docs/v3/Plugins/Observer/y.md) : Number                             | the `clientY` from the most recent touch/pointer event, which refers to the vertical distance from the top edge of the viewport. This only gets updated if you set the `type` to include "touch" and/or "pointer".                                                                                                                                                          |

|                                                                                                  |                                                                                                                                                                                                                                                                                                                    |
| ------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| #### [disable](/docs/v3/Plugins/Observer/disable\(\).md)( ) : void                               | Disables the Observer, removing the necessary event listeners and firing the `onDisable` callback if the Observer wasn't already disabled.                                                                                                                                                                         |
| #### [enable](/docs/v3/Plugins/Observer/enable\(\).md)( event:Event ) : Self                     | Enables the Observer, adding the necessary event listeners and firing the `onEnable` callback if the Observer wasn't already enabled.                                                                                                                                                                              |
| #### [kill](/docs/v3/Plugins/Observer/kill\(\).md)( ) : void                                     | Kills the Observer instance, calling `disable()` and removing it from the internal Array so that it can no longer be found via .getAll() or .getById(), making it available for garbage collection. This is permanent. If you plan on enabling the instance again later, just use `disable()` instead of `kill()`. |
| #### [Observer.create](/docs/v3/Plugins/Observer/static.create\(\).md)( vars:Object ) : Observer | Creates a new Observer instance according to the configuration details provided.                                                                                                                                                                                                                                   |
| #### [Observer.getAll](/docs/v3/Plugins/Observer/static.getAll\(\).md)( ) : Array                | Gets an Array of all Observers that have been created (and not killed). This can be useful if, for example, your framework requires that you kill everything like on a routing change.                                                                                                                             |
| #### [Observer.getById](/docs/v3/Plugins/Observer/static.getById\(\).md)( id:String ) : Observer | The Observer instance with the matching `id` that was defined in the configuration `vars` object (or undefined if no matching ScrollTriggers are found)                                                                                                                                                            |

Absolutely! That could be useful if, for example, you want certain callbacks debounced but others not. And remember that you can .disable() and .enable() an Observer anytime.

No, Observer is already included inside the ScrollTrigger file; you can access it via [ScrollTrigger.observe()](/docs/v3/Plugins/ScrollTrigger/static.observe\(\).md) and skip loading the Observer file separately.

Check out the full collection of [How-to demos](https://codepen.io/collection/xKoPmy) and our favourite [inspiring community demos](https://codepen.io/collection/KpNYOd) on CodePen.

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(Observer)
```

Example 2 (unknown):
```unknown
Observer.create({
  target: window, // can be any element (selector text is fine)
  type: "wheel,touch", // comma-delimited list of what to listen for
  onUp: () => previous(),
  onDown: () => next(),
});
```

Example 3 (unknown):
```unknown
Observer.create({
  target: window, // can be any element (selector text is fine)
  type: "wheel,touch", // comma-delimited list of what to listen for ("wheel,touch,scroll,pointer")
  onUp: () => previous(),
  onDown: () => next(),
});
```

Example 4 (unknown):
```unknown
Observer.create({
  ...
  onChange: (self) =>  {
    console.log("velocity:", self.velocityX, self.velocityY, "delta:", self.deltaX, self.deltaY, "target element:", self.target, "last event:", self.event);
  }
});
```

---

## isPressed

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/isPressed.md

**Contents:**
  - isPressed : Boolean
  - Details[‚Äö√Ñ√£](#details "Direct link to Details")

If the Draggable is being pressed, this will be `true`

If the Draggable is being pressed, this will be `true`

---

## gsap.ticker

**URL:** https://gsap.com/docs/v3/GSAP/gsap.ticker.md

**Contents:**
  - Type : Object[‚Äã](#type--object "Direct link to Type : Object")
  - Basic example[‚Äã](#basic-example "Direct link to Basic example")
  - Callback parameters[‚Äã](#callback-parameters "Direct link to Callback parameters")
- Advanced options for .add()[‚Äã](#advanced-options-for-add "Direct link to Advanced options for .add()")
  - Throttling when tab is hidden[‚Äã](#throttling-when-tab-is-hidden "Direct link to Throttling when tab is hidden")
- Ticker properties[‚Äã](#ticker-properties "Direct link to Ticker properties")
- gsap.ticker.fps()[‚Äã](#gsaptickerfps "Direct link to gsap.ticker.fps()")
- gsap.ticker.deltaRatio()[‚Äã](#deltaRatio "Direct link to gsap.ticker.deltaRatio()")
- gsap.ticker.lagSmoothing()[‚Äã](#gsaptickerlagsmoothing "Direct link to gsap.ticker.lagSmoothing()")
    - What happens when the CPU gets bogged down and there's a lag between renders?[‚Äã](#what-happens-when-the-cpu-gets-bogged-down-and-theres-a-lag-between-renders "Direct link to What happens when the CPU gets bogged down and there's a lag between renders?")

The `gsap.ticker` is like the heartbeat of the GSAP engine - it updates the [globalTimeline](/docs/v3/GSAP/gsap.globalTimeline\(\)) on every `requestAnimationFrame` event, so it is perfectly synchronized with the browser's rendering cycle. You can add your own listener(s) to run custom logic after each update (great for game developers). Add as many listeners as you want.

The following parameters are passed to each listener function:

1. **time** : *Number* - the total time (in seconds) since the ticker started. The ticker's start time may get pushed forward by lagSmoothing.
2. **deltaTime** : *Number* - the amount of milliseconds that elapsed since the previous tick. Note: you can use [gsap.ticker.deltaRatio()](#deltaRatio) to get a ratio instead that's based on a certain target FPS.
3. **frame** : *Number* - the frame (tick) number which gets incremented on each tick.

So your listener function could be setup to make use of those the parameters that are passed to it like so:

There are two optional parameters you can use in `gsap.ticker.add()`:

* **once** : *Boolean* - the callback will only fire once and then get removed automatically
* **prioritize** : *Boolean* - the callback will be added to the top of the queue instead of the bottom, meaning it'll fire *before* any of the listeners currently in the queue. This is perfect for if you want your callback to fire before GSAP's global timeline.

*These advanced options were added in GSAP 3.10.0*

When the user switches to a different tab in the browser, the ticker's updates get throttled down significantly in order to conserve battery power and reduce load on the CPU (this happens because the browser itself throttles down `requestAnimationFrame` event dispatching). Typically `requestAnimationFrame` events occur around 60 times per second, but that's up to the browser and depends on system performance as well. Some modern devices update at 120hz (120 times per second). If `requestAnimationFrame` isn't supported, the ticker automatically falls back to using a regular `setTimeout()` loop.

* **time** : *Number* - the total time (in seconds) since the ticker started. The ticker's start time may get pushed forward by lagSmoothing.
* **frame** : *Number* - the frame (tick) number which gets incremented on each tick.

To limit the ticker to a particular frame rate, you can use the `fps()` method like this:

Since it isn't possible to have the browser speed up the native `requestAnimationFrame` events (typically 60fps), you can't do something like `gsap.ticker.fps(100)` (well, you can but it'll still run at around 60fps). You could, however, do `gsap.ticker.fps(30)` to have the ticker skip beats when necessary in order to get you as close as possible to 30fps (or whatever fps you set *below* the native frequency).

The `gsap.ticker.deltaRatio()` method returns the elapsed time since the last tick as a ratio based on a certain target FPS. For example, if you do `gsap.ticker.deltaRatio(60)` but the elapsed time since the last tick was actually more like it was running at 30fps (maybe things got bogged down), it would return `2` so that you can easily set up loops that dynamically adjust to frame rate variations, like:

The default `fps` parameter is 60, so you don't even need to pass one in unless you're using something other than 60fps. For example, if you'd like to get the ratio based on things running at 30fps, you'd do `gsap.ticker.deltaRatio(30)`

[Here's a demo](https://codepen.io/osublake/pen/00dd54ccbbb469ff42770640f744be06?editors=0010) from Blake Bowen.

The `gsap.ticker.lagSmoothing()` method acts as a getter and setter for GSAP's lag smoothing.

For example, imagine a 2-second tween that should start right away, but the CPU is busy for a full second before it can render that tween for the first time. Most other animation engines (including CSS animations in some browsers) slide the start time forward to compensate but there's a **major** drawback to that approach: it sacrifices synchronization and can mangle delays so that when you try to neatly stagger animations, they [spew out in clumps/groups](https://codepen.io/GreenSock/full/e3ac33404937de0eb77c789323367da8/). That's no good.

GSAP has always used a strict timing model that prioritizes perfect synchronization, meaning in the example above, the tween would render as if it's halfway done after the initial 1-second lag. Basically, every animation engine has to pay the lag tax one way or the other - either maintain strict timing and synchronization, or slide the starting times around and lose sync.

`gsap.ticker.lagSmoothing()` gives you the best of both worlds because when the CPU gets bogged down, it adjusts the core timing mechanism on the next tick which affects **all** animations, thus everything remains **perfectly synchronized**. You can set the threshold (in millisecond) so that whenever there's a lag **greater than** that threshold, the engine will adjust the internal clock to act like the `adjustedLag` elapsed instead. Even though you call the static method on `gsap`, this one adjustment affects everything in GSAP (tweens, `timeline`s, and `delayedCall`s because they're all driven by a single timing mechanism at the heart of `gsap`).

For example, if the `threshold` is `500` and the `adjustedLag` is `33` (those are the defaults), the only time an adjustment will occur is when more than 500ms elapses between two ticks in which case it will act as though only 33ms elapsed. So if the CPU bogs down for 2 full seconds (yikes!), your animations will move 33ms worth of time on the next render instead of jumping a full 2-seconds. **\*Note:** this has no affect on the device's performance or true frame rate - this merely affects how GSAP reacts when the browser drops frames.\*

This feature is **already activated by default**, using a `threshold` of 500ms and a `adjustedLag` of 33ms, but if you want to change the settings you can do so like this:

Because doing so wouldn't allow much breathing room, and it would naturally make your tweens look like they're running more slowly (because technically they are if the time is getting nudged forward on almost every render). Also note that if you've got any delayedCalls, those will be affected as well. That's a good thing - it ensures that you can rely on those to be perfectly synchronized with the rest of the engine, but if the browser is under heavy pressure and is only rendering a few frames per second, it'd seem as if time is literally slowing down and a 2-second tween (or delayedCall) might actually take 8 seconds to complete.

In most real-world scenarios, the defaults of 500 and 33 are ideal because they protect against significant hiccups in the browser/CPU while allowing minor variations in the frame rate without slowing things down unnecessarily.

If you'd like to disable lag smoothing, you can simply set it to 0 like `gsap.ticker.lagSmoothing(0)` which is the same as setting the threshold to a super large value so that it never kicks in.

**Examples:**

Example 1 (unknown):
```unknown
//add listener
gsap.ticker.add(myFunction);

function myFunction() {
  //executes on every tick after the core engine updates
}

//to remove the listener later...
gsap.ticker.remove(myFunction);
```

Example 2 (unknown):
```unknown
function myFunction(time, deltaTime, frame) {
  //makes use of time, deltaTime, and frame
}
```

Example 3 (unknown):
```unknown
// call myCallback once on the next requestAnimationFrame BEFORE the global timeline updates.
gsap.ticker.add(myCallback, true, true);
```

Example 4 (unknown):
```unknown
// throttle the frames-per-second to 30
gsap.ticker.fps(30);
```

---

## velocityY

**URL:** https://gsap.com/docs/v3/Plugins/Observer/velocityY.md

**Contents:**
  - velocityY : Number
  - Details[‚Äã](#details "Direct link to Details")

The vertical velocity (in pixels per second).

The vertical velocity (in pixels per second).

This is only affected by the event types that the Observer is watching. So, for example, `type: "wheel,touch"` would track the velocity based on wheel and touch events (not pointer or scroll). By default, touch and pointer events are only tracked **while pressing/dragging** but if you define an `onMove` (which is mapped to "pointermove"/"mousemove" events), it'll be tracked during any movement while hovering over the target.

---

## Format number with commas and limited decimal places

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/formatNumber.md

Take a number like 1000.254145 and format it into a string like "1,000.25".

Then you can use it in an onUpdate:

I wasn't sure if you wanted to replace this file or create a new helper Jack? Thought as it's not urgent I would just partially do this so that you can give updating the docs a go?

**Examples:**

Example 1 (unknown):
```unknown
// adds commas and forces 2 decimal places.
function formatNumber(value, decimals) {
  let s = (+value).toLocaleString("en-US").split(".");
  return decimals
    ? s[0] + "." + ((s[1] || "") + "00000000").substr(0, decimals)
    : s[0];
}
```

Example 2 (unknown):
```unknown
let obj = { num: 100 };
gsap.to(obj, {
  num: 10500,
  onUpdate: () => (myElement.innerText = "$" + formatNumber(obj.num, 2)),
});
```

Example 3 (unknown):
```unknown
function getFormatter(increment, pad) {
  let snap = gsap.utils.snap(increment),
      exp = /\B(?=(\d{3})+(?!\d))/g,
      snapWithCommas = value => (snap(+value) + "").replace(exp, ","),
      whole = increment % 1 === 0,
      decimals = whole ? 0 : ((increment + "").split(".")[1] || "0").length;
  return !pad || whole ? snapWithCommas : value => {
    let s = snapWithCommas(value),
        i = s.indexOf(".");
    ~i || (i = s.length);
    return s.substr(0, i) + "." + (s.substr(i + 1, s.length - i - 1) + "00000000").substr(0, decimals);
  };
}
```

Example 4 (unknown):
```unknown
let formatter = getFormatter(0.01, true); // increment by 0.01, always pad so that there are 2 decimal places

console.log(formatter(5000.1)); // 5,000.10
```

---

## Blend two eases

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/blendEases.md

**Contents:**
    - loading...

If you need one ease at the start of your animation, and a different one at the end, you can use this function to blend them!

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/59008f3ee5f26b811e90017bdcbb7dfb?default-tab=result\&theme-id=41164)

If you need to **invert** an ease instead, see [this demo](https://codepen.io/GreenSock/pen/rgROxY?editors=0010) for a different helper function.

**Examples:**

Example 1 (unknown):
```unknown
//just feed in the starting ease and the ending ease (and optionally an ease to do &#xFEFF;the blending), and it'll return a new Ease that's...blended!
function blendEases(startEase, endEase, blender) {
  var parse = function (ease) {
      return typeof ease === "function" ? ease : gsap.parseEase("power4.inOut");
    },
    s = gsap.parseEase(startEase),
    e = gsap.parseEase(endEase),
    blender = parse(blender);
  return function (v) {
    var b = blender(v);
    return s(v) * (1 - b) + e(v) * b;
  };
}
//example usage:
gsap.to("#target", {
  duration: 2,
  x: 100,
  ease: blendEases("back.in(1.2)", "bounce"),
});
```

---

## MorphSVGPlugin.convertToPath

**URL:** https://gsap.com/docs/v3/Plugins/MorphSVGPlugin/static.convertToPath.md

**Contents:**
  - MorphSVGPlugin.convertToPath( shape:\[Element | String], swap:Boolean ) : Array
    - Parameters
  - Returns : Array[‚Äã](#returns--array "Direct link to Returns : Array")
  - Details[‚Äã](#details "Direct link to Details")
    - loading...
- Notes[‚Äã](#notes "Direct link to Notes")

Converts SVG shapes like `<circle>`, `<rect>`, `<ellipse>`, or `<line>` into `<path>`

* #### **shape**: \[Element | String]

An element or a selector string.

* #### **swap**: Boolean

By default, the resulting \<path> will be swapped directly into the DOM in place of the provided shape element, but you can define `false` for `swap` to prevent that.

Returns an Array of all `<path>` elements that were created.

Technically it's only feasible to morph `<path>` elements or `<polyline>`/`<polygon>` elements, but there are plenty of times you will want to morph a `<circle>`, `<rect>`, `<ellipse>`, or `<line>`. This method makes that possible by converting those basic shapes into `<path>` elements. It can be used like so:

You can pass in an element or selector text, so you could also have it convert ALL of those elements with one line:

This literally swaps in a `<path>` for each one directly in the DOM, and it should look absolutely identical. It'll keep the attributes like "id", etc. intact so that the conversion, you should be able to target the elements just as you would before.

Why not automatically do the conversion? Because that's a bit too intrusive and could cause problems. For example, if you had event listeners applied to the original element(s) or references in your own code to those elements. We feel it's best to make sure the developer is aware of and specifically requests this conversion rather than doing it automatically.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/gagNeR?default-tab=result\&theme-id=41164)

* If you define an `rx` or `ry` attribute on a `<rect>` element, make sure you define **both** (MorphSVGPlugin will default to a value of 0 whereas some browsers default to copying the one that was defined).

**Examples:**

Example 1 (unknown):
```unknown
MorphSVGPlugin.convertToPath("#elementID");
```

Example 2 (unknown):
```unknown
MorphSVGPlugin.convertToPath("circle, rect, ellipse, line, polygon, polyline");
```

Example 3 (unknown):
```unknown
//An svg <rect> Like this:
<rect id="endShape" width="100" height="100" fill="red"/>
//becomes
<path id="endShape" fill="red" d="M100,0 v100 h-100 v-100 h100z"></path>
```

---

## Inertia

**URL:** https://gsap.com/docs/v3/Plugins/InertiaPlugin.md

**Contents:**
    - CDN Link
    - Minimal usage
- Description[‚Äã](#description "Direct link to Description")
- Config Object[‚Äã](#config-object "Direct link to Config Object")
- Automatically determine duration[‚Äã](#automatically-determine-duration "Direct link to Automatically determine duration")
- Automatically track velocity[‚Äã](#automatically-track-velocity "Direct link to Automatically track velocity")
- Examples[‚Äã](#examples "Direct link to Examples")
    - loading...
    - loading...
    - loading...

InertiaPlugin (formerly ThrowPropsPlugin) allows you to smoothly glide any property to a stop, honoring an initial velocity as well as applying optional restrictions on the end value. You can define a specific end value or allow it to be chosen automatically based on the initial velocity (and ease) or you can define a max/min range or even an array of snap-to values that act as notches. You can have it "watch" certain properties to keep track of their velocities and then use them automatically when you do an `inertia` tween. This is perfect for flick-scrolling or animating things as though they are being thrown (where momentum factors into the animation).

For example, let's say a user drags a ball and and then when released, the ball should continue flying at the same velocity as it was just moving (so that it appears seamless), and then glide to a rest. You can't do a normal tween because you don't know exactly where it should land or how long the tween should last (faster initial velocity would usually mean a longer duration). You'd like it to decelerate based on whatever ease you define in your tween.

Maybe you want the final resting value to always land within a particular range so that the ball doesn't fly off the edge of the screen. But you don't want it to suddenly jerk to a stop when it hits the edge of the screen either; instead, you want it to ease gently into place even if that means going past the landing spot briefly and easing back (if the initial velocity is fast enough to require that). The whole point is to make it look **smooth**.

In its simplest form, you can pass just the initial velocity for each property like this:

In the above example, `obj.x` will animate at 500 pixels per second initially and `obj.y` will animate at -300 pixels per second. Both will decelerate smoothly until they come to rest and InertiaPlugin figures out a natural-looking duration for you!

To impose maximum and minimum boundaries on the end values, use the object syntax with the `max` and `min` special properties like this:

Notice the nesting of the objects (`{}`). The `max` and `min` values refer to the range for the final resting position (coordinates in this case), **not** the velocity. So `obj.x` would always land between 0 and 1024 in this case, and `obj.y` would always land between 0 and 720. If you want the target object to land on a specific value rather than within a range, simply set `max` and `min` to identical values or just use the `end` property. Also notice that you must define a `velocity` value for each property (unless you're using `track()` - see below for details).

\[*Number* | *‚Äúauto‚Äù*] - The initial velocity, measured in units per second. You may omit velocity or just use ‚Äúauto‚Äù for properties that are being tracked automatically using the track() method.

Number - The minimum end value of the property. For example, if you don‚Äôt want `x` to land at a value below 0, your `inertia` may look like `{x: {velocity: -500, min: 0}}`.

Number - The maximum end value of the property. For example, if you don‚Äôt want `x` to exceed 1024, your `inertia` may look like `{x: {velocity: 500, max: 1024}}`.

\[*Number* | *Array* | *Function*] - If `end` is defined as a **Number**, the target will land EXACTLY there (just as if you set both the `max` and `min` to identical values). If `end` is defined as a numeric **Array**, those values will be treated like ‚Äúnotches‚Äù or ‚Äúsnap-to‚Äù values so that the closest one to the natural landing spot will be selected. For example, if `[0,100,200]` is used, and the value would have naturally landed at 141, it will use the closest number (100 in this case) and land there instead. If end is defined as a **Function**, that function will be called and passed the natural landing value as the only parameter, and your function can run whatever logic you want, and then return the number at which it should land. This can be useful if, for example, you have a rotational tween and you want it to snap to 10-degree increments no matter how big or small, you could use a function that just rounds the natural value to the closest 10-degree increment. So any of these are valid: `end: 100`, `end: [0,100,200,300]`, or `end: function(n) { return Math.round(n / 10) * 10; }`.

* #### linkedProps[](#linkedProps)

String - A comma-delimited list of properties that should be linked together into a single object when passed to a function-based `end` value so that they‚Äôre processed together. This is only useful when, for example, you have an `x` and `y` but the logic in your end function needs BOTH of those (like for snapping coordinates). See [this demo](//codepen.io/GreenSock/pen/aqEdGM?editors=0010) for an example. The object that gets passed as the only parameter to the `end` function will have the properties are listed in `linkedProps`. So, for example, if `linkedProps` is `"x,y"`, then an object like `{x: 100, y: 140}` gets passed to the function as a parameter. Those values are the natural ending values, but of course your function should return a similar object with the new values you want the end values to be, like `return {x: 200, y: 300}`.

* #### resistance[](#resistance)

Number - The amount of resistance per second (think of it like how much friction is applied)..

InertiaPlugin isn't just for tweening x and y coordinates. It works with any numeric property, so you could use it for spinning the `rotation` of an object as well. Or the `scaleX`/`scaleY` properties. Maybe the user drags to spin a wheel and lets go and you want it to continue increasing the `rotation` at that velocity, decelerating smoothly until it stops. It even works with method-based getters/setters.

One of the trickiest parts of creating a `inertia` tween that looks fluid and natural (particularly if you're applying maximum and/or minimum values) is determining its duration. Typically it's best to have a relatively consistent level of resistance so that if the initial velocity is very fast, it takes longer for the object to come to rest compared to when the initial velocity is slower. You also may want to impose some restrictions on how long a tween can last (if the user drags incredibly fast, you might not want the tween to last 200 seconds). The duration will also affect how far past a max/min boundary the property may go, so you might want to only allow a certain amount of overshoot tolerance. That's why InertiaPlugin automatically sets the duration of the Tween for you, and you can optionally hard-code a duration in the inertia object or even use max/min values to give it a range, like `duration:{min:0.5, max:3}`.

Another tricky aspect of smoothly transitioning from a particular velocity is tracking the property's velocity in the first place! So we've made that easier too - you can use the [`InertiaPlugin.track()`](/docs/v3/Plugins/InertiaPlugin/.md) method to have the velocity (rate of change) of certain properties tracked and then `inertia` tweens will automatically grab the appropriate tracked value internally, allowing you to omit the `velocity` values in your tweens altogether. See the [`track()`](/docs/v3/Plugins/InertiaPlugin/static.track\(\).md) method's description for details. And make sure you start tracking velocity at least a half-second before you need to tween because it takes a small amount of time to gauge how fast something is going.

A unique convenience of InertiaPlugin compared to most other solutions out there that use frame-based loops is that everything is reversible and you can jump to any spot in the tween immediately. So if you create several `inertia` tweens, for example, and dump them into a timeline, you could simply call `reverse()` on the timeline to watch the objects retrace their steps right back to the beginning!

The following example creates a green box and a red box that you can drag and toss around the screen in a natural, fluid way. If you check the "Snap to grid" checkbox, the boxes will always land exactly on the grid. We use `Draggable` class so that we can focus more on the InertiaPlugin code rather than all the boilerplate code needed to make things draggable:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/JjwZzNG?default-tab=result\&theme-id=41164)

The following example demonstrates using a custom `end` function for complex snapping that requires both x and y values, thus `linkedProps` is used:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/qBBWPPe?default-tab=result\&theme-id=41164)

Although InertiaPlugin is commonly used with Draggable, Draggable is not required an InertiaPlugin can be used independently from Draggable.. Here's an example of Inertia's tracking being used directly:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/myyJrLE?default-tab=result\&theme-id=41164)

|                                                                                                                                                 |                                                                                                                                                                                                                        |
| ----------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| #### [InertiaPlugin.getVelocity](/docs/v3/Plugins/InertiaPlugin/static.getVelocity\(\).md)( target:Element \| String, property:String ) ;       | Returns the current velocity of the given property and target object (only works if you started tracking the property using the [`InertiaPlugin.track()`](/docs/v3/Plugins/InertiaPlugin/static.track\(\).md) method). |
| #### [InertiaPlugin.isTracking](/docs/v3/Plugins/InertiaPlugin/static.isTracking\(\).md)( target:Element \| String, property:String ) : Boolean |                                                                                                                                                                                                                        |
| #### [InertiaPlugin.track](/docs/v3/Plugins/InertiaPlugin/static.track\(\).md)( target:Element \| String \| Array, props:String ) : Array       |                                                                                                                                                                                                                        |
| #### [InertiaPlugin.untrack](/docs/v3/Plugins/InertiaPlugin/static.untrack\(\).md)( target:Element \| String \| Array, props:String ) ;         |                                                                                                                                                                                                                        |

Inertia pairs great with Draggable - check out the Draggable [how-to collection](https://codepen.io/collection/AtuHb) and our favourite [inspiring community demos](https://codepen.io/collection/DrQGpM) on CodePen.

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(InertiaPlugin)
```

Example 2 (unknown):
```unknown
gsap.to(obj, { inertia: { x: 500, y: -300 } });
```

Example 3 (unknown):
```unknown
gsap.to(obj, { inertia: { x: 500, y: -300 } });
```

Example 4 (unknown):
```unknown
gsap.to(obj, {
  inertia: {
    x: {
      velocity: 500,
      max: 1024,
      min: 0,
    },
    y: {
      velocity: -300,
      max: 720,
      min: 0,
    },
  },
});
```

---

## scrollTrigger

**URL:** https://gsap.com/docs/v3/GSAP/Timeline/scrollTrigger.md

**Contents:**
  - scrollTrigger: [ScrollTrigger](/docs/v3/Plugins/ScrollTrigger/.md) | undefined
  - Details[‚Äã](#details "Direct link to Details")

A handy way to access the ScrollTrigger associated with a timeline. This is only accessible if the timeline has a ScrollTrigger.

A `scrollTrigger`property is only added to the Timeline or Tween *if* it has a ScrollTrigger.

See the [ScrollTrigger](/docs/v3/Plugins/ScrollTrigger/.md) docs for more details

**Examples:**

Example 1 (unknown):
```unknown
// add a ScrollTrigger to a Timeline
let tl = gsap.timeline({scrollTrigger: {start: "top center"...}});

// access the ScrollTrigger to call various methods
tl.scrollTrigger.refresh();
// or
tl.scrollTrigger.kill();
```

---

## MorphSVGPlugin.stringToRawPath

**URL:** https://gsap.com/docs/v3/Plugins/MorphSVGPlugin/static.stringToRawPath.md

**Contents:**
  - MorphSVGPlugin.stringToRawPath( data:String ) : RawPath
    - Parameters
  - Returns : RawPath[‚Äã](#returns--rawpath "Direct link to Returns : RawPath")
  - Details[‚Äã](#details "Direct link to Details")

Takes a string of path data (like `"M0,0 C100,20 300,50 400,0..."`, what's typically found in the `d` attribute of a `<path>`), parses it, converts it into cubic beziers, and returns it as a RawPath which is just an array containing an array for each segment (each `M` command starts a new segment).

* #### **data**: String

A path data string which is what is typically found in the `d` attribute of a `<path>` element. Like `"M0,0 C10,20,15,30,5,18 M0,100 C50,120,80,110,100,100"`.

The RawPath of a given string, like

Converts a string of path data, like `"M0,0 C100,20 300,50 400,0..."` (which is what's typically found in the `d` attribute of a `<path>`) into a **RawPath**.

A **RawPath** is essentially an array containing an array for each contiguous segment with alternating x, y, x, y cubic bezier data. It's like an SVG `<path>` where there's one segment (array) for each `M` command. That segment (array) contains all of the cubic bezier coordinates in alternating x/y format (just like SVG path data) in raw numeric form which is nice because that way you don't have to parse a long string and convert things.

For example, this SVG `<path>` has two separate segments because there are two "M" commands:

The resulting RawPath would be:

For simplicity, the example above only has one cubic bezier in each segment, but there could be an unlimited quantity inside each segment. No matter what path commands are in the original`<path>` data string (cubic, quadratic, arc, lines, whatever), the resulting RawPath will **ALWAYS** be cubic beziers.

There is also a corresponding [`MorphSVGPlugin.rawPathToString()`](/docs/v3/Plugins/MorphSVGPlugin/static.rawPathToString.md) method so that you can convert back and forth.

**Examples:**

Example 1 (unknown):
```unknown
[
  [0, 0, 10, 20, 15, 30, 5, 18],
  [0, 100, 50, 120, 80, 110, 100, 100],
];
```

Example 2 (unknown):
```unknown
<path d="M0,0 C10,20,15,30,5,18 M0,100 C50,120,80,110,100,100" />
```

Example 3 (unknown):
```unknown
[
  [0, 0, 10, 20, 15, 30, 5, 18],
  [0, 100, 50, 120, 80, 110, 100, 100],
];
```

---

## Seamlessly loop elements along the x-axis

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/seamlessLoop.md

**Contents:**
- Usage[‚Äã](#usage "Direct link to Usage")
- Simple Demo[‚Äã](#simple-demo "Direct link to Simple Demo")
    - loading...
- Demo with Draggable[‚Äã](#demo-with-draggable "Direct link to Demo with Draggable")
    - (with "center: true" and onChange features)[‚Äã](#with-center-true-and-onchange-features "Direct link to (with \"center: true\" and onChange features)")
    - loading...
- Vertical Loop with Draggable[‚Äã](#vertical-loop-with-draggable "Direct link to Vertical Loop with Draggable")
    - loading...

Like a slider or news ticker, where elements go off one side and then eventually come back around from the other side. This helper function does all the hard work for you, returning a timeline with some special methods/properties added that allow you to go to the next/previous element, or jump to a particular one (based on its index in the Array). It's even responsive because it uses xPercent for the animations, so if your elements change width based on screen size, it doesn't break everything.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/ZELPxWW?default-tab=result\&theme-id=41164)

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/gOvvJee?default-tab=result\&theme-id=41164)

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/MWXPgKm?default-tab=result\&theme-id=41164)

**Examples:**

Example 1 (unknown):
```unknown
/*
This helper function makes a group of elements animate along the x-axis in a seamless, responsive loop.

Features:
- Uses xPercent so that even if the widths change (like if the window gets resized), it should still work in most cases.
- When each item animates to the left or right enough, it will loop back to the other side
- Optionally pass in a config object with values like "speed" (default: 1, which travels at roughly 100 pixels per second), paused (boolean),  repeat, reversed, and paddingRight.
- The returned timeline will have the following methods added to it:
- next() - animates to the next element using a timeline.tweenTo() which it returns. You can pass in a vars object to control duration, easing, etc.
- previous() - animates to the previous element using a timeline.tweenTo() which it returns. You can pass in a vars object to control duration, easing, etc.
- toIndex() - pass in a zero-based index value of the element that it should animate to, and optionally pass in a vars object to control duration, easing, etc. Always goes in the shortest direction
- current() - returns the current index (if an animation is in-progress, it reflects the final index)
- times - an Array of the times on the timeline where each element hits the "starting" spot. There's also a label added accordingly, so "label1" is when the 2nd element reaches the start.
*/
function horizontalLoop(items, config) {
  items = gsap.utils.toArray(items);
  config = config || {};
  let tl = gsap.timeline({
      repeat: config.repeat,
      paused: config.paused,
      defaults: { ease: "none" },
      onReverseComplete: () => tl.totalTime(tl.rawTime() + tl.duration() * 100),
    }),
    length = items.length,
    startX = items[0].offsetLeft,
    times = [],
    widths = [],
    xPercents = [],
    curIndex = 0,
    pixelsPerSecond = (config.speed || 1) * 100,
    snap = config.snap === false ? (v) => v : gsap.utils.snap(config.snap || 1), // some browsers shift by a pixel to accommodate flex layouts, so for example if width is 20% the first element's width might be 242px, and the next 243px, alternating back and forth. So we snap to 5 percentage points to make things look more natural
    totalWidth,
    curX,
    distanceToStart,
    distanceToLoop,
    item,
    i;
  gsap.set(items, {
    // convert "x" to "xPercent" to make things responsive, and populate the widths/xPercents Arrays to make lookups faster.
    xPercent: (i, el) => {
      let w = (widths[i] = parseFloat(gsap.getProperty(el, "width", "px")));
      xPercents[i] = snap(
        (parseFloat(gsap.getProperty(el, "x", "px")) / w) * 100 +
          gsap.getProperty(el, "xPercent")
      );
      return xPercents[i];
    },
  });
  gsap.set(items, { x: 0 });
  totalWidth =
    items[length - 1].offsetLeft +
    (xPercents[length - 1] / 100) * widths[length - 1] -
    startX +
    items[length - 1].offsetWidth *
      gsap.getProperty(items[length - 1], "scaleX") +
    (parseFloat(config.paddingRight) || 0);
  for (i = 0; i < length; i++) {
    item = items[i];
    curX = (xPercents[i] / 100) * widths[i];
    distanceToStart = item.offsetLeft + curX - startX;
    distanceToLoop =
      distanceToStart + widths[i] * gsap.getProperty(item, "scaleX");
    tl.to(
      item,
      {
        xPercent: snap(((curX - distanceToLoop) / widths[i]) * 100),
        duration: distanceToLoop / pixelsPerSecond,
      },
      0
    )
      .fromTo(
        item,
        {
          xPercent: snap(
            ((curX - distanceToLoop + totalWidth) / widths[i]) * 100
          ),
        },
        {
          xPercent: xPercents[i],
          duration:
            (curX - distanceToLoop + totalWidth - curX) / pixelsPerSecond,
          immediateRender: false,
        },
        distanceToLoop / pixelsPerSecond
      )
      .add("label" + i, distanceToStart / pixelsPerSecond);
    times[i] = distanceToStart / pixelsPerSecond;
  }
  function toIndex(index, vars) {
    vars = vars || {};
    Math.abs(index - curIndex) > length / 2 &&
      (index += index > curIndex ? -length : length); // always go in the shortest direction
    let newIndex = gsap.utils.wrap(0, length, index),
      time = times[newIndex];
    if (time > tl.time() !== index > curIndex) {
      // if we're wrapping the timeline's playhead, make the proper adjustments
      vars.modifiers = { time: gsap.utils.wrap(0, tl.duration()) };
      time += tl.duration() * (index > curIndex ? 1 : -1);
    }
    curIndex = newIndex;
    vars.overwrite = true;
    return tl.tweenTo(time, vars);
  }
  tl.next = (vars) => toIndex(curIndex + 1, vars);
  tl.previous = (vars) => toIndex(curIndex - 1, vars);
  tl.current = () => curIndex;
  tl.toIndex = (index, vars) => toIndex(index, vars);
  tl.times = times;
  tl.progress(1, true).progress(0, true); // pre-render for performance
  if (config.reversed) {
    tl.vars.onReverseComplete();
    tl.reverse();
  }
  return tl;
}
```

Example 2 (unknown):
```unknown
const boxes = gsap.utils.toArray(".box"),
  loop = horizontalLoop(boxes, { paused: true });

// add click listeners so you can click a box to have it move to the first slot
boxes.forEach((box, i) =>
  box.addEventListener("click", () =>
    loop.toIndex(i, { duration: 1, ease: "power1.inOut" })
  )
);

// make the "next" and "previous" buttons call the appropriate methods on the timeline
document
  .querySelector(".next")
  .addEventListener("click", () =>
    loop.next({ duration: 1, ease: "power1.inOut" })
  );
document
  .querySelector(".prev")
  .addEventListener("click", () =>
    loop.previous({ duration: 1, ease: "power1.inOut" })
  );
```

---

## Utility Methods

**URL:** https://gsap.com/docs/v3/GSAP/UtilityMethods.md

**Contents:**
- Video[‚Äã](#video "Direct link to Video")
- Available Utils[‚Äã](#available-utils "Direct link to Available Utils")

GSAP's utility methods can be surprisingly helpful. Note that many of them can optionally return FUNCTIONS so that they can be plugged directly into tweens, leveraging GSAP's function-based capabilities. In that case, they'll get called once for each target rather than just using the same end value for them all.

combining utility methods

[YouTube video player](https://www.youtube.com/embed/NqiF5xIuMd0)

|                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| ---------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| #### [checkPrefix](/docs/v3/GSAP/UtilityMethods/checkPrefix\(\).md)    | Prefixes the proved CSS property if necessary                                                                                                                                                                                                                                                                                                                                                                                   |
| #### [clamp](/docs/v3/GSAP/UtilityMethods/clamp\(\).md)                | Clamp a value to fit within a specific range `clamp(0, 100, -12)` -> 0                                                                                                                                                                                                                                                                                                                                                          |
| #### [distribute](/docs/v3/GSAP/UtilityMethods/distribute\(\).md)      | Distribute a value among an array of objects either linearly or according to their position in a grid, optionally with easing applied.                                                                                                                                                                                                                                                                                          |
| #### [getUnit](/docs/v3/GSAP/UtilityMethods/getUnit\(\).md)            | Get the unit of a string `getUnit("30px")` --> "px".                                                                                                                                                                                                                                                                                                                                                                            |
| #### [interpolate](/docs/v3/GSAP/UtilityMethods/interpolate\(\).md)    | Interpolate between almost any two values (numbers, colors, strings, arrays, complex strings, or even objects with multiple properties) ex `interpolate("red", "blue", 0.5)` --> "rgba(128,0,128,1)").                                                                                                                                                                                                                          |
| #### [mapRange](/docs/v3/GSAP/UtilityMethods/mapRange\(\).md) : Number | Map one range to another ex `mapRange(-10, 10, 0, 100, 5) --> 75)`                                                                                                                                                                                                                                                                                                                                                              |
| #### [normalize](/docs/v3/GSAP/UtilityMethods/normalize\(\).md)        | Map a number within a range to a progress between 0 to 1 ex `normalize(100, 200, 150) --> 0.5)`                                                                                                                                                                                                                                                                                                                                 |
| #### [pipe](/docs/v3/GSAP/UtilityMethods/pipe\(\).md)                  | Sequence a number of function calls, passing the result of each into the next ex `pipe(clamp(0, 100), snap(5))(8) --> 10`                                                                                                                                                                                                                                                                                                       |
| #### [random](/docs/v3/GSAP/UtilityMethods/random\(\).md)              | Generate a random number based on parameters ex `random(0, 100, 5) --> 65)` or randomly pick an element from in a supplied array ex. `random(["red", "green", "blue"]) --> "red"`                                                                                                                                                                                                                                               |
| #### [selector](/docs/v3/GSAP/UtilityMethods/selector\(\).md)          | Returns a **selector** function that is scoped to a particular Element (or React ref or Angular ElementRef). ex `selector(myElement)`                                                                                                                                                                                                                                                                                           |
| #### [shuffle](/docs/v3/GSAP/UtilityMethods/shuffle\(\).md)            | Shuffles the contents of an array in-place. ex `shuffle([1, 2, 3, 4, 5]) --> [4, 2, 1, 5, 3])`                                                                                                                                                                                                                                                                                                                                  |
| #### [snap](/docs/v3/GSAP/UtilityMethods/snap\(\).md)                  | Snap a value to either an increment ex `snap(5, 13)` --> `15` or to the closest value in an array ex `snap([0, 5, 10], 7)` --> `5`.                                                                                                                                                                                                                                                                                             |
| #### [splitColor](/docs/v3/GSAP/UtilityMethods/splitColor\(\).md)      | Split any color into its red, green, blue (and optionally alpha) components. Or hue, saturation, and brightness. ex `splitColor("red")` --> `[255, 0, 0])`                                                                                                                                                                                                                                                                      |
| #### [toArray](/docs/v3/GSAP/UtilityMethods/toArray\(\).md)            | Convert almost any array-like object to an array, including selector text! ex - `toArray(".class")` --> `[element1, element2]`.                                                                                                                                                                                                                                                                                                 |
| #### [unitize](/docs/v3/GSAP/UtilityMethods/unitize\(\).md)            | Wraps around another utility function, allowing it to accept values with units like "20px" or "50%", stripping off the unit when feeding into the wrapped utility function, and then adding it back to the result ex. `var wrap = gsap.utils.unitize( gsap.utils.wrap(0, 100) ) wrap("150px");` --> `"50px"`. Or force a specific unit ex `unitize( gsap.utils.mapRange(-10, 10, 0, 100), "%")`; --> always returns with `"%"`. |
| #### [wrap](/docs/v3/GSAP/UtilityMethods/wrap\(\).md)                  | Returns the next item in an array or number in a range after the given index. Or returns a function that returns that object or value if no index is given.                                                                                                                                                                                                                                                                     |
| #### [wrapYoyo](/docs/v3/GSAP/UtilityMethods/wrapYoyo\(\).md)          | Returns the element in an Array associated with the provided index or a number in a provided range, going backwards once the last index is reached (yoyo-ing). Or if no value to wrap is provided, it returns a reusable function that will do the wrapping accordingly when it's fed a value.                                                                                                                                  |

---

## .pin

**URL:** https://gsap.com/docs/v3/Plugins/ScrollTrigger/pin.md

**Contents:**
  - .pin : Element | undefined
  - Details[‚Äã](#details "Direct link to Details")
- Example[‚Äã](#example "Direct link to Example")

\[read-only] The pin element (if one was defined). If selector text was used, like ".pin", the `pin` will be the element itself (not selector text)

\[read-only] The pin element (if one was defined). If selector text was used, like ".pin", the `pin` will be the element itself (not selector text)

**Examples:**

Example 1 (unknown):
```unknown
let st = ScrollTrigger.create({
  trigger: ".trigger",
  pin: ".pin",
  start: "top center",
  end: "+=500",
});

console.log(st.pin); // pin element (not selector text)
```

---

## endX

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/endX.md

**Contents:**
  - endX : Number
  - Details[‚Äã](#details "Direct link to Details")

\[read-only] The ending x (horizontal) position of the Draggable instance which is calculated as soon as the mouse/touch is released after a drag, meaning you can use it to predict precisely where it'll land after an `inertia` flick.

*Number* - The ending `x` (horizontal) position of the Draggable instance. `endX` gets populated immediately when the mouse (or touch) is released after dragging, even before tweening has completed. This makes it easy to predict exactly where the element will land (useful for `inertia: true` Draggables where momentum gets applied). For a Draggable of `type: "x,y"`, `endX` would pertain to the `x` transform translation, as in the CSS `transform: translateX(...)`. For `type: "top,left"`, the Draggable's `x` would refer to the CSS `left` value that's applied. This is not the global coordinate - it is the inline CSS-related value applied to the element.

---

## Weighted Random

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/weightedRandom.md

Have more control over the numbers you pick by providing this function an ease curve of your choice!

For a deeper look at how to use the weightedRandom function, check out this video from the ["GSAP 3: Beyond the Basics" course](https://courses.snorkl.tv/courses/gsap3-beyond-the-basics?ref=44f484) by Snorkl.tv - one of the best ways to learn more about GSAP.

**Examples:**

Example 1 (unknown):
```unknown
// reusable function. Feed in an array and an ease and it'll return
// a function that pulls a random element from that array, weighted
// according to the ease you provide.
function weightedRandom(collection, ease) {
return gsap.utils.pipe(
	Math.random,            //random number between 0 and 1
	gsap.parseEase(ease),   //apply the ease
	gsap.utils.mapRange(0, 1, -0.5, collection.length-0.5), //map to the index range of the array, stretched by 0.5 each direction because we'll round and want to keep distribution (otherwise linear distribution would be center-weighted slightly)
	gsap.utils.snap(1),     //snap to the closest integer
	i => collection[i]      //return that element from the array
);
}

// usage:
var myArray = [0, 1, 2, 3],
getRandom = weightedRandom(myArray, "power4");

// now you can call it anytime and it'll pull a random element from myArray, weighted toward the end.
getRandom();
getRandom();
...
```

---

## maxY

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/maxY.md

**Contents:**
  - maxY : Number
  - Details[‚Äã](#details "Direct link to Details")

When bounds are applied, `maxY` refers to the maximum "legal" vertical property.

*Number* - When bounds are `applied`, `maxY` refers to the maximum "legal" value of the horizontal property (either `"y"` or `"top"`, depending on which type the Draggable is). This makes it easier to run your own custom logic inside the snap or callback function(s) if you so choose. So for a Draggable of `type: "x,y"`, `maxY` would correlate with `y` transform translation, as in the CSS `transform: translateY(...)`. For `type: "top,left"`, the Draggable's `maxY` would correlate with the CSS `top` value that's applied. This is not the global coordinate - it is the inline CSS-related value applied to the element.

---

## CustomEase

**URL:** https://gsap.com/docs/v3/Eases/CustomEase.md

**Contents:**
    - CDN Link
    - Minimal usage
  - Description[‚Äã](#description "Direct link to Description")
- Ease Visualizer
    - [Core](https://gsap.com/core/)
    - Ease pack
    - [Extra Eases](https://gsap.com/pricing/)
- Copy/Paste SVG[‚Äã](#copypaste-svg "Direct link to Copy/Paste SVG")
- Using cubic-bezier values[‚Äã](#using-cubic-bezier-values "Direct link to Using cubic-bezier values")
- The code[‚Äã](#the-code "Direct link to The code")

CustomEase frees you from the limitations of canned easing options; create literally any easing curve imaginable by simply drawing it in the [Ease Visualizer](/docs/v3/Eases.md) or by copying/pasting an SVG path. Zero limitations. Use as many control points as you want.

* Add point: ALT-CLICK on line
* Toggle smooth/corner: ALT-CLICK anchor
* Get handle from corner anchor: ALT-DRAG
* Toggle select: SHIFT-CLICK anchor
* Delete anchor: press DELETE key
* Undo: CTRL-Z

// click to modify the underlined values

ease: "Cubic/power2 (power2).out",none",(

template:none/linear (none).outnone,

(0.7,0.7,\[ ])",(scale from 0.5 to 7 (0.5,7),none)",(12)",(1,0.3)",(1.7)",create("custom", ""0""),create("myWiggle",

squashID: "myBounce-squash"

Creating a Custom Ease

How to use this ease visualizer

* **Add points** - ATL/OPTION-click anywhere on the curve
* **Delete points** - Select the point and then press the DELETE key on the keyboard
* **Toggle smooth/corner** - ALT/OPTION-click on an anchor point. Or, ALT/OPTION-drag a control handle to turn it into a corner (not smooth) point.
* **Select multiple points** - Hold the SHIFT key while clicking anchor points.
* **Undo** - Press CTRL-Z
* **Disable** snapping - Hold SHIFT while dragging

You can edit any of the other eases by selecting them and then hiting "CustomEase".

When in the "custom" mode of the Ease Visualizer, you can select the purple text at the bottom (the CustomEase data string), highlight it all, and then paste in an SVG path (like from Adobe Illustrator) and then click elsewhere and the Ease Visualizer will grab the first `<path>` and convert it into the proper format.

CustomEase also recognizes standard `cubic-bezier()` strings containing four numbers, like those you can get from [cubic-bezier.com](//cubic-bezier.com/). For example, `".17,.67,.83,.67"`. Either paste that into the orange text area in the bottom of the Ease Visualizer or feed it directly into the `CustomEase.create()` method, like `CustomEase.create("easeName", ".17,.67,.83,.67");`.

Instead of using the long data string in each tween, you simply `create()` a CustomEase once (typically as soon as your page/app loads) and assign it a memorable ID (like `"hop"` or `"wiggle"` or whatever you want) that you reference thereafter in any of your tweens, like:

Creating the ease(s) initially ensures maximum performance during animation because there's some overhead involved in calculating all the points internally and optimizing the data for blisteringly fast runtime performance. That only happens once, upon creation.

Typically the path string uses normalized values (0-1), but you can pass in any SVG path data that uses cubic bezier instructions ("M", "C", "S", "L", or "Z" commands) and it'll normalize things internally.

CustomEase has a `getSVGData()` method that calculates the SVG `<path>` data string for visualizing any ease graphically at any size that you define, like `{width: 500, height: 400, x: 10, y: 50}`. You can supply a CustomEase or the ID associated with one, or even a standard ease like `"power2"`. Feed in a `path` in the vars object and it'll populate its `d` attribute for you, like:

It's usually not a good idea to name your ease (the string name you associate with it) the same as one of the standard eases, like "expo" or "power1", etc. because that would essentially overwrite that standard ease and replace it with your CustomEase.

* [CustomEase demos](https://codepen.io/collection/AQKMdx)

[YouTube video player](https://www.youtube.com/embed/A9ROywSFFiY)

Using CustomEase in a project

[YouTube video player](https://www.youtube.com/embed/rJRrUHds7fc)

See the [installation page](/docs/v3/Installation) for all the options (CDN, NPM, download, etc.) where there's even an interactive helper that provides the necessary code. Easy peasy. Don't forget to [register undefined](/docs/v3/GSAP/gsap.registerPlugin\(\).md) like this in your project:

No, you must load/import it separately

Your build tool is probably dropping the plugin when [tree shaking](https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking) and you forgot to [register undefined](/docs/v3/GSAP/gsap.registerPlugin\(\).md) (which protects it from tree shaking). Just register the plugin like this:

No, it's perfectly fine. It doesn't help anything, nor does it hurt.

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(CustomEase)
```

Example 2 (unknown):
```unknown
CustomEase.create(
  "hop",
  "M0,0 C0,0 0.056,0.442 0.175,0.442 0.294,0.442 0.332,0 0.332,0 0.332,0 0.414,1 0.671,1 0.991,1 1,0 1,0"
);

//now you can reference the ease by ID (as a string):
gsap.to(element, { duration: 1, y: -100, ease: "hop" });
```

Example 3 (unknown):
```unknown
//define your CustomEase and give it an ID ("hop" in this case)

CustomEase.create(
  "hop",
  "M0,0 C0,0 0.056,0.442 0.175,0.442 0.294,0.442 0.332,0 0.332,0 0.332,0 0.414,1 0.671,1 0.991,1 1,0 1,0"
);

//now you can reference the ease by ID (as a string):
gsap.to(element, { duration: 1, y: -100, ease: "hop" });
```

Example 4 (unknown):
```unknown
//create a CustomEase with an ID of "hop"
CustomEase.create(
  "hop",
  "M0,0 C0,0 0.056,0.445 0.175,0.445 0.294,0.445 0.332,0 0.332,0 0.332,0 0.414,1 0.671,1 0.991,1 1,0 1,0"
);

//draw the ease visually in the SVG  that has an ID of "ease" at 500px by 400px:
CustomEase.getSVGData("hop", { width: 500, height: 400, path: "#ease" });
```

---

## chars

**URL:** https://gsap.com/docs/v3/Plugins/SplitText/chars.md

**Contents:**
  - chars : Array
  - Details[‚Äã](#details "Direct link to Details")

An array containing all of the characters' raw DOM elements that were split apart.

An array containing all of the characters' raw DOM elements that were split apart. For example, if the original text was `"my split text"` the chars array would contain 11 elements.

---

## target

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/target.md

**Contents:**
  - target : Object
  - Details[‚Äã](#details "Direct link to Details")

The object that is being dragged.

*Object* - The object that is being dragged.

---

## MorphSVG

**URL:** https://gsap.com/docs/v3/Plugins/MorphSVGPlugin.md

**Contents:**
    - CDN Link
    - Minimal usage
- Description[‚Äã](#description "Direct link to Description")
    - loading...
- Features[‚Äã](#features "Direct link to Features")
- Simple Examples[‚Äã](#simple-examples "Direct link to Simple Examples")
- Configuration[‚Äã](#configuration "Direct link to Configuration")
- Tips[‚Äã](#tips "Direct link to Tips")
  - Morph into multiple shapes[‚Äã](#morph-into-multiple-shapes "Direct link to Morph into multiple shapes")
    - loading...

[YouTube video player](https://www.youtube.com/embed/Uxa9sdaeyKM)

MorphSVG morphs an SVG `<path>` by animating the data inside the `d` attribute. For example, you can morph a diamond into a lightning bolt with a single line of code:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/vEGpawb?default-tab=result\&theme-id=41164)

In this example, MorphSVG finds the path with the ID of "diamond" and the path with the ID of "lightning" and automatically figures out how to add enough points to the diamond to get a super smooth morph. It rips through all that ugly path data, converts everything to cubic beziers, and dynamically subdivides them when necessary, adding anchor points so that the beginning and ending quantities match (but visually it looks identical). It's all done seamlessly under the hood.

* Morph `<path>` data **even if the number (and type) of points don't match** between the start and end shapes!
* **Perfect shape fidelity**. Most other morphing tools use a lossy approximation of your artwork that falls apart in complex shapes, or they require matching point quantities in the start/end shapes. MorphSVG is both **super flexible** and **super accurate**.
* **Natural point mapping** that avoids strange twisting in other libraries caused by misaligned artwork point sequencing.
* Optionally **draw the resulting shape to a `<canvas>`** (see [`MorphSVGPlugin.defaultRender`](/docs/v3/Plugins/MorphSVGPlugin/static.defaultRender.md)).

* Morph a `<polyline>` or `<polygon>` to a different set of points.
* Turn primitive elements like `<circle>`, `<rect>`, `<ellipse>`, `<polygon>`, `<polyline>`, and `<line>` into the equivalent `<path>` with [`MorphSVGPlugin.convertToPath()`](/docs/v3/Plugins/MorphSVGPlugin/static.convertToPath.md) so you can then morph it.
* Not happy with the morph? There are plenty of **configuration options** to improve it, like setting `smooth: true` or `curveMode: true` or defining a `shapeIndex` or using a `rotational` type.
* Morph to raw path data (like `"M490.1,280.649c0,44.459-36.041,80..."`) or to a particular `<path>` element (using selector text like `"#diamond"` or even a direct reference to the element like `diamondEl`), making workflow easy.

In its simplest form, you can just morph to another element or raw path data directly:

If the shape you pass in is a `<circle>`, `<rect>`, `<ellipse>`, `<polygon>`, `<polyline>`, or `<line>`, MorphSVG will internally create path data from those shapes.

To configure the morph, use the object `{...}` syntax instead. `shape` is the only required property:

Here are the various configuration options:

boolean *(new in 3.14.0)*

Forces smooth anchors (on curves) to avoid kinks mid-morph by interpolating the angle and length of control point handles instead of their raw x/y coordinates. Normally you do **not** need to enable `curveMode`

In the example below, notice how `curveMode: true` prevents the kink mid-morph. However, `curveMode` can actually cause certain morphs to look slightly worse, especially if anchor points are close together, so it's wise to experiment and determine which look you prefer.

[MorphSVG: curveMode](https://codepen.io/GreenSock/embed/zxvRmrY?default-tab=result\&editable=true\&theme-id=41164)

"size" | "position" | "complexity"

If the sub-segments inside your path aren't matching up the way you hoped between the start and end shapes, you can use `map` to tell MorphSVG which algorithm to prioritize (see details below)

* `"size"` (the default) - Attempts to match segments based on their overall size. If multiple segments are close in size, it'll use positional data to match them. This mode typically gives the most intuitive morphs.
  * `"position"` - Matches mostly based on position (proximity).
  * `"complexity"` - Matches purely based on the quantity of anchor points. This is the fastest algorithm and it can be used to "trick" things to match up by manually adding anchors in your SVG authoring tool so that the pieces that you want matched up contain the same number of anchors (though that's completely optional).

* `map` is completely optional. Typically the default mode works great.
  * If none of the map modes get the segments to match up the way you want, it's probably best to just split your path into multiple paths and morph each one. That way you get total control.

* #### origin[](#origin)

Sets the origin of rotation. The default is `50% 50%`. The format is either a string of two percentage values, or a string or four values if there are different values for the start and end shapes.

To set your own origin:

sometimes the rotations around a point look odd, In cases like this, it's best to experiment and set your own custom origin to improve things even more. We created a `findMorphOrigin()` utility function to help with this...

`findMorphOrigin()` allows you to simply feed in a start and end shape and then it'll superimpose an origin that you can drag around and see exactly how it affects the morph! In the demo below, go into the JS panel and un-comment the `findMorphOrigin()` line and you'll see exactly how this works. Drag the origin around and watch how it affects things.

[MorphSVG: fixing type:"rotational" weirdness](https://codepen.io/GreenSock/embed/VqRVgr?default-tab=result\&editable=true\&theme-id=41164)

* #### precision[](#precision)

By default, MorphSVG will round values in the resulting `d` string to 2 decimal places in order to maximize performance and reduce string length but you can set `precision` to your preferred number of decimal places. For example, `precision: 5` would round to 5 decimal places:

* #### precompile[](#precompile)

Only for very advanced use cases where you're running into performance issues on the initial render, which is rare.

Tell MorphSVG to run all of its initial calculations and return an array with the transformed strings, logging them to the console where you can copy and paste them back into your tween. That way, when the tween begins it can just grab all the values directly instead of doing expensive calculations.

For more information see [precompile](#precompile)

* #### render[](#render)

Define a render function that'll be called every time the path updates, typically for drawing to `<canvas>`. See [Rendering to canvas](#rendering-to-canvas)

* #### shape[](#shape)

The shape to morph to. You can use selector text like `"#diamond"` or a direct reference to the element like `diamondEl` or even raw path data like `"M490.1,280.649c0,44.459-36.041,80..."`

* #### shapeIndex[](#shapeIndex)

The `shapeIndex` property controls how the points in the start shape are mapped to the ones in the end shape. Every closed path is drawn from a particular point on the path. For example, if you were drawing a circle with a pencil, you could start anywhere (1 o'clock, 9 o'clock, etc.). So if the starting shape begins its sequence of points in its upper left corner and it's mapped to an end shape whose points begin in the lower right corner (matching first with first, second with second, etc.) will result in the shape crossing over itself (visually inverting halfway through). Think of `shapeIndex` like an offset, so `shapeIndex: 3` would match up the 3rd point from the start shape with the first point in the end shape:

For help finding the best `shapeIndex`, see the [findShapeIndex() function](/docs/v3/Plugins/MorphSVGPlugin.md#findshapeindex-utility)

* `shapeIndex` only works on closed paths.
  * If you supply a negative `shapeIndex` the start path will be completely reversed (which can be quite useful

* #### smooth[](#smooth)

number | "auto" | object *(new in 3.14.0)*

Adds extra "smoothing" anchor points to the artwork. Think of it like increasing the resolution, inserting points to pull on during the morph. **Normally this is not necessary**, but if your original artwork has awkwardly-placed anchor points it can help make the morph look more natural.

You can define a specific number of points, like `smooth: 80` would redraw the path using 80 evenly-spaced anchor points (replacing all existing anchor points). Or `smooth: "auto"` would automatically choose a number of points based on the surface area. By default, smoothing the path will **redraw** it which is like tracing it at a certain resolution in order to distribute the anchor points evenly, so it loses some fidelity to the original artwork. You can use the object syntax to set `redraw: false` to avoid this (see details below). Keep in mind that if you use too many points, it could affect performance.

Use the object `{...}` syntax for more options:

* `points` (number | "auto") - the number of points to use for redrawing the path. Or if `redraw` is `false`, this is the number of points to **add** to the existing anchor points. `"auto"` (the default) automatically chooses a number based on the surface area of the path.
  * `redraw` (boolean) - By default, the path will be completely redrawn with new fabricated anchor points that are equally-spaced which entails a loss of fidelity to the original path since the original anchors are eliminated to prioritize equal spacing. To maintain **PERFECT fidelity** to the original artwork, set `redraw: false` and it will keep the original anchor points and intersperse the new smoothing points between those as evenly-spaced as possible. Redrawing almost always results in more evenly-spaced anchor points but it sacrifices some level of fidelity (more points delivers more fidelity). `redraw: false` delivers **perfect** fidelity but sacrifices equal spacing.
  * `persist` (boolean) - by default, the redrawn shape will persist at the end of the animation in order to avoid any visual jump back to the original artwork (from the loss in fidelity), but you can set `persist: false` to have it return to the original artwork at the end of the animation, eliminating the extra smoothing points that were added.

[Smooth Morph ](https://codepen.io/GreenSock/embed/EaKLgKZ/61c6551d1a18328828a229d25160e784?default-tab=result\&editable=true\&theme-id=41164)

"linear" | "rotational"

By default, all of the anchors and control points in the shape are interpolated linearly (`type: "linear"`) which is usually great but you can set `type: "rotational"` to make MorphSVG use rotation and length data for interpolation instead which can produce more natural morphs in some cases. It also eliminates kinks that may form in otherwise smooth anchors mid-tween (like `curveMode: true`). To tap into this alternative style of morphing, just set type: "rotational" in the object:

The concept is best understood visually, so here are some videos and demos...

[YouTube video player](https://www.youtube.com/embed/C-qo_aEAPp8)

[MorphSVG type:"rotational" for more natural morphs](https://codepen.io/GreenSock/embed/vvjOGq?default-tab=result\&editable=true\&theme-id=41164)

MorphSVG also stores the original path data on the target so that you can easily tween back to the original shape. (like `data-original="M490.1,280.649c0,44.459-36.041,80..."`)

Sequencing multiple morphs is a breeze with GSAP. Watch how easy it is to make that diamond morph into various other shapes and back again:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/MWMVKmp?default-tab=result\&theme-id=41164)

[YouTube video player](https://www.youtube.com/embed/jcq9kEyJNMM)

Technically it's only feasible to morph `<path>` elements or `<polyline>`/`<polygon>` elements, but what if you want to morph a `<circle>`, `<rect>`, `<ellipse>`, or `<line>`? No problem - just tap into the utility method and have the plugin do the conversion for you:

You can pass in an element or selector text, so you could also have it convert ALL of those elements with one line:

This literally swaps in a for each one directly in the DOM, and it should look absolutely identical. It'll keep the attributes, like the "id" attribute. So after the conversion, you should be able to target the elements pretty easily, just as you would previously.

Experimenting with `shapeIndex` can be a bit of a guessing game. To make things easier we have created a stand-alone utility function called `findShapeIndex()` that you can use just during development to find the right number to plug into the final animation. This function provides an interactive user interface to help you visualize where the start point is, change it, and preview the animation.

You can load `findShapeIndex()` from [this download link](https://s3-us-west-2.amazonaws.com/s.cdpn.io/16327/findShapeIndex.js).

Once it's loaded you simply tell it which shapes to use.

The best way to get started is to drop your SVG into the pen and alter the IDs to match your svg.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/763b6533f17a795c3cd957c668c33882?default-tab=result\&theme-id=41164)

Performance tip: define a `shapeIndex` in advance

MorphSVGPlugin's default `shapeIndex: "auto"` does a bunch of calculations to reorganize the points so that they match up in a natural way but if you define a numeric `shapeIndex` (like `shapeIndex: 5`) it skips those calculations. Each segment inside a path needs a `shapeIndex`, so multiple values are passed in an array like `shapeIndex:[5, 1, -8, 2]`. But how would you know what numbers to pass in? The `findShapeIndex()` tool helps for single-segment paths, what about multi-segment paths? It's a pretty complex thing to provide a GUI for.

**read more about shapeIndex...**

Typically the default `"auto"` mode works great but the goal here is to avoid the calculations, so there is a `"log"` value that will act just like `"auto"` but it will also `console.log()` the `shapeIndex` value(s). That way, you can run the tween in the browser once and look in your console and see the numbers that `"auto"` mode would produce. Then it's simply a matter of copying and pasting that value into your tween where `"log"` was previously.

While precompiling isn't usually necessary, it can really improve performance for very complex morphs. Precompiling involves having MorphSVG run all of its initial calculations and then spit out an array with the transformed strings, logging them to the console where you can copy and paste them back into your tween. That way, when the tween begins it can just grab all the values directly and skip the expensive startup calculations.

**show precompiling example...**

As an example, here's [a really cool CodePen](https://codepen.io/davatron5000/pen/meNOqK/) by Dave Rupert before it was precompiled. Notice the very first time you click the toggle button, it may seem to jerk a bit because the entire brain is one path with many segments, and it must get matched up with all the letters and figure out the `shapeIndex` for each (which is expensive). By contrast, [here's a fork](https://codepen.io/GreenSock/pen/MKevzM) of that pen that has precompile enabled. You may noticed that it starts more smoothly.

* `precompile` is only available on `<path>` elements (not `<polyline>`/`<polygon>`). You can easily convert things using `MorphSVGPlugin.convertToPath("polygon, polyline");`

* Precompiling only improves the performance of the first (most expensive) render. If your entire morph is janky throughout the tween, it most likely has nothing to do with GSAP; your SVG may be too complex for the browser to render fast enough. In other words, the bottleneck is probably the browser's graphics rendering routines. Unfortunately, there's nothing GSAP can do about that and you'll need to simplify your SVG artwork and/or reduce the size at which it is displayed.

* The precompiled values are inclusive of `shapeIndex` adjustments. In other words, `shapeIndex` gets baked in.

* In most cases, you probably don't need to precompile; it's intended to be an advanced technique for squeezing every ounce of performance out of a very complex morph.

* If you alter the original start or end shape/artwork, make sure you precompile again so that the values reflect your changes.

SVG is fantastic, but sometimes developers prefer a canvas-based animation (often for rendering performance reasons). The MorphSVG plugin allows you to define a `render` function that'll be called every time the path updates.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/WYWZab?default-tab=result\&theme-id=41164)

**read more about canvas rendering...**

The render function will receive two parameters:

1. **`rawPath`** \[array]: A RawPath is essentially an array containing an array for each contiguous segment with alternating x, y, x, y cubic bezier data. It's like an SVG `<path>` where there's one segment (array) for each `M` command. That segment (array) contains all of the cubic bezier coordinates in alternating x/y format (just like SVG path data) in raw numeric form which is nice because that way you don't have to parse a long string and convert things.

For example, this SVG `<path>` has two separate segments because there are two `M` commands: `<path d="M0,0 C10,20,15,30,5,18 M0,100 C50,120,80,110,100,100"></path>` So the resulting **RawPath** would be:

For simplicity, the example above only has one cubic bezier in each segment, but there could be an unlimited quantity inside each segment. No matter what path commands are in the original`<path>` data string (cubic, quadratic, arc, lines, whatever), the resulting RawPath will **ALWAYS** be cubic beziers.

2. **`target`** \[object]: The target of the tween (usually a `<path>`)

This means you can even render morphs to super high-performance engines like [PixiJS](//pixijs.com/) or anything that'll allow you to draw cubic beziers!

Here's an example of a tween and a render function that'd draw the morphing shape to canvas:

To set a default render method for all tweens:

By default, MorphSVG will update the original target of the tween (typically an SVG `<path>` element), but if you're only drawing to canvas you can tell MorphSVG to skip updating the target like this:

To set the default `updateTarget` value for all tweens (so that you don't have to add it to every tween):

|                                                                                                                    |                                                                                                                                                                                   |
| ------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| #### [MorphSVGPlugin.defaultRender](/docs/v3/Plugins/MorphSVGPlugin/static.defaultRender.md) : Function            | Sets the default function that should be called whenever a morphSVG tween updates. This is useful if you're rendering to `<canvas>`.                                              |
| #### [MorphSVGPlugin.defaultType](/docs/v3/Plugins/MorphSVGPlugin/static.defaultType.md) : String                  | Sets the default `"type"` for all MorphSVG animations. The default `type` is `"linear"` but you can change it to `"rotational"`.                                                  |
| #### [MorphSVGPlugin.defaultUpdateTarget](/docs/v3/Plugins/MorphSVGPlugin/static.defaultUpdateTarget.md) : Boolean | Sets the default `updateTarget` value for all MorphSVG animations; if `true`, the original tween target (typically an SVG `<path>` element) itself gets updated during the tween. |

|                                                                                                                                                  |                                                                                                                                                                                                                                                                                                             |
| ------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| #### [MorphSVGPlugin.convertToPath](/docs/v3/Plugins/MorphSVGPlugin/static.convertToPath.md)( shape:\[Element \| String], swap:Boolean ) : Array | Converts SVG shapes like `<circle>`, `<rect>`, `<ellipse>`, or `<line>` into `<path>`                                                                                                                                                                                                                       |
| #### [MorphSVGPlugin.rawPathToString](/docs/v3/Plugins/MorphSVGPlugin/static.rawPathToString.md)( rawPath:Array ) : String                       | Converts a RawPath (array) into a string of path data, like `"M0,0 C100,20 300,50 400,0..."` which is what's typically found in the `d` attribute of a `<path>`.                                                                                                                                            |
| #### [MorphSVGPlugin.stringToRawPath](/docs/v3/Plugins/MorphSVGPlugin/static.stringToRawPath.md)( data:String ) : RawPath                        | Takes a string of path data (like `"M0,0 C100,20 300,50 400,0..."`, what's typically found in the `d` attribute of a `<path>`), parses it, converts it into cubic beziers, and returns it as a RawPath which is just an array containing an array for each segment (each `M` command starts a new segment). |

Check out the full collection of [How-to demos](https://codepen.io/collection/noQGjq) and our favourite [inspiring community demos](https://codepen.io/collection/naMaNQ) on CodePen.

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(MorphSVGPlugin)
```

Example 2 (unknown):
```unknown
gsap.to("#circle", { duration: 1, morphSVG: "#lightning" });
```

Example 3 (unknown):
```unknown
gsap.to("#diamond", { duration: 1, morphSVG: "#lightning" });
```

Example 4 (unknown):
```unknown
// selector string (grabs the data from the corresponding element's "d" attribute)
gsap.to("#diamond", { morphSVG: "#lightning" });

// an SVG element
const endShape = document.getElementById("lightning");
gsap.to("#diamond", { morphSVG: endShape });

// raw path data (string)
gsap.to("#diamond", { morphSVG: "M47.1,0.8 73.3,0.8 61.9,37.2 77.1,37.2 30.7,99.4 45.8,51.9 29,51.9z" });

// points for polygon or polyline elements:
gsap.to("#polygon", { morphSVG: "240,220 240,70 70,70 70,220" });
```

---

## vars

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/vars.md

**Contents:**
  - vars : Object
  - Details[‚Äã](#details "Direct link to Details")

The `vars` object passed into the constructor which stores configuration variables like `type`, `bounds`, `onPress`, `onDrag`, etc.

*Object* - The `vars` object passed into the constructor which stores configuration variables like `type`, `bounds`, `onPress`, `onDrag`, etc.

---

## isThrowing

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/isThrowing.md

**Contents:**
  - isThrowing : Boolean
  - Details[‚Äö√Ñ√£](#details "Direct link to Details")

Reports if the target of a Draggable is being thrown using a InertiaPlugin tween.

*Boolean* - `isThrowing` will be `true` if the Draggable's target is currently being animated by an inertia tween.

---

## ScrollSmoother

**URL:** https://gsap.com/docs/v3/Plugins/ScrollSmoother.md

**Contents:**
    - CDN Link
    - Minimal usage
- Feature Highlights[‚Äã](#feature-highlights "Direct link to Feature Highlights")
- Setup[‚Äã](#setup "Direct link to Setup")
- Example[‚Äã](#example "Direct link to Example")
    - loading...
- **Config Object**[‚Äã](#config-object "Direct link to config-object")
- Speed (parallax)[‚Äã](#speed-parallax "Direct link to Speed (parallax)")
  - "auto" speed[‚Äã](#auto-speed "Direct link to \"auto\" speed")
  - clamp() speed effects[‚Äã](#clamp-speed-effects "Direct link to clamp() speed effects")

added in v<!-- -->3.10.0

ScrollSmoother adds a vertical smooth-scrolling effect to a ScrollTrigger-based page. Unlike most smooth-scrolling libraries, ScrollSmoother leverages **NATIVE** scrolling - it doesn't add "fake" scrollbars nor does it mess with touch/pointer functionality. That means it doesn't suffer from many of the accessibility annoyances common with smooth-scrolling sites.

* Uses the browser's **native scroll**; no "fake" scrollbars.
* Add a **parallax effect** by defining a `data-speed` attribute on any element, like `data-speed="0.5"` would make that element "scroll" at half-speed while it's in the viewport. It arrives at its normal position in the document flow when it's **centered** vertically.
* Put a larger image/element inside a container that has `overflow: hidden` and then set the child's `data-speed="auto"` and it'll automatically calculate exactly how far it can move inside that container (parallax).
* Make an element appear to **lag behind**, taking a certain amount of time to "catch up" to the smoothed scroll position. It's a really fun effect! Simply define a `data-lag` attribute, like `data-lag="0.5"` would take 0.5 seconds to "catch up".

* ScrollSmoother is **seamlessly integrated** with [ScrollTrigger](/docs/v3/Plugins/ScrollTrigger/.md) and GSAP for mega-robust animation capabilities.
* Set [paused(true)](/docs/v3/Plugins/ScrollSmoother/paused\(\).md) to completely halt scrolling (users can't even drag the scrollbar) - great for modals.
* The `normalizeScroll: true` feature prevents \[most] mobile browser address bars from hiding/showing (resizing the viewport), stops overscroll behavior, and solves multi-thread synchronization challenges!
* A side benefit of using ScrollSmoother is that it avoids issues caused by browser multi-threading, like the small jump that sometimes happens when pinning/unpinning, or the occasional "jitter" of a pinned element in certain rare scenarios. You can even set `normalizeScroll: true` to avoid common problems like the hiding/showing of the address bar on mobile browsers, plus it'll work around iOS Safari bugs that occasionally cause jitter. See [ScrollTrigger.normalizeScroll()](/docs/v3/Plugins/ScrollTrigger/static.normalizeScroll\(\).md) for details.

Your HTML content should reside in a single `content` element (usually a `<div>` but it doesn't really matter) - that's what gets moved around when the user scrolls. That `content` element is wrapped in a `wrapper` element that serves as the viewport. The actual scrollbar remains on the `<body>`, so your setup would look like:

Under the hood, everything flows through [ScrollTrigger](/docs/v3/Plugins/ScrollTrigger/.md) which watches the page's native scroll position and then ScrollSmoother applies transforms to the `content` to gradually catch up with that scroll position. So if you suddenly drag the native scrollbar 500px, ScrollSmoother will gradually move the content to that spot using inline CSS transforms (`matrix3d()`) on the `content`. Since ScrollSmoother is built on top of ScrollTrigger, don't forget to register them both:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/d03d2e4695cf6a87ebc59a2fbbbdef53?default-tab=result\&theme-id=41164)

The configuration object can have any of the following optional properties:

Element | String - the element containing all of your HTML content. This one `content` element is what gets moved around when scrolling. By default, it will automatically find the element with an id of "smooth-content", so if you're following that convention there's no need to even define `content`. The HTML structure would look like this:

String | Function - the easing function to be used for smooth scrolling (defaults to "expo").

* #### effects[](#effects)

boolean | String | Array - if `true`, ScrollSmoother will find all elements that have a `data-speed` and/or `data-lag` attribute and apply those effects accordingly so that they move at the designated speed or delay, so `data-speed="0.5"` would scroll at half the normal speed, and `data-speed="2"` would scroll at twice the normal speed. `data-lag="0.8"` would take 0.8 seconds to "catch up" to the smoothed scroll position. You can also use selector text or an Array of elements, so `effects: ".box"` would only look for the attributes on elements with the ".box" class. You can use the [effects()](/docs/v3/Plugins/ScrollSmoother/effects\(\).md) method to apply effects directly via JavaScript instead. See that method's docs for more details about how effects work. *Note: effects should not be nested.*

* #### effectsPadding[](#effectsPadding)

Number - Normally effects applied to a particular element begin as soon as the natural position of the element enters the viewport and then end when the natural position leaves the viewport, but in some rare cases you may want to expand that, so you can pass a number (in pixels) as the `effectsPadding`. *Added in 3.11.4*

* #### effectsPrefix[](#effectsPrefix)

String - perhaps you're already using `data-speed` and/or `data-lag` for other purposes and you'd like to use a custom prefix for effects data attributes like `effectsPrefix: "scroll-"` would resolve to `data-scroll-speed` and `data-scroll-lag`. *Added in 3.10.5*

* #### ignoreMobileResize[](#ignoreMobileResize)

Boolean - if `true`, vertical resizes (of 25% of the viewport height) on touch-only devices won't trigger a `ScrollTrigger.refresh()`, avoiding the jumps that can happen when the start/end values are recalculated. Beware that if you skip the refresh(), the start/end trigger positions may be inaccurate but in many scenarios that's preferable to the visual jumps that occur due to the new start/end positions.

* #### onFocusIn[](#onFocusIn)

Function - a function to call when a new element receives focus and you can return `false` if you want ScrollSmoother to skip ensuring that the element is in the viewport (overriding that default behavior).

* #### onStop[](#onStop)

Function - a function to call when the smoothed scroll comes to a stop (catches up to the native scroll position).

* #### onUpdate[](#onUpdate)

Function - a function to call after each time the SmoothScroller updates the position of the content.

* #### normalizeScroll[](#normalizeScroll)

boolean - if `true`, it forces scrolling to be done on the JavaScript thread, ensuring it is synchronized and the address bar doesn't show/hide on mobile devices. This is the same as calling [ScrollTrigger.normalizeScroll()](/docs/v3/Plugins/ScrollTrigger/static.normalizeScroll\(\).md) except that it *debounces* because smooth scrolling makes that possible.

* #### smooth[](#smooth)

Number - the time (in seconds) that it takes to "catch up" to the native scroll position. By default, it is 0.8 seconds.

* #### smoothTouch[](#smoothTouch)

Boolean | Number - by default, ScrollSmoother will **NOT** apply scroll smoothing on touch-only devices (like phones) because that typically feels odd to users when it disconnects from their finger's drag position, but you can force smoothing on touch devices too by setting `smoothTouch: true` (same as `smooth` value) or specify an amount like `smoothTouch: 0.1` (in seconds).

* #### speed[](#speed)

Number - a multiplier for overall scroll speed, so `2` would make it scroll twice the normal speed, and `0.5` would make it scroll at half-speed. *added in version 3.11.4*.

* #### wrapper[](#wrapper)

Element | String - the outer-most element that serves as the viewport. Its only child should be the `content` element which is what gets moved around when scrolling. By default, it will automatically find the element with an id of "smooth-wrapper", so if you're following that convention there's no need to even define `wrapper`. If it cannot find a wrapper, one will automatically be created. You can use selector text like `"#elementID"` or reference the element itself.

When you set `effects: true`, ScrollSmoother finds all elements that have a `data-speed` attribute and applies a parallax effect accordingly so that they move at the designated speed. For example:

When you set the speed to `"auto"`, it will calculate how far it can move inside its **parent container** in the direction of the largest gap (up or down). So it's perfect for parallax effects - just make the child larger than its parent, align it where you want it (typically its top edge at the top of the container, or the bottom edge at the bottom of the container) and let ScrollSmoother do its magic. Obviously set `overflow: hidden` on the parent so it clips the child.

Have you ever had an element that you natively placed toward the very top of your page but when you apply a `data-speed`, it starts out shifted from its native position? That's because by default, speed effects cause elements to reach their "native" position when **centered vertically** in the viewport, so they'll likely start out offset. Starting in version 3.12, you can wrap your speed value in `"clamp()"` to make them start out in their native position if they're "above the fold" (inside the viewport when scrolled to the very top). Under the hood, `data-speed` effects are driven by ScrollTrigger instances, so this a way to employ ScrollTrigger's clamp() feature that prevents the start/end values from "leaking" outside the page bounds (never less than 0 and never more than the maximum scroll position). For example:

You can also use the [effects()](/docs/v3/Plugins/ScrollSmoother/effects\(\).md) method to dynamically apply speed or lag effects to targets (including function-based ones). *Note: effects **should not be nested**.*

Keep in mind that the elements will hit their "natural" position in the **CENTER** of the viewport. Here's a visual demo from [@snorkltv](https://www.creativecodingclub.com/courses/FreeGSAP3Express?ref=44f484):

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/vYjrKWX?default-tab=result\&theme-id=41164)

Think of a "lag" like making the element lazy, allowing it to drift from its normal scroll position, taking a certain amount of time to "catch up". You can assign slightly different lags to elements in close proximity to give them a staggered effect when scrolling that's quite pleasing to the eye. If you set `effects: true` on the ScrollSmoother.create() config, it'll automatically find any elements with the `data-lag` attribute and apply that effect:

You can also use the [effects()](/docs/v3/Plugins/ScrollSmoother/effects\(\).md) method to dynamically apply speed or lag effects to targets (including function-based ones) via JavaScript.

* \*\*`position: fixed` should be outside the wrapper \*\*- since the `content` has a CSS `transform` applied, browsers create a new containing block and that means `position: fixed` elements will be fixed to the `content` rather than the viewport. That's not a bug - it's just how CSS/browsers work. You can use ScrollTrigger pinning instead or you could put any `position: fixed` elements OUTSIDE the `wrapper`/`content`.
* **`normalizeScroll: true` doesn't prevent the address bar from hiding/showing on iOS phones in portrait orientation** - the latest Apple iOS makes it impossible to prevent that (at least from what we can tell). Even though `event.preventDefault()` is called on all scroll-related events, the browser *still* imposes that behavior. If that causes a jump due to the window resizing and making your ScrollTriggers recalculate their start/end positions, you could `ScrollTrigger.config({ ignoreMobileResize: true });`

|                                                                                         |                                                                                                                                                                                                                        |
| --------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| #### [.progress](/docs/v3/Plugins/ScrollSmoother/progress.md) : Number                  | The progress value of the overall page scroll where 0 is at the very top and 1 is at the very bottom and 0.5 is halfway scrolled. This value will animate during the smooth scrolling and end when the `onStop` fires. |
| #### [.scrollTrigger](/docs/v3/Plugins/ScrollSmoother/scrollTrigger.md) : ScrollTrigger | The ScrollTrigger instance that ScrollSmoother created internally to manage the smooth scrolling effect of the page.                                                                                                   |
| #### [.vars](/docs/v3/Plugins/ScrollSmoother/vars.md) : Object                          | The configuration object passed into the [ScrollSmoother.create()](/docs/v3/Plugins/ScrollSmoother/static.create\(\).md) initially.                                                                                    |

|                                                                                                                                            |                                                                                                                                                                                                                             |
| ------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| #### [.content](/docs/v3/Plugins/ScrollSmoother/content\(\).md)( element:String \| Element ) : Element \| self                             | Gets/Sets the content element.                                                                                                                                                                                              |
| #### [.effects](/docs/v3/Plugins/ScrollSmoother/effects\(\).md)( targets:String \| Element \| Array, config:Object \| null ) : Array       | Adds parallax elements that should be managed by the ScrollSmoother                                                                                                                                                         |
| #### [.getVelocity](/docs/v3/Plugins/ScrollSmoother/getVelocity\(\).md)( ) : Number                                                        | Returns the current velocity of the smoothed scroll in pixels-per-second                                                                                                                                                    |
| #### [.kill](/docs/v3/Plugins/ScrollSmoother/kill\(\).md)( ) ;                                                                             | Kills the entire ScrollSmoother as well as any effects that were applied.                                                                                                                                                   |
| #### [.offset](/docs/v3/Plugins/ScrollSmoother/offset\(\).md)( target:String \| Element, position:String ) : Number                        | Calculates the numeric offset (scroll position in pixels) that corresponds to when a particular element reaches the specified position like:                                                                                |
| #### [.paused](/docs/v3/Plugins/ScrollSmoother/paused\(\).md)( pause:Boolean ) : Boolean \| self                                           | Gets/Sets the paused state - if `true`, nothing will scroll (except via [scrollTop()](/docs/v3/Plugins/ScrollSmoother/scrollTop\(\).md) or [scrollTo()](/docs/v3/Plugins/ScrollSmoother/scrollTo\(\).md) on this instance). |
| #### [.scrollTo](/docs/v3/Plugins/ScrollSmoother/scrollTo\(\).md)( target:Number \| String \| Element, smooth:Boolean, position:String ) ; | Scrolls to a particular position or element                                                                                                                                                                                 |
| #### [.scrollTop](/docs/v3/Plugins/ScrollSmoother/scrollTop\(\).md)( position:Number ) : Number \| void                                    | Immediately gets/sets the scroll position (in pixels).                                                                                                                                                                      |
| #### [.smooth](/docs/v3/Plugins/ScrollSmoother/smooth\(\).md)( duration:Number ) : Number \| self                                          | Gets/Sets the number of seconds it takes to catch up to the scroll position (smoothing).                                                                                                                                    |
| #### [ScrollSmoother.create](/docs/v3/Plugins/ScrollSmoother/static.create\(\).md)( ) ;                                                    |                                                                                                                                                                                                                             |
| #### [ScrollSmoother.get](/docs/v3/Plugins/ScrollSmoother/static.get\(\).md)( ) : ScrollSmoother                                           | Returns the ScrollSmoother instance (if one has been created). There can only be one instance at any given time.                                                                                                            |
| #### [.wrapper](/docs/v3/Plugins/ScrollSmoother/wrapper\(\).md)( element:String \| Element ) : Element \| self                             | Gets/Sets the wrapper element.                                                                                                                                                                                              |

Check out the full collection of [Scroll animation demos](https://codepen.io/collection/bNPYOw) on CodePen.

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(ScrollSmoother)
```

Example 2 (unknown):
```unknown
ScrollSmoother.create({
	smooth: 1,
	effects: true
});
```

Example 3 (unknown):
```unknown
<body>
	<div id="smooth-wrapper">
		<div id="smooth-content">
			<!--- ALL YOUR CONTENT HERE --->
		</div>
	</div>
	<!-- position: fixed elements can go outside --->
</body>
```

Example 4 (unknown):
```unknown
gsap.registerPlugin(ScrollTrigger, ScrollSmoother);
```

---

## rotation

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/rotation.md

**Contents:**
  - rotation : Number
  - Details[‚Äã](#details "Direct link to Details")

\[read-only] \[only applies to `type: "rotation"`] The current rotation (in degrees) of the Draggable instance.

*Number* - \[only applies to `type: "rotation"`] The current rotation (in degrees) of the Draggable instance. This is the rotation transform, as in the CSS `transform: rotate(...deg)`. This value is updated each time the Draggable is dragged interactively and during the momentum-based tween that Draggable applies when the user releases their mouse/touch, but if you manually change (or tween) the element's rotation you can force Draggable to look at the "real" value and record it to its own `x` property by calling the Draggable's `update()` method. Basically that re-synchronizes it. Again, this is not necessary unless other code (outside Draggable) alters the target element's position.

---

## x

**URL:** https://gsap.com/docs/v3/Plugins/Observer/x.md

**Contents:**
  - x : Number
  - Details[‚Äã](#details "Direct link to Details")

the `clientX` from the most recent touch/pointer event, which refers to the horizontal distance from the left edge of the viewport. This only gets updated if you set the `type` to include "touch" and/or "pointer".

the `clientX` from the most recent touch/pointer event, which refers to the horizontal distance from the left edge of the viewport. This only gets updated if you set the `type` to include "touch" and/or "pointer".

---

## Tween

**URL:** https://gsap.com/docs/v3/GSAP/Tween.md

**Contents:**
    - Minimal usage
    - loading...
    - loading...
- Special Properties[‚Äã](#special-properties "Direct link to Special Properties")
- Plugins[‚Äã](#plugins "Direct link to Plugins")
- Function-based values[‚Äã](#function-based-values "Direct link to Function-based values")
- Random values[‚Äã](#random-values "Direct link to Random values")
- Relative values[‚Äã](#relative-values "Direct link to Relative values")
- Staggers[‚Äã](#staggers "Direct link to Staggers")
- Sequencing[‚Äã](#sequencing "Direct link to Sequencing")

A Tween is what does all the animation work - think of it like a **high-performance property setter**. You feed in targets (the objects you want to animate), a duration, and any properties you want to animate and when its playhead moves to a new position, it figures out what the property values should be at that point applies them accordingly.

**Methods for creating a Tween** (all of these methods return a Tween instance):

* [gsap.to()](/docs/v3/GSAP/gsap.to\(\).md)
* [gsap.from()](/docs/v3/GSAP/gsap.from\(\).md)
* [gsap.fromTo()](/docs/v3/GSAP/gsap.fromTo\(\).md)

For simple animations, the methods above are all you need! For example:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/wvwEOZL?default-tab=result\&theme-id=41164)

Since GSAP can animate any property of any object, you are NOT limited to CSS properties or DOM objects. Go crazy. You may be surprised by how many things can be animated with GSAP and it "just works".

You can do basic sequencing by using the `delay` special property, but [Timelines](/docs/v3/GSAP/Timeline.md) make sequencing and complex choreography much, much easier. A Timeline is like a container for multiple Tween instances (and/or other [Timelines](/docs/v3/GSAP/Timeline.md)) where you can position them in time and control them as a whole. See the [Timeline docs](/docs/v3/GSAP/Timeline.md) for details.

To control the Tween instance later, assign it to a variable (GSAP is conveniently object-oriented):

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/OJLgdyg?default-tab=result\&theme-id=41164)

To simply fire off animations and let them run, there's no need to use variables. Tweens play immediately by default (though you can set a `delay` or `paused` value) and when they finish, they automatically dispose of themselves. Call `gsap.to()` as much as you want without worrying about cleanup.

1. **targets** - the object(s) whose properties you want to animate. This can be selector text like `".class"`, `"#id"`, etc. (GSAP uses [`document.querySelectorAll()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll) internally) or it can be direct references to elements, ¬†generic objects, or even an array of objects
2. **vars** - an object containing all the properties/values you want to animate, along with any special properties like `ease`, `duration`, `delay`, or `onComplete` (listed below).

The scope to be used for all of the callbacks (onStart, onUpdate, onComplete, etc.).

Assign arbitrary data to this property (a string, a reference to an object, whatever) and it gets attached to the tween instance itself so that you can reference it later like `yourTween.data`.

* #### delay[](#delay)

Amount of delay before the animation should begin (in seconds).

* #### duration[](#duration)

The duration of the animation (in seconds). Default: `0.5`.

Controls the rate of change during the animation, giving it a specific feel. For example, `"elastic"` or `"strong.inOut"`. See the [Ease Visualizer](/docs/v3/Eases.md) for a list of all of the options. `ease` can be a String (most common) or a function that accepts a progress value between 0 and 1 and returns a converted, similarly normalized value. Default: `"power1.out"`.

Allows you to (optionally) assign a unique identifier to your tween instance so that you can find it later with `gsap.getById()` and it will show up in [GSDevTools](/docs/v3/Plugins/GSDevTools.md) with that id.

* #### immediateRender[](#immediateRender)

Normally a tween waits to render for the first time until the very next tick (update cycle) unless you specify a delay. Set `immediateRender: true` to force it to render immediately upon instantiation. Default: `false` for [to()](/docs/v3/GSAP/gsap.to\(\).md) tweens, `true` for [from()](/docs/v3/GSAP/gsap.from\(\).md) and [fromTo()](/docs/v3/GSAP/gsap.fromTo\(\).md) tweens or anything with a [scrollTrigger](/docs/v3/Plugins/ScrollTrigger/.md) applied.

* #### inherit[](#inherit)

Normally tweens inherit from their parent timeline's `defaults` object (if one is defined), but you can disable this on a per-tween basis by setting `inherit: false`.

When a tween renders for the very first time and reads its starting values, GSAP will try to delay writing of values until the very end of the current "tick" which can improve performance because it avoids the read/write/read/write layout thrashing that browsers dislike. To disable lazy rendering for a particular tween, set `lazy: false`. In most cases, there's no need to set `lazy`. To learn more, watch [this video](https://www.youtube.com/watch?v=TMHJptqnDpU). Default: `true` (except for zero-duration tweens).

* #### onComplete[](#onComplete)

A function to call when the animation has completed.

* #### onCompleteParams[](#onCompleteParams)

An Array of parameters to pass the onComplete function. For example, `gsap.to(".class", {x:100, onComplete:myFunction, onCompleteParams:["param1", "param2"]});`.

* #### onRepeat[](#onRepeat)

A function to call each time the animation enters a new iteration cycle (repeats). Obviously this only occurs if you set a non-zero `repeat`.

* #### onRepeatParams[](#onRepeatParams)

An Array of parameters to pass the onRepeat function.

* #### onReverseComplete[](#onReverseComplete)

A function to call when the animation has reached its beginning again from the reverse direction (excluding repeats).

* #### onReverseCompleteParams[](#onReverseCompleteParams)

An Array of parameters to pass the onReverseComplete function.

* #### onStart[](#onStart)

A function to call when the animation begins (when its time changes from 0 to some other value which can happen more than once if the tween is restarted multiple times).

* #### onStartParams[](#onStartParams)

An Array of parameters to pass the onStart function.

* #### onUpdate[](#onUpdate)

A function to call every time the animation updates (on each "tick" that moves its playhead).

* #### onUpdateParams[](#onUpdateParams)

An Array of parameters to pass the onUpdate function.

* #### overwrite[](#overwrite)

If `true`, all tweens of the same targets will be killed immediately regardless of what properties they affect. If `"auto"`, when the tween renders for the first time it hunt down any conflicts in active animations (animating the same properties of the same targets) and kill **only those parts** of the other tweens. Non-conflicting parts remain intact. If `false`, no overwriting strategies will be employed. Default: `false`.

* #### paused[](#paused)

If `true`, the animation will pause itself immediately upon creation. Default: `false`.

* #### repeat[](#repeat)

How many times the animation should repeat. So `repeat: 1` would play a total of two iterations. Default: `0`. `repeat: -1` will repeat infinitely.

* #### repeatDelay[](#repeatDelay)

Amount of time to wait between repeats (in seconds). Default: `0`.

* #### repeatRefresh[](#repeatRefresh)

Setting `repeatRefresh: true` causes a repeating tween to `invalidate()` and re-record its starting/ending values internally on each full iteration (not including yoyo's). This is useful when you use dynamic values (relative, random, or function-based). For example, `x: "random(-100, 100)"` would get a new random x value on each repeat. `duration`, `delay`, and `stagger` do **NOT** refresh.

* #### reversed[](#reversed)

If `true`, the animation will start out with its playhead reversed, meaning it will be oriented to move toward its start. Since the playhead begins at a time of 0 anyway, a reversed tween will *appear* paused initially because its playhead cannot move backward past the start.

* #### runBackwards[](#runBackwards)

If `true`, the animation will invert its starting and ending values (this is what a [from()](/docs/v3/GSAP/gsap.from\(\).md) tween does internally), though the ease doesn't get flipped. In other words, you can make a `to()` tween into a `from()` by setting `runBackwards: true`.

* #### stagger[](#stagger)

If multiple targets are defined, you can easily [stagger](https://codepen.io/GreenSock/pen/938f5cd34818443c43af9ba2692137a5) the start times for each by setting a value like `stagger: 0.1` (for 0.1 seconds between each start time). Or you can get much more advanced staggers by using a stagger object. For more information, see [the stagger documentation](/resources/getting-started/Staggers.md).

* #### startAt[](#startAt)

Defines starting values for any properties (even if they're not animating). For example, `startAt: {x: -100, opacity: 0}`

If `true`, every other `repeat` iteration will run in the opposite direction so that the tween appears to go back and forth. This has no affect on the `reversed` property though. So if `repeat` is `2` and `yoyo` is `false`, it will look like: start - 1 - 2 - 3 - 1 - 2 - 3 - 1 - 2 - 3 - end. But if `yoyo` is `true`, it will look like: start - 1 - 2 - 3 - 3 - 2 - 1 - 1 - 2 - 3 - end. Default: `false`.

* #### yoyoEase[](#yoyoEase)

Allows you to alter the ease in the tween's `yoyo` phase. Set it to a specific ease like `"power2.in"` or set it to `true` to simply invert the tween's normal `ease`. Note: GSAP is smart enough to automatically set `yoyo: true` if you define any `yoyoEase`, so there's less code for you to write. Default: `false`.

* #### keyframes[](#keyframes)

To animate the targets to various states, use `keyframes` - an array of vars objects that serve as `to()` tweens. For example, `keyframes: [{x:100, duration:1}, {y:100, duration:0.5}]`. All keyframes will be perfectly sequenced back-to-back, but you can define a `delay` value to add spacing between each step (or a negative delay would create an overlap). Keyframes are only to be used in `to()` tweens.

A plugin adds extra capabilities to GSAP's core. Some plugins make it easier to work with rendering libraries like PIXI.js or EaselJS while other plugins add superpowers like [morphing](/docs/v3/Plugins/MorphSVGPlugin.md) SVG shapes, adding [drag and drop](/docs/v3/Plugins/Draggable/.md) functionality, etc. This allows the GSAP core to remain relatively small and lets you add features only when you need them. [See the full list of plugins here](/docs/v3/Plugins.md).

Get incredibly dynamic animations by using a function for any value, and it will get called **once for each target** the first time the tween renders, and whatever is returned by that function will be used as the value. This can be very useful for applying conditional logic or randomizing things (though GSAP has baked-in randomizing capabilities too...scroll down for that).

The function is passed three parameters:

1. index - the index of the target in the array. For example, if there are 3 `<div>` elements with the class ".box", and you `gsap.to(".box", ...)`, the function gets called 3 times (once for each target); the index would be `0` first, then `1`, and finally `2`.
2. target - the target itself (the `<div>` element in this example)
3. targets - the array of targets (same as `tween.targets()`)

Define random values as a string like `"random(-100, 100)"`¬†for a range or like `"random([red, blue, green])"`¬†for an array and GSAP will swap in a random value **for each target** accordingly! This makes advanced randomized effects simple. You can even have the random number rounded to the closest increment of any number! For example:

Or use an array-like value and GSAP will randomly select one of those:

There's also a [`gsap.utils.random()`](/docs/v3/GSAP/UtilityMethods/random\(\).md) function that you can use directly if you prefer.

Use a`"+="` or `"-="` prefix to indicate a relative value. For example, `gsap.to(".class", {x:"-=20"});` will animate `x` 20 pixels **less than** whatever it is when the tween starts. `{x:"+=20"}` would **add** 20.

If multiple targets are defined, you can easily [stagger](https://codepen.io/GreenSock/pen/938f5cd34818443c43af9ba2692137a5) (offset) the start times for each by setting a value like `stagger: 0.1` (for 0.1 seconds between each start time). Or you can get much more advanced staggers by using a stagger object. For more information, see [the stagger documentation](/resources/getting-started/Staggers.md).

For basic sequencing, you could use a `delay` on each tween (like ``gsap.to(".class", {`delay: 0.5,`¬†duration: 1, x: 100})``), but we **strongly** recommended using a [`Timeline`](/docs/v3/GSAP/Timeline.md) for all but the simplest sequencing tasks because it gives you much greater flexibility, especially when you're experimenting with timing. It allows you to append tweens one-after-the-other and then control the entire sequence as a whole. You can even have the tweens overlap as much as you want, ¬†nest timelines as deeply as you want, and much, much more.

Timelines have convenient [to()](/docs/v3/GSAP/Timeline/to\(\).md), [from()](/docs/v3/GSAP/Timeline/from\(\).md), and [fromTo()](/docs/v3/GSAP/Timeline/fromTo\(\).md) methods as well so you can very easily chain them together and build complex sequences:

If you find yourself animating the same target over and over again, you should definitely check out [Keyframes](/resources/keyframes.md) which can make your code much more concise. They also let you port animations over from CSS animations easily.

[Learn more about keyframes](/resources/keyframes.md)

* You can change the default ease via [`gsap.defaults({ease: ...})`](/docs/v3/GSAP/gsap.defaults\(\).md). The default is `"power1.out"`.
* Kill all tweens of a particular object anytime with [`gsap.killTweensOf(yourObject)`](/docs/v3/GSAP/gsap.killTweensOf\(\).md) You can also use selector text like `gsap.killTweensOf("#someID");`
* You can kill all `delayedCall`s to a particular function with [`gsap.killTweensOf(myFunction)`](/docs/v3/GSAP/gsap.killTweensOf\(\).md)

|                                                                                                                                      |                                                                                                                                                                                                                                  |
| ------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| #### [delay](/docs/v3/GSAP/Tween/delay\(\).md)( value:Number ) : \[Number \| self]                                                   | Gets or sets the animation's initial delay which is the length of time in seconds before the animation should begin.                                                                                                             |
| #### [duration](/docs/v3/GSAP/Tween/duration\(\).md)( value:Number ) : \[Number \| self]                                             | Gets or sets the animation's duration, not including any repeats or repeatDelays.                                                                                                                                                |
| #### [endTime](/docs/v3/GSAP/Tween/endTime\(\).md)( includeRepeats:Boolean ) : Number                                                | Returns the time at which the animation will finish according to the parent timeline's local time.                                                                                                                               |
| #### [eventCallback](/docs/v3/GSAP/Tween/eventCallback\(\).md)( type:String, callback:Function, params:Array ) : \[Function \| self] | Gets or sets an event callback like `"onComplete", "onUpdate", "onStart"` or or `"onRepeat"` along with any parameters that should be passed to that callback.                                                                   |
| #### [globalTime](/docs/v3/GSAP/Tween/globalTime\(\).md)( localTime:Number ) : Number                                                | Converts a local time to the corresponding time on the [gsap.globalTimeline](/docs/v3/GSAP/gsap.globalTimeline.md) (factoring in all nesting, timeScales, etc.).                                                                 |
| #### [invalidate](/docs/v3/GSAP/Tween/invalidate\(\).md)( ) : self                                                                   | \[override] Flushes any internally-recorded starting/ending values which can be useful if you want to restart an animation without reverting to any previously recorded starting values.                                         |
| #### [isActive](/docs/v3/GSAP/Tween/isActive\(\).md)( ) : Boolean                                                                    | Indicates whether or not the animation is currently active (meaning the virtual playhead is actively moving across this instance's time span and it is not paused, nor are any of its ancestor timelines).                       |
| #### [iteration](/docs/v3/GSAP/Tween/iteration\(\).md)( ) : \[Number \| self]                                                        | Gets or sets the iteration (the current repeat) of tweens.                                                                                                                                                                       |
| #### [kill](/docs/v3/GSAP/Tween/kill\(\).md)( target:Object, propertiesList:String ) : self                                          | Kills the animation entirely or in part depending on the parameters. To kill means to immediately stop the animation, remove it from its parent timeline, and release it for garbage collection.                                 |
| #### [pause](/docs/v3/GSAP/Tween/pause\(\).md)( atTime:Number, suppressEvents:Boolean ) : self                                       | Pauses the instance, optionally jumping to a specific time.                                                                                                                                                                      |
| #### [paused](/docs/v3/GSAP/Tween/paused\(\).md)( value:Boolean ) : \[Boolean \| self]                                               | Gets or sets the animation's paused state which indicates whether or not the animation is currently paused.                                                                                                                      |
| #### [play](/docs/v3/GSAP/Tween/play\(\).md)( from:Number, suppressEvents:Boolean ) : self                                           | Begins playing forward, optionally from a specific time (by default playback begins from wherever the playhead currently is).                                                                                                    |
| #### [progress](/docs/v3/GSAP/Tween/progress\(\).md)( value:Number, suppressEvents:Boolean ) : \[Number \| self]                     | \[override] Gets or sets the tween's progress which is a value between 0 and 1 indicating the position of the virtual playhead (excluding repeats) where 0 is at the beginning, 0.5 is halfway complete, and 1 is complete.      |
| #### [repeat](/docs/v3/GSAP/Tween/repeat\(\).md)( value:Number ) : \[Number \| self]                                                 | Gets or sets the number of times that the tween should repeat after its first iteration.                                                                                                                                         |
| #### [repeatDelay](/docs/v3/GSAP/Tween/repeatDelay\(\).md)( value:Number ) : \[Number \| self]                                       | Gets or sets the amount of time in seconds between repeats.                                                                                                                                                                      |
| #### [restart](/docs/v3/GSAP/Tween/restart\(\).md)( includeDelay:Boolean, suppressEvents:Boolean ) : self                            | Restarts and begins playing forward from the beginning.                                                                                                                                                                          |
| #### [resume](/docs/v3/GSAP/Tween/resume\(\).md)( ) : self                                                                           | Resumes playing without altering direction (forward or reversed).                                                                                                                                                                |
| #### [reverse](/docs/v3/GSAP/Tween/reverse\(\).md)( from:\*, suppressEvents:Boolean ) : self                                         | Reverses playback so that all aspects of the animation are oriented backwards including, for example, a tween's ease.                                                                                                            |
| #### [reversed](/docs/v3/GSAP/Tween/reversed\(\).md)( value:Boolean ) : \[Boolean \| self]                                           | Gets or sets the animation's reversed state which indicates whether or not the animation should be played backwards.                                                                                                             |
| #### [revert](/docs/v3/GSAP/Tween/revert\(\).md)( ) : Self                                                                           | Reverts the animation and kills it, returning the targets to their pre-animation state including the removal of inline styles added by the animation.                                                                            |
| #### [seek](/docs/v3/GSAP/Tween/seek\(\).md)( time:\*, suppressEvents:Boolean ) : self                                               | Jumps to a specific time without affecting whether or not the instance is paused or reversed.                                                                                                                                    |
| #### [startTime](/docs/v3/GSAP/Tween/startTime\(\).md)( value:Number ) : \[Number \| self]                                           | Gets or sets the time at which the animation begins on its parent timeline (after any delay that was defined).                                                                                                                   |
| #### [targets](/docs/v3/GSAP/Tween/targets\(\).md)( ) : Array                                                                        |                                                                                                                                                                                                                                  |
| #### [then](/docs/v3/GSAP/Tween/then\(\).md)( callback:Function ) : Promise                                                          | Returns a promise so that you can uses promises to track when a tween or timeline is complete.                                                                                                                                   |
| #### [time](/docs/v3/GSAP/Tween/time\(\).md)( value:Number, suppressEvents:Boolean ) : \[Number \| self]                             | \[override] Gets or sets the local position of the playhead (essentially the current time), not including any repeats or repeatDelays.                                                                                           |
| #### [timeScale](/docs/v3/GSAP/Tween/timeScale\(\).md)( value:Number ) : \[Number \| self]                                           | Factor that's used to scale time in the animation where 1 = normal speed (the default), 0.5 = half speed, 2 = double speed, etc.                                                                                                 |
| #### [totalDuration](/docs/v3/GSAP/Tween/totalDuration\(\).md)( value:Number ) : \[Number \| self]                                   | \[override] Gets or sets the total duration of the tween in seconds including any repeats or repeatDelays.                                                                                                                       |
| #### [totalProgress](/docs/v3/GSAP/Tween/totalProgress\(\).md)( value:Number, suppressEvents:Boolean ) : \[Number \| self]           | \[override] Gets or sets the tween's totalProgress which is a value between 0 and 1 indicating the position of the virtual playhead (including repeats) where 0 is at the beginning, 0.5 is halfway complete, and 1 is complete. |
| #### [totalTime](/docs/v3/GSAP/Tween/totalTime\(\).md)( time:Number, suppressEvents:Boolean ) : \[Number \| self]                    | Gets or sets the position of the playhead according to the totalDuration which includes any repeats and repeatDelays.                                                                                                            |
| #### [yoyo](/docs/v3/GSAP/Tween/yoyo\(\).md)( value:Boolean ) : \[Boolean \| self]                                                   | Gets or sets the tween's yoyo state, where true causes the tween to go back and forth, alternating backward and forward on each repeat.                                                                                          |

|                                                                                                                              |                                                                                                                                                                                                                                                                                                                                       |
| ---------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| #### [data](/docs/v3/GSAP/Tween/data.md) : \*                                                                                | A place to store any data you want (initially populated with `vars.data` if it exists).                                                                                                                                                                                                                                               |
| #### [ratio](/docs/v3/GSAP/Tween/ratio.md)                                                                                   | **\[read-only]** the progress of the Tween (a value between 0 and 1 where 0.5 is in the middle) **after** being run through the `ease`. So this value may exceed the 0-1 range, like in the case of `ease: "back"` or `ease: "elastic"`. It can be useful as a multiplier for your own interpolation, like in an `onUpdate` callback. |
| #### [scrollTrigger](/docs/v3/GSAP/Tween/scrollTrigger.md): [ScrollTrigger](/docs/v3/Plugins/ScrollTrigger/.md) \| undefined | A handy way to access the ScrollTrigger associated with a tween. This is only accessible if the tween has a ScrollTrigger.                                                                                                                                                                                                            |
| #### [vars](/docs/v3/GSAP/Tween/vars.md) : Object                                                                            | The configuration object passed into the constructor which contains all the properties/values you want to animate, along with any of the optional **special properties** like like `onComplete`, `onUpdate`, etc., like `gsap.to(".class",{onComplete: func});`                                                                       |

**Examples:**

Example 1 (unknown):
```unknown
// This is a Tween
gsap.to(".box", { rotation: 27, x: 100, duration: 1 });
```

Example 2 (unknown):
```unknown
//rotate and move elements with a class of "box" ("x" is a shortcut for a translateX() transform) over the course of 1 second.
gsap.to(".box", { rotation: 27, x: 100, duration: 1 });
```

Example 3 (unknown):
```unknown
let tween = gsap.to(".class", { rotation: 360, duration: 5, ease: "elastic" });

//now we can control it!
tween.pause();
tween.seek(2);
tween.progress(0.5);
tween.play();
```

Example 4 (unknown):
```unknown
gsap.to(".class", {
    x: 100, //normal value
    y: function(index, target, targets) { //function-based value
        return index \* 50;
    },
    duration: 1
});
```

---

## startY

**URL:** https://gsap.com/docs/v3/Plugins/Observer/startY.md

**Contents:**
  - startY : Number
  - Details[—Ç–ê–õ](#details "Direct link to Details")

The `clientY` from the most recent `onPress` touch/pointer event, which refers to the vertical distance from the top edge of the viewport. This only gets updated if you set the `type` to include "touch" and/or "pointer". It's quite useful for dragging logic.

The `clientY` from the most recent `onPress` touch/pointer event, which refers to the vertical distance from the top edge of the viewport. This only gets updated if you set the `type` to include "touch" and/or "pointer". It's quite useful for dragging logic.

---

## CustomBounce

**URL:** https://gsap.com/docs/v3/Eases/CustomBounce.md

**Contents:**
    - CDN Link
    - Minimal usage
    - loading...
  - Description[‚Äã](#description "Direct link to Description")
  - Options[‚Äã](#options "Direct link to Options")
  - .getSVGData()[‚Äã](#getsvgdata "Direct link to .getSVGData()")
  - String format[‚Äã](#string-format "Direct link to String format")
  - **Demos**[‚Äã](#demos "Direct link to demos")

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/pRowwX?default-tab=result\&theme-id=41164)

GSAP always has the tried-and-true `"bounce"` ease, but there is no built-in way to customize how "bouncy" it is, nor could you easily get a synchronized squash and stretch effect during the bounce because:

* The "bounce" ease needs to stick to the ground momentarily at the point of the bounce while the squashing occurs. `"bounce"` offers no such customization.
* There was no way to create the corresponding \[synchronized] scaleX/scaleY ease for the squashing/stretching. [CustomEase](/docs/v3/Eases/CustomEase.md) solves this now, but it'd still be very difficult to manually draw that ease with all the points lined up in the right spots to match up with the bounces.

With CustomBounce, you can set a few parameters and it'll create **BOTH** CustomEases for you (one for the bounce, and one \[optionally] for the squash/stretch). Think of CustomBounce like a wrapper that creates a CustomEase under the hood based on the variables you pass in.

CustomBounce extends [CustomEase](/docs/v3/Eases/CustomEase.md) (which you must include in your project) and it lets you set the bounce and (optionally) a squash and stretch.

[YouTube video player](https://www.youtube.com/embed/iO8J_CiH1fk)

Number - A number between 0 and 1 that determines how ‚Äúbouncy‚Äù the ease is, so 0.9 will have a lot more bounces than 0.3. Default: `0.7`.

* #### endAtStart[](#endAtStart)

Boolean - If `true`, the ease will end back where it started, allowing you to get an effect like an object sitting on the ground, leaping into the air, and bouncing back down to a stop. Default: `false`.

* #### squash[](#squash)

Number - Controls how long the squash should last (the gap between bounces, when it appears ‚Äústuck‚Äù). Typically 2 is a good number, but 4 (as an example) would make the squash longer in relation to the rest of the ease. Default: `0`.

* #### squashID[](#squashID)

String - The ID that should be assigned to the squash ease. The default is whatever the ID of the bounce is plus ‚Äú-squash‚Äù appended to the end. For example, `CustomBounce.create("hop", {strength: 0.6, squash: 2})` would default to a squash ease ID of `"hop-squash"`.

How do you get the bounce and the squash and stretch to work together? You'd use two tweens; one for the position (`y`), and the other for the `scaleX` and `scaleY`, with both running at the same time:

CustomBounce also shares CustomEase's method that calculates the SVG `<path>` data string for visualizing any ease graphically at any size that you define, like `{width: 500, height: 400, x: 10, y: 50}`. You can supply a CustomEase or the ID associated with one, or even a standard ease like `Power2.easeOut`. Feed in a `path` in the vars object and it'll populate its `d` attribute for you, like:

You can also use GSAP's condensed string formatting for eases, like:

[CustomBounce demos](https://codepen.io/collection/DqaLzb)

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(CustomEase, CustomBounce)
```

Example 2 (unknown):
```unknown
//Create a custom bounce ease:
CustomBounce.create("myBounce", {
  strength: 0.6,
  squash: 3,
  squashID: "myBounce-squash",
});

//do the bounce by affecting the "y" property.
gsap.from(".class", { duration: 2, y: -200, ease: "myBounce" });

//and do the squash/stretch at the same time:
gsap.to(".class", {
  duration: 2,
  scaleX: 1.4,
  scaleY: 0.6,
  ease: "myBounce-squash",
  transformOrigin: "center bottom",
});
```

Example 3 (unknown):
```unknown
gsap.registerPlugin(CustomEase, CustomBounce); // register

//Create a custom bounce ease:
CustomBounce.create("myBounce", {
  strength: 0.6,
  squash: 3,
  squashID: "myBounce-squash",
});

//do the bounce by affecting the "y" property.
gsap.from(".class", { duration: 2, y: -200, ease: "myBounce" });

//and do the squash/stretch at the same time:
gsap.to(".class", {
  duration: 2,
  scaleX: 1.4,
  scaleY: 0.6,
  ease: "myBounce-squash",
  transformOrigin: "center bottom",
});
```

Example 4 (unknown):
```unknown
//create a CustomEase with an ID of "hop"
CustomBounce.create("myBounce", {
  strength: 0.6,
  squash: 3,
  squashID: "myBounce-squash",
});

//draw the ease visually in the SVG  that has an ID of "ease" at 500px by 400px:
CustomEase.getSVGData("myBounce", { width: 500, height: 400, path: "#ease" });
```

---

## pointerY

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/pointerY.md

**Contents:**
  - pointerY : Number
  - Details[‚Äã](#details "Direct link to Details")

\[read-only] The y (vertical) position of the pointer (mouse or touch) associated with the Draggable's last event (like event.pageY).

*Number* - The `y` (vertical) position of the pointer (mouse or touch) associated with the Draggable's last event (like `event.pageY`). In most cases, this should be used instead of using the event's `.pageY` because GSAP tries to normalize positioning across all browsers.

---

## vars

**URL:** https://gsap.com/docs/v3/GSAP/Tween/vars.md

**Contents:**
  - vars : Object
  - Details[‚Äã](#details "Direct link to Details")

The configuration object passed into the constructor which contains all the properties/values you want to animate, along with any of the optional **special properties** like like `onComplete`, `onUpdate`, etc., like `gsap.to(".class",{onComplete: func});`

The `vars` object passed into the constructor which contains all the properties/values you want to animate, along with any of the optional **special properties** like like `onComplete`, `onUpdate`, etc. (listed below)

The scope to be used for all of the callbacks (onStart, onUpdate, onComplete, etc.).

Assign arbitrary data to this property (a string, a reference to an object, whatever) and it gets attached to the tween instance itself so that you can reference it later like `yourTween.data`.

* #### delay[](#delay)

Amount of delay before the animation should begin (in seconds).

* #### duration[](#duration)

The duration of the animation (in seconds). Default: `0.5`.

Controls the rate of change during the animation, giving it a specific feel. For example, `"elastic"` or `"strong.inOut"`. See the [Ease Visualizer](/docs/v3/Eases.md) for a list of all of the options. `ease` can be a String (most common) or a function that accepts a progress value between 0 and 1 and returns a converted, similarly normalized value. Default: `"power1.out"`.

Allows you to (optionally) assign a unique identifier to your tween instance so that you can find it later with `gsap.getById()` and it will show up in [GSDevTools](/docs/v3/Plugins/GSDevTools.md) with that id.

* #### immediateRender[](#immediateRender)

Normally a tween waits to render for the first time until the very next tick (update cycle) unless you specify a delay. Set `immediateRender: true` to force it to render immediately upon instantiation. Default: `false` for [to()](/docs/v3/GSAP/gsap.to\(\).md) tweens, `true` for [from()](/docs/v3/GSAP/gsap.from\(\).md) and [fromTo()](/docs/v3/GSAP/gsap.fromTo\(\).md) tweens or anything with a [scrollTrigger](/docs/v3/Plugins/ScrollTrigger/.md) applied.

* #### inherit[](#inherit)

Normally tweens inherit from their parent timeline's `defaults` object (if one is defined), but you can disable this on a per-tween basis by setting `inherit: false`.

When a tween renders for the very first time and reads its starting values, GSAP will try to delay writing of values until the very end of the current "tick" which can improve performance because it avoids the read/write/read/write layout thrashing that browsers dislike. To disable lazy rendering for a particular tween, set `lazy: false`. In most cases, there's no need to set `lazy`. To learn more, watch [this video](https://www.youtube.com/watch?v=TMHJptqnDpU). Default: `true` (except for zero-duration tweens).

* #### onComplete[](#onComplete)

A function to call when the animation has completed.

* #### onCompleteParams[](#onCompleteParams)

An Array of parameters to pass the onComplete function. For example, `gsap.to(".class", {x:100, onComplete:myFunction, onCompleteParams:["param1", "param2"]});`.

* #### onRepeat[](#onRepeat)

A function to call each time the animation enters a new iteration cycle (repeats). Obviously this only occurs if you set a non-zero `repeat`.

* #### onRepeatParams[](#onRepeatParams)

An Array of parameters to pass the onRepeat function.

* #### onReverseComplete[](#onReverseComplete)

A function to call when the animation has reached its beginning again from the reverse direction (excluding repeats).

* #### onReverseCompleteParams[](#onReverseCompleteParams)

An Array of parameters to pass the onReverseComplete function.

* #### onStart[](#onStart)

A function to call when the animation begins (when its time changes from 0 to some other value which can happen more than once if the tween is restarted multiple times).

* #### onStartParams[](#onStartParams)

An Array of parameters to pass the onStart function.

* #### onUpdate[](#onUpdate)

A function to call every time the animation updates (on each "tick" that moves its playhead).

* #### onUpdateParams[](#onUpdateParams)

An Array of parameters to pass the onUpdate function.

* #### overwrite[](#overwrite)

If `true`, all tweens of the same targets will be killed immediately regardless of what properties they affect. If `"auto"`, when the tween renders for the first time it hunt down any conflicts in active animations (animating the same properties of the same targets) and kill **only those parts** of the other tweens. Non-conflicting parts remain intact. If `false`, no overwriting strategies will be employed. Default: `false`.

* #### paused[](#paused)

If `true`, the animation will pause itself immediately upon creation. Default: `false`.

* #### repeat[](#repeat)

How many times the animation should repeat. So `repeat: 1` would play a total of two iterations. Default: `0`. `repeat: -1` will repeat infinitely.

* #### repeatDelay[](#repeatDelay)

Amount of time to wait between repeats (in seconds). Default: `0`.

* #### repeatRefresh[](#repeatRefresh)

Setting `repeatRefresh: true` causes a repeating tween to `invalidate()` and re-record its starting/ending values internally on each full iteration (not including yoyo's). This is useful when you use dynamic values (relative, random, or function-based). For example, `x: "random(-100, 100)"` would get a new random x value on each repeat. `duration`, `delay`, and `stagger` do **NOT** refresh.

* #### reversed[](#reversed)

If `true`, the animation will start out with its playhead reversed, meaning it will be oriented to move toward its start. Since the playhead begins at a time of 0 anyway, a reversed tween will *appear* paused initially because its playhead cannot move backward past the start.

* #### runBackwards[](#runBackwards)

If `true`, the animation will invert its starting and ending values (this is what a [from()](/docs/v3/GSAP/gsap.from\(\).md) tween does internally), though the ease doesn't get flipped. In other words, you can make a `to()` tween into a `from()` by setting `runBackwards: true`.

* #### stagger[](#stagger)

If multiple targets are defined, you can easily [stagger](https://codepen.io/GreenSock/pen/938f5cd34818443c43af9ba2692137a5) the start times for each by setting a value like `stagger: 0.1` (for 0.1 seconds between each start time). Or you can get much more advanced staggers by using a stagger object. For more information, see [the stagger documentation](/resources/getting-started/Staggers.md).

* #### startAt[](#startAt)

Defines starting values for any properties (even if they're not animating). For example, `startAt: {x: -100, opacity: 0}`

If `true`, every other `repeat` iteration will run in the opposite direction so that the tween appears to go back and forth. This has no affect on the `reversed` property though. So if `repeat` is `2` and `yoyo` is `false`, it will look like: start - 1 - 2 - 3 - 1 - 2 - 3 - 1 - 2 - 3 - end. But if `yoyo` is `true`, it will look like: start - 1 - 2 - 3 - 3 - 2 - 1 - 1 - 2 - 3 - end. Default: `false`.

* #### yoyoEase[](#yoyoEase)

Allows you to alter the ease in the tween's `yoyo` phase. Set it to a specific ease like `"power2.in"` or set it to `true` to simply invert the tween's normal `ease`. Note: GSAP is smart enough to automatically set `yoyo: true` if you define any `yoyoEase`, so there's less code for you to write. Default: `false`.

* #### keyframes[](#keyframes)

To animate the targets to various states, use `keyframes` - an array of vars objects that serve as `to()` tweens. For example, `keyframes: [{x:100, duration:1}, {y:100, duration:0.5}]`. All keyframes will be perfectly sequenced back-to-back, but you can define a `delay` value to add spacing between each step (or a negative delay would create an overlap). Keyframes are only to be used in `to()` tweens.

---

## isSplit

**URL:** https://gsap.com/docs/v3/Plugins/SplitText/isSplit.md

**Contents:**
  - isSplit : Boolean
  - Details[‚Äö√Ñ√£](#details "Direct link to Details")

Whether the text is currently split.

A boolean that indicates whether the element is currently split. When `true`, the SplitText instance has performed a split and (depending on which types you split by) the `.chars`, `.words`, `.lines`, or `.masks` arrays will be populated. Use `.revert()` to undo the split and reset `isSplit` to `false`.

---

## pointerX

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/pointerX.md

**Contents:**
  - pointerX : Number
  - Details[‚Äã](#details "Direct link to Details")

\[read-only] The x (horizontal) position of the pointer (mouse or touch) associated with the Draggable's last event (like event.pageX).

*Number* - The `x` (horizontal) position of the pointer (mouse or touch) associated with the Draggable's last event (like `event.pageX`). In most cases, this should be used instead of using the event's `.pageX` because GSAP tries to normalize positioning across all browsers.

---

## SlowMo

**URL:** https://gsap.com/docs/v3/Eases/SlowMo.md

**Contents:**
    - CDN Link
    - Minimal usage
  - Description[‚Äã](#description "Direct link to Description")
  - Example code[‚Äã](#example-code "Direct link to Example code")

Not included in the Core

This ease is in the EasePack file. To learn how to include this in your project, see [the Installation page](/docs/v3/Installation).

SlowMo is a configurable ease that produces a slow-motion effect that decelerates initially, then moves linearly for a certain portion of the ease (which you can choose) and then accelerates again at the end; it's great for effects like zooming text onto the screen, smoothly moving it long enough for people to read it, and then zooming it off the screen.

Without SlowMo, animators would often try to get the same effect by sequencing 3 tweens, one with an ease `.out`, then another with no ease (`ease: "none"`), and finally an ease `.in`. But the problem was that the eases didn't smoothly transition into one another so you'd see sudden shifts in velocity at the joints. SlowMo solves this problem and gives you complete control over how strong the eases are on each end and what portion of the movement in the middle is linear.

The first parameter, `linearRatio`, determines the proportion of the ease during which the rate of change will be linear (steady pace). This should be a number between 0 and 1. For example, 0.5 would be half, so the first 25% of the ease would be easing out (decelerating), then 50% would be linear, then the final 25% would be easing in (accelerating). If you choose 0.8, that would mean 80% of the ease would be linear, leaving 10% on each end to ease. The default is 0.7.

The second parameter, `power`, determines the strength of the ease at each end. If you define a value greater than 1, it will actually reverse the linear portion in the middle which can create interesting effects. The default is 0.7.

The third parameter, `yoyoMode`, provides an easy way to create companion tweens that sync with normal SlowMo tweens. For example, let's say you have a SlowMo tween that is zooming some text onto the screen and moving it linearly for a while and then zooming off, but you want to tween that alpha of the text at the beginning and end of the positional tween. Normally, you'd need to create 2 separate alpha tweens, 1 for the fade-in at the beginning and 1 for the fade-out at the end and you'd need to calculate their durations manually to ensure that they finish fading in by the time the linear motion begins and then they start fading out at the end right when the linear motion completes. But to make this whole process much easier, all you'd need to do is create a separate tween for the alpha and use the same duration but a SlowMo ease that has its `yoyoMode` parameter set to `true`.

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(EasePack)
```

Example 2 (unknown):
```unknown
// we're starting at a scale of 1 and animating to 2, so pass those into config()...
gsap.to("#image", { duration: 1, scale: 2, ease: "expoScale(1, 2)" });
```

Example 3 (unknown):
```unknown
//use the default SlowMo ease (linearRatio of 0.7 and power of 0.7)
gsap.to(myText, {duration: 5, x: 600, ease: "slow"});

//this gives the exact same effect as the line above, but uses a different syntax
gsap.to(myText, {duration: 5, x: 600, ease: "slow(0.5, 0.8)"});

//now let's create an opacity tween that syncs with the above positional tween, fading it in at the beginning and out at the end
gsap.from(myText, {duration: 5, opacity: 0, ease: "slow(0.5, 0.8, true)"});
```

---

## Attributes

**URL:** https://gsap.com/docs/v3/GSAP/CorePlugins/Attributes.md

**Contents:**
  - Description[‚Äã](#description "Direct link to Description")

What are internal plugins?

GSAP animates attributes using an internal plugin, AttrPlugin is **automatically included in GSAP's core** and **doesn't have to be loaded using gsap.registerPlugin()**. You can think of internal plugins as just a part of GSAP.

GSAP allows you to easily tween any numeric attribute of a DOM element. For example, let's say your DOM element looks like this:

You could tween the "x", "y", "width", or "height" attributes like this:

You can tween an unlimited number of attributes simultaneously. Just use the associated property name inside the `attr:{}` object. GSAP will retain suffixes like "%" meaning you can tween values like `<rect width="50%"...>`.<br />**Caveat: you cannot do unit conversion with attributes (like px to %)**

Do not attempt to animate CSS-related properties inside the attr object. GSAP handles [CSS](/docs/v3/GSAP/CorePlugins/CSS.md) differently internally. In the example above, the `x` outside the `attr:{}` object will animate the CSS transform, whereas the x inside the attr object will animate the underlying geometry - the x coordinate of the rect element.

**Examples:**

Example 1 (unknown):
```unknown
<rect id="rect" fill="none" x="0" y="0" width="500" height="400"></rect>
```

Example 2 (unknown):
```unknown
gsap.to("#rect", {
  duration: 1,
  // x here refers to the x attribute
  attr: { x: 100, y: 50, width: 100, height: 100 },
  ease: "none",
  x: 200 // animate translateX() transform
});
```

---

## MorphSVGPlugin.defaultUpdateTarget

**URL:** https://gsap.com/docs/v3/Plugins/MorphSVGPlugin/static.defaultUpdateTarget.md

**Contents:**
  - MorphSVGPlugin.defaultUpdateTarget : Boolean
  - Details[‚Äã](#details "Direct link to Details")

Sets the default `updateTarget` value for all MorphSVG animations; if `true`, the original tween target (typically an SVG `<path>` element) itself gets updated during the tween.

Sets the default `updateTarget` value for all MorphSVG animations; if `true`, the original tween target (typically an SVG `<path>` element) itself gets updated during the tween. If you've got a render function set up to draw to `<canvas>`, for example, then it may be wasteful to update the original target as well (duplicate efforts). Ultimately this is a performance optimization. Setting it to `false` allows MorphSVG to skip that step.

---

## scrollTrigger

**URL:** https://gsap.com/docs/v3/GSAP/Tween/scrollTrigger.md

**Contents:**
  - scrollTrigger: [ScrollTrigger](/docs/v3/Plugins/ScrollTrigger/.md) | undefined
  - Details[‚Äã](#details "Direct link to Details")

A handy way to access the ScrollTrigger associated with a tween. This is only accessible if the tween has a ScrollTrigger.

A "scrollTrigger" property is **only** added to the Timeline or Tween **if** it has a ScrollTrigger.

See the [ScrollTrigger](/docs/v3/Plugins/ScrollTrigger/.md) docs for more details

**Examples:**

Example 1 (unknown):
```unknown
// add a ScrollTrigger to a Timeline
let tl = gsap.to("#id" {scrollTrigger: {start: "top center"...}});

// access the ScrollTrigger to call various methods
tl.scrollTrigger.refresh();
// or
tl.scrollTrigger.kill();
```

---

## vars

**URL:** https://gsap.com/docs/v3/Plugins/Observer/vars.md

**Contents:**
  - vars : Object
  - Details[‚Äã](#details "Direct link to Details")

The configuration object that was originally passed in to the Observer.create().

The configuration object that was originally passed in to the Observer.create().

---

## deltaY

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/deltaY.md

**Contents:**
  - deltaY : Number
  - Details[√î√á√Ø](#details "Direct link to Details")

The change in the y-related value since the last drag event.

*Number* - The change in the y-related value since the last drag event. The y-related value is typically `y` (`translateY`) or `top`.

---

## Weighted eases

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/addWeightedEases.md

Here's a useful function that'll let you feed in a ratio between -1 and 1 to any of the standard (non-configurable) eases to make them "weighted" in one direction or the other, as if it's pulling the ease curve toward the start or the end. A ratio of "0" won't be weighted either way, -1 would be weighted toward the "in" portion of the ease, and 1 is weighted toward the "out" portion.

After you run that function once, you can basically configure any of the standard eases like `power2.inOut` or `power1.in` (or whatever) by adding parenthesis with a number indicating how you'd like to weight the ease in one direction or the other. And again, it works with any standard ease that doesn't already have a configuration option (like "steps()", "slow()", etc.)

**Examples:**

Example 1 (unknown):
```unknown
function addWeightedEases() {
  let eases = gsap.parseEase(),
    createConfig = (ease) => (ratio) => {
      let y = 0.5 + ratio / 2;
      return (p) => ease(2 * (1 - p) * p * y + p * p);
    };
  for (let p in eases) {
    if (!eases[p].config) {
      eases[p].config = createConfig(eases[p]);
    }
  }
}

//example usage:
ease: "power2.inOut(0.5)"; // weighted halfway to the "out" portion
ease: "power2.inOut(-0.2)"; // weighted slightly to the "in" portion
ease: "power2.inOut(-1)"; // weighted ALL THE WAY to the "in" portion
ease: "power2.inOut(1)"; // weighted ALL THE WAY to the "out" portion
```

---

## Text

**URL:** https://gsap.com/docs/v3/Plugins/TextPlugin.md

**Contents:**
    - CDN Link
    - Minimal usage
- **Config Object**[‚Äã](#config-object "Direct link to config-object")
- **Demos**[‚Äã](#demos "Direct link to demos")

Replaces the text content of a DOM element one character at a time (or one word at a time if you set `delimiter: " "`). So when the tween is finished, the DOM element's text has been completely replaced. This also means that if you rewind or restart the tween, the text will be reverted.

Here is a simple example of replacing the text in yourElement:

For advanced usage, set `text` to an object (like `text:{...}`) with any of the following properties:

The character that should be used to split the text up. The default is `""`, so each character is isolated but if you'd prefer to animate in word-by-word instead you can use the space character, like

* #### newClass[](#newClass)

A CSS class that should be applied to the new text via a ``tag. This makes it easy to have the new text differentiated visually from the old text, like maybe it should be red or bold or something - just create a class in your CSS and pass the name in here like

* #### oldClass[](#oldClass)

A CSS class that should be applied to the old text via a ``tag.

* #### padSpace[](#padSpace)

If the new text is shorter than the old text, it can be useful to pad the trailing space with non-breaking space HTML characters so that the old text doesn't collapse. If that's the effect you want, set `padSpace: true` inside the text object.

* #### preserveSpaces[](#preserveSpaces)

If `true`, it will force TextPlugin to maintain extra spaces, swapping in ``to make them show up in HTML.

if `true`, the text will be introduced from right-to-left (reverse order). See a [demo here](https://codepen.io/GreenSock/pen/wvrpPqv?editors=0010)

* #### speed[](#speed)

Automatically adjust the **duration** of the tween according to how many changes there are in the text; a value of `1` is relatively slow, and a value of `20` is very fast. Without this feature, you'd need to specify a duration for the tween and it might be difficult to guess what looks good (animating 10 characters over 2 seconds looks VERY different than animating 500 in the same amount of time). In other words, `speed` lets you think more in terms of "changes per unit of time". Technically the formula is "0.05 / speed \* text\_changes".

If you'd like to only animate the differences in the text (skipping all of the character positions that are identical between the start and end strings), set `type: "diff"` (new in GSAP 3.0.4). If, for example, the first 50 characters are the same it might look like the animation is delayed because it's going character-by-character from the start, so `type: "diff"` solves that by skipping all the identical parts.

* #### value[](#value)

The replacement text string, like `"This is the new text"` (**REQUIRED**)

Use the object syntax for special properties

If you use any of the special properties above, make sure you put them **inside their own object**, not inside the main vars object, like this:

TextPlugin will recognize simple HTML nodes like `<br>` and honor them (new in GSAP 3.0.4).

Check out the full collection of [text animation demos](https://codepen.io/collection/ExBwoK) on CodePen.

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(TextPlugin)
```

Example 2 (unknown):
```unknown
//replaces yourElement's text with "This is the new text" 
gsap.to(yourElement, {
  duration: 2,
  text: "This is the new text",
  ease: "none",
});
```

Example 3 (unknown):
```unknown
//replaces yourElement's text with "This is the new text" over the course of 2 seconds
gsap.to(yourElement, {
  duration: 2,
  text: "This is the new text",
  ease: "none",
});
```

Example 4 (unknown):
```unknown
//replaces word-by-word because the delimiter is " " (a space) gsap.to("#element", {     duration: 2,     text: {         value: "This is the new text",         delimiter: " "     },     ease: "none" });
```

---

## Stop overscroll behavior, even on iOS Safari

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/stopOverscroll.md

**Contents:**
- Usage[‚Äã](#usage "Direct link to Usage")

It should be as simple as setting `overscroll-behavior: none` in your CSS, but iOS Safari won't cooperate! So here's a function that'll help stop the overscroll behavior:

**Examples:**

Example 1 (unknown):
```unknown
function stopOverscroll(element) {
  element = gsap.utils.toArray(element)[0] || window;
  (element === document.body || element === document.documentElement) &&
    (element = window);
  let lastScroll = 0,
    lastTouch,
    forcing,
    forward = true,
    isRoot = element === window,
    scroller = isRoot ? document.scrollingElement : element,
    ua = window.navigator.userAgent + "",
    getMax = isRoot
      ? () => scroller.scrollHeight - window.innerHeight
      : () => scroller.scrollHeight - scroller.clientHeight,
    addListener = (type, func) =>
      element.addEventListener(type, func, { passive: false }),
    revert = () => {
      scroller.style.overflowY = "auto";
      forcing = false;
    },
    kill = () => {
      forcing = true;
      scroller.style.overflowY = "hidden";
      !forward && scroller.scrollTop < 1
        ? (scroller.scrollTop = 1)
        : (scroller.scrollTop = getMax() - 1);
      setTimeout(revert, 1);
    },
    handleTouch = (e) => {
      let evt = e.changedTouches ? e.changedTouches[0] : e,
        forward = evt.pageY <= lastTouch;
      if (
        ((!forward && scroller.scrollTop <= 1) ||
          (forward && scroller.scrollTop >= getMax() - 1)) &&
        e.type === "touchmove"
      ) {
        e.preventDefault();
      } else {
        lastTouch = evt.pageY;
      }
    },
    handleScroll = (e) => {
      if (!forcing) {
        let scrollTop = scroller.scrollTop;
        forward = scrollTop > lastScroll;
        if (
          (!forward && scrollTop < 1) ||
          (forward && scrollTop >= getMax() - 1)
        ) {
          e.preventDefault();
          kill();
        }
        lastScroll = scrollTop;
      }
    };
  if ("ontouchend" in document && !!ua.match(/Version\/[\d\.]+.*Safari/)) {
    addListener("scroll", handleScroll);
    addListener("touchstart", handleTouch);
    addListener("touchmove", handleTouch);
  }
  scroller.style.overscrollBehavior = "none";
}
```

Example 2 (unknown):
```unknown
stopOverscroll();

// or specify an element
stopOverscroll("#viewport");
```

---

## lockedAxis

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/lockedAxis.md

**Contents:**
  - lockedAxis : String
  - Returns : String[‚Äã](#returns--string "Direct link to Returns : String")
  - Details[‚Äã](#details "Direct link to Details")

The axis along which movement is locked during that particular drag.

*Boolean* - The axis along which movement is locked (either `"x"` or `"y"`). For example, if `lockAxis` is `true` on a Draggable of `type: "x,y"`, and the user starts dragging horizontally, `lockedAxis` would be `"y"` because vertical movement won't be allowed during that drag. The `lockedAxis` property isn't set immediately upon press - the Draggable must wait to see which direction the user drags first. You can define a `onLockAxis` callback if you'd like to be notified when the axis gets locked.

`lockedAxis` is also populated on touch-enabled devices when you have a Draggable whose type only permits it to drag along one axis (like `type: "x"`, `type: "y"`, `type: "left"`, or `type: "top"`) and the user touch-drags and the Draggable determines the direction, either allowing native touch-scrolling or Draggable-induced dragging.

**Examples:**

Example 1 (unknown):
```unknown
Draggable.create("#yourID", {
  type: "x,y",
  lockAxis: true,
  onLockAxis: function () {
    console.log("locked axis: " + this.lockedAxis);
  },
});
```

---

## isPressed

**URL:** https://gsap.com/docs/v3/Plugins/Observer/isPressed.md

**Contents:**
  - isPressed : Boolean
  - Details[‚Äö√Ñ√£](#details "Direct link to Details")

Set to `true` while the user presses on the target (only applies to `type` of "pointer" and "touch")

Set to `true` while the user presses on the target (only applies to `type` of "pointer" and "touch")

---

## .animation

**URL:** https://gsap.com/docs/v3/Plugins/ScrollTrigger/animation.md

**Contents:**
  - .animation : Tween | Timeline | undefined
  - Returns : Tween | Timeline | undefined[‚Äã](#returns--tween--timeline--undefined "Direct link to Returns : Tween | Timeline | undefined")
  - Details[‚Äã](#details "Direct link to Details")
- Embedded example[‚Äã](#embedded-example "Direct link to Embedded example")
- Standalone example[‚Äã](#standalone-example "Direct link to Standalone example")

\[read-only] The [Tween](/docs/v3/GSAP/Tween.md) or [Timeline](/docs/v3/GSAP/Timeline.md) associated with the ScrollTrigger instance (if any).

The Tween or Timeline associated with the ScrollTrigger (if any)

\[read-only] The [Tween](/docs/v3/GSAP/Tween.md) or [Timeline](/docs/v3/GSAP/Timeline.md) associated with the ScrollTrigger instance (if any). ScrollTriggers don't have to have any animation associated with them, of course, in which case `animation` will be undefined.

**Examples:**

Example 1 (unknown):
```unknown
let tween = gsap.to(".class", {
  x: 100,
  id: "example",
  scrollTrigger: ".trigger",
});

console.log(ScrollTrigger.getById("example").animation); // tween
```

Example 2 (unknown):
```unknown
let tween = gsap.to(".class", { x: 100 }),
  st = ScrollTrigger.create({
    trigger: ".trigger",
    start: "top center",
    end: "+=500",
    animation: tween,
  });

console.log(st.animation); // tween
```

---

## Estimate where an ease will hit a certain value

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/easeToLinear.md

An ease accepts a normalized progress value (0-1) and returns the corresponding eased value, but what if you want to know when that eased value will hit a specific ratio like 0.7? For example, a `"power2.out"` ease may hit 0.7 when the linear progress is only around 0.33. This function lets you feed in that 0.7 and get the linear progress value (0.33 in this example):

More practical use: let's say you're animating a value from 100 to 500 with a `"power2.out"` ease and you want to estimate the linear progress value (between 0 and 1) where it'll hit 250 according to that ease - you could leverage this function like:

**Examples:**

Example 1 (unknown):
```unknown
function easeToLinear(ease, ratio, precision = 0.0001) {
  ease = gsap.parseEase(ease);
  let t = 0,
    dif = ratio - ease(t),
    inc = dif / 2,
    newDif;
  while (Math.abs(dif) > precision) {
    newDif = ratio - ease((t += inc));
    newDif < 0 !== inc < 0 && (inc *= Math.max(-0.5, newDif / dif));
    dif = newDif;
  }
  return t + ((ratio - ease(t + inc)) / dif) * -inc;
}
```

Example 2 (unknown):
```unknown
let from = 100,
  to = 500,
  targetValue = 250,
  progress = easeToLinear(
    "power2",
    (targetValue - from) / (to - from),
    0.00001
  );
```

---

## gsap.globalTimeline

**URL:** https://gsap.com/docs/v3/GSAP/gsap.globalTimeline.md

**Contents:**
  - Type : [Timeline](/docs/v3/GSAP/Timeline.md)[‚Äã](#type--timeline "Direct link to type--timeline")
- Useful Methods[‚Äã](#useful-methods "Direct link to Useful Methods")

`gsap.globalTimeline` is the root Timeline instance that drives everything in GSAP, making it a powerful way to affect all animations at once. Keep in mind, however, that [gsap.delayedCalls()](/docs/v3/GSAP/gsap.delayedCall\(\).md) are also technically tweens, so if you [pause()](/docs/v3/GSAP/Timeline/pause\(\).md) or [timeScale()](/docs/v3/GSAP/Timeline/timeScale\(\).md) the globalTimeline, it will affect delayedCalls() too. If you want to omit those, check out [gsap.exportRoot()](/docs/v3/GSAP/gsap.exportRoot\(\).md).

* `gsap.globalTimeline`[`.pause()`](/docs/v3/GSAP/Timeline/pause\(\).md) - Pauses the global timeline which affects **ALL** animations. Returns itself.

* `gsap.globalTimeline`[`.play()`](/docs/v3/GSAP/Timeline/play\(\).md) - Resumes the global timeline which affects **ALL** animations. Returns itself.

* `gsap.globalTimeline`[`.paused()`](/docs/v3/GSAP/Timeline/paused\(\).md) - Returns `true` if the global timeline is paused. Returns `false` if the global timeline is playing.

* `gsap.globalTimeline`[`.timeScale()`](/docs/v3/GSAP/Timeline/timeScale\(\).md) - Gets or sets the global time scale which is a multiplier that affects **ALL** animations. This doesn't actually set the `timeScale()` of each individual tween/timeline, but rather it affects the rate at which the root timeline plays (that timeline contains all other animations). This is a great way to globally speed up or slow down all animations at once. For example:

Keep in mind that since the global timeline is used to run all other tweens and timelines, `gsap.globalTimeline.isActive()` will always return `true` regardless of whether or not there are any tweens or timelines currently active.

**Examples:**

Example 1 (unknown):
```unknown
gsap.globalTimeline.timeScale(0.5); //plays at half-speed
gsap.globalTimeline.timeScale(2); //plays twice the normal speed
var currentTimeScale = gsap.globalTimeline.timeScale(); //returns the current global timeScale
```

---

## minRotation

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/minRotation.md

**Contents:**
  - minRotation : Number
  - Details[‚Äö√Ñƒç](#details "Direct link to Details")

When bounds are applied, `minRotation` refers to the minimum "legal" rotation property.

*Number* - \[only applies to `type: "rotation"`] When bounds are applied, `minRotation` refers to the minimum "legal" rotation. This makes it easier to run your own custom logic inside the `snap`, `liveSnap`, or callback function(s) if you so choose.

---

## deltaY

**URL:** https://gsap.com/docs/v3/Plugins/Observer/deltaY.md

**Contents:**
  - deltaY : Number
  - Details[‚Äã](#details "Direct link to Details")

The amount of change (in pixels) vertically since the last time a callback was fired on that axis. For example, `onChangeY` or `onDown`

The amount of change (in pixels) vertically since the last time a callback was fired on that axis. For example, `onChangeY` or `onDown`

This is only affected by the event types that the Observer is watching. So, for example, `type: "wheel,touch"` would track the delta based on wheel and touch events (not pointer or scroll). By default, touch and pointer events are only tracked **while pressing/dragging** but if you define an `onMove` (which is mapped to "pointermove"/"mousemove" events), it'll be tracked during any movement while hovering over the target.

---

## Easing

**URL:** https://gsap.com/docs/v3/Eases.md

**Contents:**
- Ease Visualizer
    - [Core](https://gsap.com/core/)
    - Ease pack
    - [Extra Eases](https://gsap.com/pricing/)
- How to use the Ease Visualizer[‚Äã](#how-to-use-the-ease-visualizer "Direct link to How to use the Ease Visualizer")

["slow"](/docs/v3/Eases/SlowMo.md), ["rough"](/docs/v3/Eases/RoughEase.md), and ["expoScale"](/docs/v3/Eases/ExpoScaleEase.md) eases are not in the core - they are packaged together in an **EasePack** file in order to minimize file size. ["CustomEase"](/docs/v3/Eases/CustomEase.md), ["CustomBounce"](/docs/v3/Eases/CustomBounce.md), and ["CustomWiggle"](/docs/v3/Eases/CustomWiggle.md) are packaged independently as well (not in the core).

See the [installation page](/docs/v3/Installation) for details.

**Easing is the primary way to change the timing of your tweens.** Simply changing the ease can adjust the entire feel and personality of your animation. There are infinite eases that you can use in GSAP so we created the visualizer below to help you choose exactly the type of easing that you need.

* Add point: ALT-CLICK on line
* Toggle smooth/corner: ALT-CLICK anchor
* Get handle from corner anchor: ALT-DRAG
* Toggle select: SHIFT-CLICK anchor
* Delete anchor: press DELETE key
* Undo: CTRL-Z

// click to modify the underlined values

ease: "Cubic/power2 (power2).out",none",(

template:none/linear (none).outnone,

(0.7,0.7,\[ ])",(scale from 0.5 to 7 (0.5,7),none)",(12)",(1,0.3)",(1.7)",create("custom", ""0""),create("myWiggle",

squashID: "myBounce-squash"

Coding tip - Default Easing

GSAP uses a default ease of `"power1.out"`. You can overwrite this in any tween by setting the `ease` property of that tween to another (valid) ease value. You can set a different default ease for GSAP by using [gsap.defaults()](/docs/v3/GSAP/gsap.defaults\(\).md). You can also set defaults for particular [timelines](/docs/v3/GSAP/Timeline.md).

To use the ease visualizer, simply click on the ease name that you'd like to use. You can also click on the underlined text to change the values and type of ease.<br /><!-- -->Use the navigation links in the menu to the left for more information about complex eases.

Huge thanks to Carl for providing this video. We highly recommend their extensive GSAP training at [CreativeCodingClub.com](https://www.creativecodingclub.com/bundles/creative-coding-club?ref=44f484). Enroll today in their [Free GSAP course](https://www.creativecodingclub.com/courses/FreeGSAP3Express?ref=44f484) and discover the joy of animating with code.

**Examples:**

Example 1 (unknown):
```unknown
gsap.defaults({
  ease: "power2.in",
  duration: 1,
});

gsap.timeline({defaults: {ease: "power2.in"}})
```

---

## .scrollTrigger

**URL:** https://gsap.com/docs/v3/Plugins/ScrollSmoother/scrollTrigger.md

**Contents:**
  - .scrollTrigger : ScrollTrigger
  - Details[‚Äã](#details "Direct link to Details")

The ScrollTrigger instance that ScrollSmoother created internally to manage the smooth scrolling effect of the page.

The [ScrollTrigger](/docs/v3/Plugins/ScrollTrigger/.md) instance that ScrollSmoother created internally to manage the smooth scrolling effect of the page.

**Examples:**

Example 1 (unknown):
```unknown
let smoother = ScrollSmoother.create({...});

let nativeScrollVelocity = smoother.scrollTrigger.getVelocity();
```

---

## CSSRule

**URL:** https://gsap.com/docs/v3/Plugins/CSSRulePlugin.md

**Contents:**
    - loading...
- **Methods**[‚Äã](#methods "Direct link to methods")

CSSRulePlugin has been **deprecated** in favor of using CSS variables which have [excellent browser support](https://caniuse.com/#feat=css-variables) these days. GSAP has native support for animating CSS variables, like:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/MoeLdj?default-tab=result\&theme-id=41164)

Be aware that animating a CSS variable, no matter the property targeted, will trigger a repaint, so use sparingly and be cautious of performance.

Allows GSAP to animate a raw style sheet rule which affects all objects of a particular selector rather than affecting an individual DOM element's inline styles.

For example, if you have a CSS class named `myClass` that sets `background-color` to `#FF0000`, you could tween that to a different color and *all* of the objects on the page that have a class of `myClass` would have their background color change. Typically it is best to use the regular CSSPlugin to animate CSS-related properties of individual elements so that you can get very precise control over each object, but sometimes it can be useful to animate the global rules themselves instead. For example, pseudo elements like `::after` and `::before` are impossible to reference directly in JavaScript, but you can animate them using CSSRulePlugin.

The plugin itself has a static `getRule()` method that you can use to grab a reference to the style sheet itself based on the CSS selector.

For example, let's say you have CSS like this:

If you want to tween the color of the `.myClass:before` to blue. Make sure you load the CSSRulePlugin file and then do this:

And if you want to get *all* of the `::before` pseudo elements, the `getRule()` will return an array of them, so I could do this:

Keep in mind that it is typically best to tween a property that has already been defined in the specific rule that you're selecting because it cannot perform a calculated style (the combination of styles from other selectors that might pertain to similar elements). For example, if we didn't define any color initially for the `.myClass::before` and tried to tween its color to blue, it would start from `transparent` and go to `blue`. One way around this is to simply set your starting values explicitly in the tween by doing a `fromTo()`. That way there's no having to guess what the starting value should be when it isn't defined previously.

**Don't forget to wrap the values in a `cssRule: {}` object.**

Styles defined inside media queries may not be accessible or tweenable.

Alternatively, convert your pseudo-elements to real HTML elements and animate them directly like you would any other DOM elements.

|                                                                                                                        |                                                                                                                                      |
| ---------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| #### [CSSRulePlugin.getRule](/docs/v3/Plugins/CSSRulePlugin/methods/static-getRule\(\).md)( selector:String ) : Object | \[static] Provides a simple way to find the style sheet object associated with a particular selector like `".myClass"` or `"#myID"`. |

**Examples:**

Example 1 (unknown):
```unknown
gsap.to("html", { "--my-variable": 100, duration: 2 });
```

Example 2 (unknown):
```unknown
.myClass {
    color: #FF0000;
}
.myClass::before {
    content: "This content is before.";
    color: #00FF00;
}
```

Example 3 (unknown):
```unknown
var rule = CSSRulePlugin.getRule(".myClass::before"); //get the rule
gsap.to(rule, { duration: 3, cssRule: { color: "blue" } });
```

Example 4 (unknown):
```unknown
gsap.to( CSSRulePlugin.getRule("::before"), {duration: 3, cssRule: {color: "blue"}});>
```

---

## vars

**URL:** https://gsap.com/docs/v3/GSAP/Timeline/vars.md

**Contents:**
  - vars : Object
  - Details[‚Äã](#details "Direct link to Details")

The configuration object passed into the original timeline via the constructor, like `gsap.timeline({onComplete: func});`

The `vars` object passed into the constructor which contains all the properties/values you want a timeline to have.

Boolean If `autoRemoveChildren` is set to `true`, as soon as child tweens/timelines complete, they will automatically get killed/removed. This is normally undesireable because it prevents going backwards in time (like if you want to `reverse()` or set the progress lower, etc.). It can, however, improve speed and memory management. The root timelines use `autoRemoveChildren: true`.

* #### callbackScope[](#callbackScope)

Object The scope to be used for all of the callbacks (`onStart`, `onUpdate`, `onComplete`, etc.). The scope is what `this` refers to inside any of the callbacks.

* #### defaults[](#defaults)

Object A simple way to set defaults that get inherited by the child animations. See the "[defaults](https://gsap.com/docs/v3/GSAP/Timeline#setting-defaults)" section for details.

* #### delay[](#delay)

Number Amount of delay in seconds before the animation should begin.

* #### onComplete[](#onComplete)

Function A function that should be called when the animation has completed.

* #### onCompleteParams[](#onCompleteParams)

Array An array of parameters to pass the `onComplete` function. For example, `gsap.timeline({onComplete: myFunction, onCompleteParams: ["param1", "param2"]});`.

* #### onInterrupt[](#onInterrupt)

A function to call when the animation is interrupted min animation. Note that this does not fire if the animation completes normally.

* #### onInterruptParams[](#onInterruptParams)

An Array of parameters to pass the onInterrupt function. For example, `gsap.to(".class", {x:100, onInterrupt:myFunction, onInterruptParams:["param1", "param2"]});`.

* #### onRepeat[](#onRepeat)

Function A function that should be called each time the animation repeats.

* #### onRepeatParams[](#onRepeatParams)

Array An Array of parameters to pass the `onRepeat` function. For example, `gsap.timeline({onRepeat: myFunction, onRepeatParams: ["param1", "param2"]});`.

* #### onReverseComplete[](#onReverseComplete)

Function A function that should be called when the animation has reached its beginning again from the reverse direction. For example, if `reverse()` is called the tween will move back towards its beginning and when its `time` reaches `0`, `onReverseComplete` will be called. This can also happen if the animation is placed in a timeline instance that gets reversed and plays the animation backwards to (or past) the beginning.

* #### onReverseCompleteParams[](#onReverseCompleteParams)

Array An array of parameters to pass the `onReverseComplete` function. For example, `gsap.timeline({onReverseComplete: myFunction, onReverseCompleteParams: ["param1", "param2"]});`.

* #### onStart[](#onStart)

Function A function that should be called when the animation begins (when its `time` changes from `0` to some other value which can happen more than once if the tween is restarted multiple times).

* #### onStartParams[](#onStartParams)

Array An array of parameters to pass the `onStart` function. For example, `gsap.timeline({onStart: myFunction, onStartParams: ["param1", "param2"]});`.

* #### onUpdate[](#onUpdate)

Function A function that should be called every time the animation updates (on every frame while the animation is active).

* #### onUpdateParams[](#onUpdateParams)

Array An array of parameters to pass the `onUpdate` function. For example, `gsap.timeline({onUpdate: myFunction, onUpdateParams: ["param1", "param2"]});`.

* #### paused[](#paused)

Boolean If `true`, the animation will pause itself immediately upon creation.

* #### repeat[](#repeat)

Number Number of times that the animation should repeat after its first iteration. For example, if `repeat` is `1`, the animation will play a total of twice (the initial play plus 1 repeat). To repeat indefinitely, use `-1`. `repeat` should always be an integer.

* #### repeatDelay[](#repeatDelay)

Number Amount of time in seconds between repeats. For example, if `repeat` is `2` and `repeatDelay` is `1`, the animation will play initially, then wait for 1 second before it repeats, then play again, then wait 1 second again before doing its final repeat.

* #### repeatRefresh[](#repeatRefresh)

Setting `repeatRefresh: true` causes a repeating timeline to `invalidate()` all of its child tweens and re-record their starting/ending values internally on each full iteration (not including yoyo's). This is useful when you use dynamic values (relative, random, or function-based). For example, `x: "random(-100, 100)"` would get a new random x value on each repeat. `duration`, `delay`, and `stagger` do **NOT** refresh.

* #### smoothChildTiming[](#smoothChildTiming)

Boolean Controls whether or not child animations are repositioned automatically (changing their `startTime`) in order to maintain smooth playback when timing-related properties are changed on-the-fly. For example, imagine that the timeline‚Äôs playhead is on a child tween that is 75% complete, moving element‚Äôs left from 0 to 100 and then that tween‚Äôs `reverse()` method is called. If `smoothChildTiming` is `false` (the default except for the globalTimeline), the tween would flip in place, keeping its `startTime` consistent. Therefore the playhead of the timeline would now be at the tween‚Äôs 25% completion point instead of 75%. See the "[How to timelines work?](https://gsap.com/docs/v3/GSAP/Timeline#mechanics)" section for details.

Boolean If `true`, every other repeat cycle will run in the opposite direction so that the tween appears to go back and forth (forward then backward). This has no affect on the `reversed` property though. So if `repeat` is `2` and `yoyo` is `false`, it will look like: start - 1 - 2 - 3 - 1 - 2 - 3 - 1 - 2 - 3 - end. But if `yoyo` is `true`, it will look like: start - 1 - 2 - 3 - 3 - 2 - 1 - 1 - 2 - 3 - end.

---

## Helper Functions

**URL:** https://gsap.com/docs/v3/HelperFunctions.md

**Contents:**
- Available Helpers[‚Äã](#available-helpers "Direct link to Available Helpers")

Over the years Jack has "whipped together" various GSAP-related helper functions for [community](https://gsap.com/community/) members, so we gathered them into one place for convenience. We'll keep adding relevant helper functions here as we craft them. Enjoy!

Browse the [helper function collection](https://codepen.io/collection/eJwrak)

|                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                            |
| -------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| #### [Seamlessly loop elements along the x or y axis](/docs/v3/HelperFunctions/helpers/seamlessLoop.md)                                      | Like a slider or news ticker, where elements go off one side and then eventually come back around from the other side. This helper function does all the hard work for you                                                                                                                                                                                                                                                 |
| #### [Stop overscroll behavior, even on iOS Safari](/docs/v3/HelperFunctions/helpers/stopOverscroll.md)                                      | It should be as simple as setting overscroll-behavior: none in your CSS, but iOS Safari won't cooperate! So here's a function that'll help stop the overscroll behavior:                                                                                                                                                                                                                                                   |
| #### [Hook a Lottie animation up to ScrollTrigger](/docs/v3/HelperFunctions/helpers/LottieScrollTrigger.md)                                  | Tie a Lottie animation to the scroll position with this handy function so that as the user scrolls, the animation progresses                                                                                                                                                                                                                                                                                               |
| #### [addWeightedEases](/docs/v3/HelperFunctions/helpers/addWeightedEases.md)                                                                | Feed in a ratio between -1 and 1 to any of the standard (non-configurable) eases to make them "weighted" in one direction or the other                                                                                                                                                                                                                                                                                     |
| #### [Change transformOrigin without a jump](/docs/v3/HelperFunctions/helpers/alignOrigins.md)                                               | change transformOrigin dynamically without a jump                                                                                                                                                                                                                                                                                                                                                                          |
| #### [anchorsToProgress](/docs/v3/HelperFunctions/helpers/anchorsToProgress.md)                                                              | Calculate all the progress values for the anchor points on a path so that, for example, you could use DrawSVG to animate point-by-point (requires [MotionPathPlugin](/docs/v3/Plugins/MotionPathPlugin.md))                                                                                                                                                                                                                |
| #### [Animating backgroundSize:"cover" or "contain"](/docs/v3/HelperFunctions/helpers/bgSize.md)                                             | Animate between \`backgroundSize\` of \`"cover"\` or \`"contain"                                                                                                                                                                                                                                                                                                                                                           |
| #### [blendEases](/docs/v3/HelperFunctions/helpers/blendEases.md)                                                                            | If you need one ease at the start of your animation, and a different one at the end, you can use this function to blend them!                                                                                                                                                                                                                                                                                              |
| #### [Call a function after viewport resizing stops (debounced)](/docs/v3/HelperFunctions/helpers/callAfterResize.md)                        | "resize" events get dispatched many times while the user is dragging the browser window's edges, so if you run an expensive function on every resize event, it can really bog things down. Here's a function that will wait to call your function until a certain amount of time has elapsed since the user STOPPED resizing the window                                                                                    |
| #### [Compensated skews](/docs/v3/HelperFunctions/helpers/compensatedSkew.md)                                                                | This is a special method that you can apply via an onUpdate to make a tween render skews in the old skewType: "compensated" way from GSAP 2. Note that it affects an element's scaleX/scaleY (hence "compensated")! This assumes skews are degree-based, and only works in GSAP 3.                                                                                                                                         |
| #### [Directional snapping](/docs/v3/HelperFunctions/helpers/getDirectionalSnapFunc.md)                                                      | Snap to a value in a specified direction - greater or lesser                                                                                                                                                                                                                                                                                                                                                               |
| #### [Estimate where an ease will hit a certain value](/docs/v3/HelperFunctions/helpers/easeToLinear.md)                                     | An ease accepts a normalized progress value (0-1) and returns the corresponding eased value, but what if you want to know when that eased value will hit a specific ratio like 0.7? For example, a \`"power2.out"\` ease may hit 0.7 when the linear progress is only around 0.33. This function lets you feed in that 0.7 and get the linear progress value (0.33 in this example)                                        |
| #### [Simple FLIP](/docs/v3/HelperFunctions/helpers/FLIP.md)                                                                                 | If you're shifting things around in the DOM and then you want elements to animate to their new positions, the most full-featured way to handle it is with the [Flip Plugin](/docs/v3/Plugins/Flip/.md), but if you're only doing basic things you can use this helper function (see the comments at the top to learn how to use it):                                                                                       |
| #### [Format number with commas and limited decimal places](/docs/v3/HelperFunctions/helpers/formatNumber.md)                                | Take a number like 1000.254145 and format it into a string like "1,000.25".                                                                                                                                                                                                                                                                                                                                                |
| #### [Find a nested label's time](/docs/v3/HelperFunctions/helpers/getNestedLabelTime.md)                                                    | Labels are timeline-specific, so you can't tell a timeline to move its playhead to a label that exists in a nested timeline. So here's a helper function that lets you find a nested label and calculate where that lines up on the parent timeline                                                                                                                                                                        |
| #### [Get the scroll position associated with an element (ScrollTrigger-aware)](/docs/v3/HelperFunctions/helpers/getScrollLookup.md)         | This function even takes ScrollTrigger pinning into account in most situations. Feed it your target elements and it'll return a function that you can call later, passing it a specific one of those target elements and it'll return the scroll position. It even adjusts when the viewport resizes (responsive).                                                                                                         |
| #### [Get the scroll position associated with a particular ScrollTriggered animation](/docs/v3/HelperFunctions/helpers/getScrollPosition.md) | Perhaps you want to scroll the page to the exact spot where a particular scroll-triggered animation starts (or ends or any progress value) - just feed this helper function your animation (it must have a ScrollTrigger of course) and optionally a progress value (0 is when the animation starts, 0.5 is halfway through, 1 is the end) and it'll return the scroll position which you could feed into a scrollTo tween |
| #### [Scrub through a canvas image sequence](/docs/v3/HelperFunctions/helpers/imageSequenceScrub.md)                                         | Create an Array of image URLs, feed it to this helper function along with a reference to your `<canvas>` object and a ScrollTrigger config object to have it scrub through those, drawing the appropriate one to the canvas.                                                                                                                                                                                               |
| #### [killChildTweensOf](/docs/v3/HelperFunctions/helpers/killChildTweensOf.md)                                                              | kill all tweening elements that are children of a given target                                                                                                                                                                                                                                                                                                                                                             |
| #### [SplitText lines in nested elements](/docs/v3/HelperFunctions/helpers/nestedLinesSplit.md)                                              | SplitText doesn't natively support splitting nested elements by "lines", but if you really need that we've put together a helper function for it.                                                                                                                                                                                                                                                                          |
| #### [pluckRandomFrom](/docs/v3/HelperFunctions/helpers/pluckRandomFrom.md)                                                                  | Randomly pluck values from an array one-by-one until they've all been plucked (almost as if when you pluck one, it's no longer available to be plucked again until ALL of them have been uniquely plucked)                                                                                                                                                                                                                 |
| #### [Step-by-step function calls progressively build timeline](/docs/v3/HelperFunctions/helpers/progressiveBuild.md)                        | Maybe you can't pre-build your entire timeline because you need to call individual functions in a sequenced fashion. Perhaps they each change the state of elements, creating an animation that must finish before the next step (function) is called. This helper function lets you organize your code quite easily into a simple sequence of arguments you pass                                                          |
| #### [Change transformOrigin without a jump](/docs/v3/HelperFunctions/helpers/smoothOriginChange.md)                                         | change transformOrigin dynamically without a jump by compensating its translation (x/y)                                                                                                                                                                                                                                                                                                                                    |
| #### [Force GSAP to update while in hidden tab](/docs/v3/HelperFunctions/helpers/tickGSAPWhileHidden.md)                                     | Most browsers pause requestAnimationFrame() calls while a browser tab is hidden in order to reduce CPU/battery drain, but if you'd like GSAP to continue to update, you can use this function                                                                                                                                                                                                                              |
| #### [Track the playhead direction of any animation](/docs/v3/HelperFunctions/helpers/trackDirection.md)                                     | If you find yourself needing an onReverse() callback (which doesn't exist) or a way to get notified when the playhead changes direction, this is a very useful helper function.                                                                                                                                                                                                                                            |
| #### [Weighted Random](/docs/v3/HelperFunctions/helpers/weightedRandom.md)                                                                   | Have more control over the numbers you pick by providing this function an ease curve of your choice!                                                                                                                                                                                                                                                                                                                       |

---

## x

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/x.md

**Contents:**
  - x : Number
  - Details[‚Äã](#details "Direct link to Details")

\[read-only] The current x (horizontal) position of the Draggable instance.

*Number* - The current `x` (horizontal) position of the Draggable instance. For a Draggable of `type: "x,y"`, it would be the `x` transform translation, as in the CSS `transform: translateX(...)`. For `type: "top,left"`, the Draggable's `x` would refer to the CSS `left` value that's applied. This is not the global coordinate - it is the inline CSS-related value applied to the element.

This value is updated each time the Draggable is dragged interactively and during the momentum-based tween that Draggable applies when the user releases their mouse/touch, but if you manually change (or tween) the element's position you can force Draggable to look at the "real" value and record it to its own `x` property by calling the Draggable's `update()` method. Basically that re-synchronizes it. Again, this is not necessary unless other code (outside Draggable) alters the target element's position.

---

## startX

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/startX.md

**Contents:**
  - startX : Number
  - Details[‚Äã](#details "Direct link to Details")

\[read-only] The starting `x` (horizontal) position of the Draggable instance when the most recent drag began.

\[read-only] The starting `x` (horizontal) position of the Draggable instance when the most recent drag began. For a Draggable of `type: "x,y"`, it would be the `x` transform translation, as in the CSS `transform: translateX(...)`. For `type: "top,left"`, the Draggable's `x` would refer to the CSS `left` value that's applied. For `type: "rotation"` it's the rotation (in degrees). This is not the global coordinate - it is the inline CSS-related value applied to the element.

---

## minY

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/minY.md

**Contents:**
  - minY : Number
  - Details[‚Äã](#details "Direct link to Details")

When bounds are applied, `minY` refers to the minimum "legal" vertical property.

*Number* - When bounds are `applied`, `minY` refers to the minimum "legal" value of the horizontal property (either `"y"` or `"top"`, depending on which type the Draggable is). This makes it easier to run your own custom logic inside the snap or callback function(s) if you so choose. So for a Draggable of `type: "x,y"`, `minY` would correlate with `y` transform translation, as in the CSS `transform: translateY(...)`. For `type: "top,left"`, the Draggable's `minY` would correlate with the CSS `top` value that's applied. This is not the global coordinate - it is the inline CSS-related value applied to the element.

---

## zIndex

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/zIndex.md

**Contents:**
  - zIndex : Number
  - Details[‚Äã](#details "Direct link to Details")

\[static] The starting zIndex that gets applied by default when an element is pressed/touched (for positional types, like `"x,y"`, `"top,left"`, etc.

*Number* - The starting `zIndex` that gets applied by default when an element is pressed/touched (for positional types, like `"x,y"`, `"top,left"`, etc. but not `"rotation"` or `"scroll"`) and this number gets incremented and applied to each new element that gets pressed/touched so that the stacking order looks correct (newly pressed objects rise to the top) unless `zIndexBoost: false` is set in a particular Draggable's `vars` parameter. You can set this `zIndex` to whatever you want, but `1000` is the default.

**Examples:**

Example 1 (unknown):
```unknown
Draggable.zIndex = 500;
```

---

## Get the scroll position associated with an element (ScrollTrigger-aware)

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/getScrollLookup.md

**Contents:**
- Usage[‚Äã](#usage "Direct link to Usage")
    - loading...

This function even takes ScrollTrigger pinning into account in most situations. Feed it your target elements and it'll return a function that you can call later, passing it a specific one of those target elements and it'll return the scroll position. It even adjusts when the viewport resizes (responsive).

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/popKYRW?default-tab=result\&theme-id=41164)

**Examples:**

Example 1 (unknown):
```unknown
/*
Returns a FUNCTION that you can feed an element to get its scroll position.
- targets: selector text, element, or Array of elements
- config: an object with any of the following optional properties:
- start: defaults to "top top" but can be anything like "center center", "100px 80%", etc. Same format as "start" and "end" ScrollTrigger values.
- containerAnimation: the horizontal scrolling tween/timeline. Must have an ease of "none"/"linear".
- pinnedContainer: if you're pinning a container of the element(s), you must define it so that ScrollTrigger can make the proper accommodations.
*/
function getScrollLookup(
  targets,
  { start, pinnedContainer, containerAnimation }
) {
  let triggers = gsap.utils.toArray(targets).map((el) =>
      ScrollTrigger.create({
        trigger: el,
        start: start || "top top",
        pinnedContainer: pinnedContainer,
        refreshPriority: -10,
        containerAnimation: containerAnimation,
      })
    ),
    st = containerAnimation && containerAnimation.scrollTrigger;
  return (target) => {
    let t = gsap.utils.toArray(target)[0],
      i = triggers.length;
    while (i-- && triggers[i].trigger !== t) {}
    if (i < 0) {
      return console.warn("target not found", target);
    }
    return containerAnimation
      ? st.start +
          (triggers[i].start / containerAnimation.duration()) *
            (st.end - st.start)
      : triggers[i].start;
  };
}
```

Example 2 (unknown):
```unknown
let getPosition = getScrollLookup(".section", {
  containerAnimation: horizontalTween,
  start: "center center",
});

// then later, use the function as many times as you want to look up any of the scroll position of any ".section" element
gsap.to(window, {
  scrollTo: getPosition("#your-element"),
  duration: 1,
});
```

---

## deltaX

**URL:** https://gsap.com/docs/v3/Plugins/Observer/deltaX.md

**Contents:**
  - deltaX : Number
  - Details[‚Äã](#details "Direct link to Details")

The amount of change (in pixels) horizontally since the last time a callback was fired on that axis. For example, `onChangeX` or `onRight`

The amount of change (in pixels) horizontally since the last time a callback was fired on that axis. For example, `onChangeX` or `onRight`

This is only affected by the event types that the Observer is watching. So, for example, `type: "wheel,touch"` would track the delta based on wheel and touch events (not pointer or scroll). By default, touch and pointer events are only tracked **while pressing/dragging** but if you define an `onMove` (which is mapped to "pointermove"/"mousemove" events), it'll be tracked during any movement while hovering over the target.

---

## Animating backgroundSize:"cover" or "contain"

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/bgSize.md

**Contents:**
- Demo[‚Äã](#demo "Direct link to Demo")
    - loading...
- BackgroundSizePlugin[‚Äã](#backgroundsizeplugin "Direct link to BackgroundSizePlugin")
    - loading...

I was asked about animating to or from a `backgroundSize` of `"cover"` or `"contain"` with GSAP. Ôªø**The problem:** GSAP interpolates between numbers, but how is it supposed to interpolate between something like "300px 250px" and "contain" (not a number)? So I whipped together a function that basically translates "contain" or "cover" into their px-based equivalents for that particular element at whatever size it is then. Once we've got it converted, it's easy tÔªøo animate.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/89bd92e9114108e96874df09a424e8aa?default-tab=result\&theme-id=41164)

For even more flexibility, you can use this unofficial plugin for animating the backgroundSize to/from "cover" or "contain" and it'll even let you apply a scale to the value. Plus if you animate to "cover" or "contain", it will actually set it to that value (instead of the pixel-based equivalent) so that it's responsive after the tween:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/rNYxENg?default-tab=result\&theme-id=41164)

**Examples:**

Example 1 (unknown):
```unknown
/*
config is optional and can have any of the following properties:
- size [string] - the size to set and convert into px before it gets returned, like "cover" or "150% auto".
- nativeWidth [number] - native width of the image (in pixels)
- nativeHeight [number] - native height of the image (in pixels)

Simple example:
// returns current backgroundSize in px
bgSize(".class");

Advanced example:
// sets the backgroundSize to "cover" and returns it in the equivalent px-based amount assuming the image's native width is 600px and height is 400px.
bgSize(".class", {size: "cover", nativeWidth: 600, nativeHeight: 400});

Note: if you can define the nativeWidth and nativeHeight, it helps becaues it can skip tasks like creating
an Image and loading the URL to detect the native size automatically. Sometimes images don't load fast enough,
so skipping that step avoids the whole issue.
*/
function bgSize(element, config) {
  config = config || {};
  let e = gsap.utils.toArray(element)[0],
    cs = window.getComputedStyle(e),
    imageUrl = cs.backgroundImage,
    { nativeWidth, nativeHeight } = config,
    size = config.size || cs.backgroundSize,
    image,
    w,
    h,
    ew,
    eh,
    ratio;
  if (imageUrl && (!/\d/g.test(size) || size.indexOf("%") > -1)) {
    if (!nativeWidth || !nativeHeight) {
      image = new Image();
      image.setAttribute(
        "src",
        imageUrl.replace(/(^url\("|^url\('|^url\(|"\)$|'\)$|\)$)/gi, "")
      );
      nativeWidth = image.naturalWidth;
      nativeHeight = image.naturalHeight;
    }
    ew = e.offsetWidth;
    eh = e.offsetHeight;
    if (!nativeWidth || !nativeHeight) {
      console.log("bgSize() failed;", imageUrl, "hasn't loaded yet.");
      nativeWidth = ew;
      nativeHeight = eh;
    }
    ratio = nativeWidth / nativeHeight;
    if (size === "cover" || size === "contain") {
      if ((size === "cover") === nativeWidth / ew > nativeHeight / eh) {
        h = eh;
        w = eh * ratio;
      } else {
        w = ew;
        h = ew / ratio;
      }
    } else {
      // "auto" or %
      size = size.split(" ");
      size.push("");
      w = ~size[0].indexOf("%")
        ? (ew * parseFloat(size[0])) / 100
        : nativeWidth;
      h = ~size[1].indexOf("%")
        ? (eh * parseFloat(size[1])) / 100
        : nativeHeight;
    }
    size = Math.ceil(w) + "px " + Math.ceil(h) + "px";
    config.size && (e.style.backgroundSize = size);
  }
  return size;
}
```

---

## Timeline

**URL:** https://gsap.com/docs/v3/GSAP/Timeline.md

**Contents:**
    - Minimal usage
  - Returns : [Timeline](/docs/v3/GSAP/Timeline.md)[‚Äã](#returns--timeline "Direct link to returns--timeline")
- Positioning animations in a timeline[‚Äã](#positioning-animations-in-a-timeline "Direct link to Positioning animations in a timeline")
- Special Properties and Callbacks[‚Äã](#special-properties-and-callbacks "Direct link to Special Properties and Callbacks")
- Setting Defaults[‚Äã](#setting-defaults "Direct link to Setting Defaults")
- Nesting[‚Äã](#nesting "Direct link to Nesting")
- Other Timeline Features[‚Äã](#other-timeline-features "Direct link to Other Timeline Features")
- How do timelines work?[‚Äã](#mechanics "Direct link to How do timelines work?")
- **Properties**[‚Äã](#properties "Direct link to properties")
- **Methods**[‚Äã](#methods "Direct link to methods")

A [Timeline](/docs/v3/GSAP/Timeline.md) is a powerful sequencing tool that acts as a container for tweens and other timelines, making it simple to control them as a whole and precisely manage their timing. Without Timelines, building complex sequences would be far more cumbersome because you'd need to use a `delay` for every animation. For example:

What if you wanted to make the first animation longer? You'd need to adjust *every* delay thereafter. And what if you want to `pause()` the whole sequence or `restart()` it or `reverse()` it on-the-fly or repeat it twice? This could become quite messy, but GSAP's Timelines make it incredibly simple:

Now we can adjust the timing without worrying about trickle-down changes to delays! Increase the duration of that first tween and everything automatically adjusts.

The secret to building gorgeous animations with intricate timing is understanding the [position parameter](/resources/position-parameter.md) which is used in many various Timeline methods. This one super-flexible parameter controls the placement of your tweens, labels, callbacks, pauses, and even nested timelines. In other words, it tells the timeline exactly where to insert the animation. It typically comes after the **vars** parameter and it has multiple behaviors:

* Absolute time, like `3` (a number)

* Relative time, like `"+=1"` or `"-=1"` (relative to the **end** of the timeline)

* Label, like `"someLabel"`

* Relative to a label, like `"someLabel+=1"`

* At the **start** of most recently-added animation, `"<"`

* At the **end** of the most recently-added animation, `">"`

* Relative to the start of the most recently-added animation, like `"<1"`

* Relative to the end of the most recently-added animation, like `">1"`

**Hint**: think of `"<"` and `">"` as pointers to the start or end of the most recently-added animation.

Add any of these to your vars object to give your animation special powers:

All of timeline's `vars` properties are described below:

Boolean If `autoRemoveChildren` is set to `true`, as soon as child tweens/timelines complete, they will automatically get killed/removed. This is normally undesireable because it prevents going backwards in time (like if you want to `reverse()` or set the progress lower, etc.). It can, however, improve speed and memory management. The root timelines use `autoRemoveChildren: true`.

* #### callbackScope[](#callbackScope)

Object The scope to be used for all of the callbacks (`onStart`, `onUpdate`, `onComplete`, etc.). The scope is what `this` refers to inside any of the callbacks.

* #### defaults[](#defaults)

Object A simple way to set defaults that get inherited by the child animations. See the "[defaults](https://gsap.com/docs/v3/GSAP/Timeline#setting-defaults)" section for details.

* #### delay[](#delay)

Number Amount of delay in seconds before the animation should begin.

* #### onComplete[](#onComplete)

Function A function that should be called when the animation has completed.

* #### onCompleteParams[](#onCompleteParams)

Array An array of parameters to pass the `onComplete` function. For example, `gsap.timeline({onComplete: myFunction, onCompleteParams: ["param1", "param2"]});`.

* #### onInterrupt[](#onInterrupt)

A function to call when the animation is interrupted min animation. Note that this does not fire if the animation completes normally.

* #### onInterruptParams[](#onInterruptParams)

An Array of parameters to pass the onInterrupt function. For example, `gsap.to(".class", {x:100, onInterrupt:myFunction, onInterruptParams:["param1", "param2"]});`.

* #### onRepeat[](#onRepeat)

Function A function that should be called each time the animation repeats.

* #### onRepeatParams[](#onRepeatParams)

Array An Array of parameters to pass the `onRepeat` function. For example, `gsap.timeline({onRepeat: myFunction, onRepeatParams: ["param1", "param2"]});`.

* #### onReverseComplete[](#onReverseComplete)

Function A function that should be called when the animation has reached its beginning again from the reverse direction. For example, if `reverse()` is called the tween will move back towards its beginning and when its `time` reaches `0`, `onReverseComplete` will be called. This can also happen if the animation is placed in a timeline instance that gets reversed and plays the animation backwards to (or past) the beginning.

* #### onReverseCompleteParams[](#onReverseCompleteParams)

Array An array of parameters to pass the `onReverseComplete` function. For example, `gsap.timeline({onReverseComplete: myFunction, onReverseCompleteParams: ["param1", "param2"]});`.

* #### onStart[](#onStart)

Function A function that should be called when the animation begins (when its `time` changes from `0` to some other value which can happen more than once if the tween is restarted multiple times).

* #### onStartParams[](#onStartParams)

Array An array of parameters to pass the `onStart` function. For example, `gsap.timeline({onStart: myFunction, onStartParams: ["param1", "param2"]});`.

* #### onUpdate[](#onUpdate)

Function A function that should be called every time the animation updates (on every frame while the animation is active).

* #### onUpdateParams[](#onUpdateParams)

Array An array of parameters to pass the `onUpdate` function. For example, `gsap.timeline({onUpdate: myFunction, onUpdateParams: ["param1", "param2"]});`.

* #### paused[](#paused)

Boolean If `true`, the animation will pause itself immediately upon creation.

* #### repeat[](#repeat)

Number Number of times that the animation should repeat after its first iteration. For example, if `repeat` is `1`, the animation will play a total of twice (the initial play plus 1 repeat). To repeat indefinitely, use `-1`. `repeat` should always be an integer.

* #### repeatDelay[](#repeatDelay)

Number Amount of time in seconds between repeats. For example, if `repeat` is `2` and `repeatDelay` is `1`, the animation will play initially, then wait for 1 second before it repeats, then play again, then wait 1 second again before doing its final repeat.

* #### repeatRefresh[](#repeatRefresh)

Setting `repeatRefresh: true` causes a repeating timeline to `invalidate()` all of its child tweens and re-record their starting/ending values internally on each full iteration (not including yoyo's). This is useful when you use dynamic values (relative, random, or function-based). For example, `x: "random(-100, 100)"` would get a new random x value on each repeat. `duration`, `delay`, and `stagger` do **NOT** refresh.

* #### smoothChildTiming[](#smoothChildTiming)

Boolean Controls whether or not child animations are repositioned automatically (changing their `startTime`) in order to maintain smooth playback when timing-related properties are changed on-the-fly. For example, imagine that the timeline‚Äôs playhead is on a child tween that is 75% complete, moving element‚Äôs left from 0 to 100 and then that tween‚Äôs `reverse()` method is called. If `smoothChildTiming` is `false` (the default except for the globalTimeline), the tween would flip in place, keeping its `startTime` consistent. Therefore the playhead of the timeline would now be at the tween‚Äôs 25% completion point instead of 75%. See the "[How to timelines work?](https://gsap.com/docs/v3/GSAP/Timeline#mechanics)" section for details.

Boolean If `true`, every other repeat cycle will run in the opposite direction so that the tween appears to go back and forth (forward then backward). This has no affect on the `reversed` property though. So if `repeat` is `2` and `yoyo` is `false`, it will look like: start - 1 - 2 - 3 - 1 - 2 - 3 - 1 - 2 - 3 - end. But if `yoyo` is `true`, it will look like: start - 1 - 2 - 3 - 3 - 2 - 1 - 1 - 2 - 3 - end.

Anything in the `defaults` object of a timeline gets inherited by its child animations when they get created, so if you find yourself setting the same `ease` or `duration` (or any value) over and over again, this can help make your code more concise. For example:

Any defaults you set this way will get pushed into every child tween - it's not limited to a certain subset of properties. Inherited defaults are easily overwritten anytime a property is declared on a child animation.

Nest timelines within timelines as deeply as you want. This lets you modularize your code and make it more maintainable. For example, you could build your animation in sections and stitch them together in a master timeline like:

* Speed up or slow down the entire timeline with its `timeScale()` method. You can even tween it to gradually speed up or slow down the animation smoothly!

* Get or set the progress of the timeline using its `progress()` or `totalProgress()` methods (totalProgress() just includes any repeats). For example, to skip to the halfway point, set `myTimeline.progress(0.5);`.

* Tween the `time()`, `totalTime()`, `progress()`, or `totalProgress()` to fast-forward or rewind the timeline. You could even attach a slider to one of these to give the user the ability to drag forward or backward through the timeline.

* Add `onComplete`, `onStart`, `onUpdate`, `onRepeat` and/or `onReverseComplete` callbacks using the constructor's `vars` object like `var tl = gsap.timeline({onComplete: myFunction});`.

* Kill the tweens of a particular object inside the timeline with `killTweensOf(target)` or get the tweens of an object with `getTweensOf()` or get all the tweens and timelines in the timeline with `getChildren()`.

* Set the timeline to repeat any number of times or indefinitely. You can even set a delay between each repeat cycle and/or cause the repeat cycles to yoyo, appearing to reverse direction every other cycle.

* Get the `currentLabel()` or find labels at various positions in the timeline using `nextLabel()` and `previousLabel()`

Every animation (Tween and Timeline) is placed on a parent Timeline. In a sense, they all have their own playheads (that's what its "time" refers to, or "totalTime" which is identical except that it includes repeats and repeatDelays) and when the parent's playhead moves to a new position, it updates the childrens' too (unless they're paused).

When a timeline renders at a particular time, it loops through its children and says "okay, you should render as if your playhead is at \_\_\_\_" and if that child is a Timeline with children, it does the same to its children, right on down the line. So the playheads generally remain synchronized.

When you unpause an animation (`resume()` or `play()`), it essentially picks up the playhead and moves it so that its internal playhead is synchronized with wherever the parent's playhead is at that moment, thus things play perfectly smoothly. That is, unless the timeline's `smoothChildTiming` is `false` in which case that child won't move - its `startTime` will remain locked to where it was.

So basically when `smoothChildTiming` is `true`, the engine will rearrange things on the fly to ensure the playheads line up so that playback feels seamless and smooth. The same thing happens when you `reverse()` or alter the `timeScale`, etc. - the animation's startTime shifts automatically. But sometimes you might not want that behavior - that's when `smoothChildTiming: false` is handy on a parent timeline.

One more example: let's say you've got a 10-second tween that's just sitting on the root timeline and you're 2-seconds into the tween. Let's assume it started at exactly 0 on the root to make this easy, and then when it's at 2-seconds, you do `tween.seek(5)`. The playhead of the root isn't affected - it keeps going exactly as it always did, but in order to make that tween jump to 5 seconds and play appropriately, the tween's `startTime` gets changed to -3. That way, the tween's playhead and the root playhead are perfectly aligned.

* You can access GSAP's global timeline via [`gsap.globalTimeline`](/docs/v3/GSAP/gsap.globalTimeline\(\)) but be careful because if, for example, you pause() or timeScale() it, that affects EVERYTHING including delayedCalls(). You can use [`gsap.exportRoot()`](/docs/v3/GSAP/gsap.exportRoot\(\).md) instead to basically wrap all of the existing animations on the root (optionally excluding delayedCalls) into a new Timeline instance, isolating those from future animations you create. For example, if you have a bunch of animations going on in a game and then the user clicks a button to pop open a modal window that should slow all the game animations to 1/10ths speed...but you want you modal animations to be full-speed, that's the perfect case for exportRoot().

|                                                                                                                                 |                                                                                                                                                                                                                                 |
| ------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| #### [autoRemoveChildren](/docs/v3/GSAP/Timeline/autoRemoveChildren.md) : Boolean                                               | If `true`, child tweens and timelines will be removed as soon as they complete.                                                                                                                                                 |
| #### [data](/docs/v3/GSAP/Timeline/data.md) : \*                                                                                | A place to store any data you want (initially populated with `vars.data` if it exists).                                                                                                                                         |
| #### [labels](/docs/v3/GSAP/Timeline/labels.md) : Object                                                                        | This stores any labels that have been added to the timeline.                                                                                                                                                                    |
| #### [parent](/docs/v3/GSAP/Timeline/parent.md) : Timeline                                                                      | The parent [Timeline](/docs/v3/GSAP/Timeline.md) to which the animation is attached. Anything that's not in a Timeline that you create is placed on the [gsap.globalTimeline](/docs/v3/GSAP/gsap.globalTimeline.md) by default. |
| #### [scrollTrigger](/docs/v3/GSAP/Timeline/scrollTrigger.md): [ScrollTrigger](/docs/v3/Plugins/ScrollTrigger/.md) \| undefined | A handy way to access the ScrollTrigger associated with a timeline. This is only accessible if the timeline has a ScrollTrigger.                                                                                                |
| #### [smoothChildTiming](/docs/v3/GSAP/Timeline/smoothChildTiming.md) : Boolean                                                 | Controls whether or not child tweens and timelines are repositioned automatically (changing their `startTime`) in order to maintain smooth playback when properties are changed on-the-fly.                                     |
| #### [vars](/docs/v3/GSAP/Timeline/vars.md) : Object                                                                            | The configuration object passed into the original timeline via the constructor, like `gsap.timeline({onComplete: func});`                                                                                                       |

|                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                                              |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| #### [add](/docs/v3/GSAP/Timeline/add\(\).md)( child:\[Tween \| Timeline \| Label \| Callback \| Array], position:\[Number \| String \| Label] ) : self             | \[override] Adds a tween, timeline, callback, or label (or an array of them) to the timeline.                                                                                                                                                                                                                                                |
| #### [addLabel](/docs/v3/GSAP/Timeline/addLabel\(\).md)( label:String, position:\[Number \| String] ) : self                                                        | Adds a label to the timeline, making it easy to mark important positions/times.                                                                                                                                                                                                                                                              |
| #### [addPause](/docs/v3/GSAP/Timeline/addPause\(\).md)( position:\[String \| Number \| Label], callback:Function, params:Array ) : self                            | Inserts a special callback that pauses playback of the timeline at a particular time or label.                                                                                                                                                                                                                                               |
| #### [call](/docs/v3/GSAP/Timeline/call\(\).md)( callback:Function, params:Array, position:\* ) : self                                                              | Adds a callback to the end of the timeline (or elsewhere using the `position` parameter) - this is a convenience method that accomplishes exactly the same thing as `add( gsap.delayedCall(...) )` but with less code.                                                                                                                       |
| #### [clear](/docs/v3/GSAP/Timeline/clear\(\).md)( labels:Boolean ) : self                                                                                          | Empties the timeline of all tweens, timelines, and callbacks (and optionally labels too).                                                                                                                                                                                                                                                    |
| #### [currentLabel](/docs/v3/GSAP/Timeline/currentLabel\(\).md)( value:String ) : \[String \| self]                                                                 | Gets the closest label that is at or before the current time, or jumps to a provided label (behavior depends on whether or not you pass a parameter to the method).                                                                                                                                                                          |
| #### [delay](/docs/v3/GSAP/Timeline/delay\(\).md)( value:Number ) : \[Number \| self]                                                                               | Gets or sets the animation's initial `delay` which is the length of time in seconds before the animation should begin.                                                                                                                                                                                                                       |
| #### [duration](/docs/v3/GSAP/Timeline/duration\(\).md)( value:Number ) : \[Number \| self]                                                                         | \[override] Gets the timeline's duration or, if used as a setter, adjusts the timeline's timeScale to fit it within the specified duration.                                                                                                                                                                                                  |
| #### [endTime](/docs/v3/GSAP/Timeline/endTime\(\).md)( includeRepeats:Boolean ) : \[Number \| self]                                                                 | Returns the time at which the animation will finish according to the parent timeline's local time.                                                                                                                                                                                                                                           |
| #### [eventCallback](/docs/v3/GSAP/Timeline/eventCallback\(\).md)( type:String, callback:Function, params:Array ) : \[Function \| self]                             | Gets or sets an event callback like `onComplete`, `onUpdate`, `onStart`, `onReverseComplete`, or `onRepeat` along with any parameters that should be passed to that callback.                                                                                                                                                                |
| #### [from](/docs/v3/GSAP/Timeline/from\(\).md)( target:\[ Object \| Array \| String ], vars:Object, position:\[ Number \| String ] ) : self                        | Adds a `.from()` tween to the end of the timeline (or elsewhere using the `position` parameter) - this is a convenience method that accomplishes exactly the same thing as `add( gsap.from(...) )` but with less code.                                                                                                                       |
| #### [fromTo](/docs/v3/GSAP/Timeline/fromTo\(\).md)( target:\[ Object \| Array \| String ], fromVars:Object, toVars:Object, position:\[ Number \| String ] ) : self | Adds a `.fromTo()` tween to the end of the timeline - this is a convenience method that accomplishes exactly the same thing as `add( gsap.fromTo(...) )` but with less code.                                                                                                                                                                 |
| #### [getById](/docs/v3/GSAP/Timeline/getById\(\).md)( id:String ) : Animation                                                                                      |                                                                                                                                                                                                                                                                                                                                              |
| #### [getChildren](/docs/v3/GSAP/Timeline/getChildren\(\).md)( nested:Boolean, tweens:Boolean, timelines:Boolean, ignoreBeforeTime:Number ) : Array                 | Returns an array containing all the tweens and/or timelines nested in this timeline.                                                                                                                                                                                                                                                         |
| #### [getTweensOf](/docs/v3/GSAP/Timeline/getTweensOf\(\).md)( target:\[Object \| Selector text \| Array], nested:Boolean ) : Array                                 | Returns the tweens of a particular object that are inside this timeline.                                                                                                                                                                                                                                                                     |
| #### [globalTime](/docs/v3/GSAP/Timeline/globalTime\(\).md)( localTime:Number ) : Number                                                                            | Converts a local time to the corresponding time on the [gsap.globalTimeline](/docs/v3/GSAP/gsap.globalTimeline.md) (factoring in all nesting, timeScales, etc.).                                                                                                                                                                             |
| #### [invalidate](/docs/v3/GSAP/Timeline/invalidate\(\).md)( ) : self                                                                                               | \[override] Flushes any internally-recorded starting/ending values which can be useful if you want to restart an animation without reverting to any previously recorded starting values.                                                                                                                                                     |
| #### [isActive](/docs/v3/GSAP/Timeline/isActive\(\).md)( ) : Boolean                                                                                                | Indicates whether or not the animation is currently active (meaning the virtual playhead is actively moving across this instance's time span and it is not paused, nor are any of its ancestor timelines).                                                                                                                                   |
| #### [iteration](/docs/v3/GSAP/Timeline/iteration\(\).md)( value:Number ) : \[Number \| self]                                                                       | Gets or sets the iteration (the current repeat) of timelines.                                                                                                                                                                                                                                                                                |
| #### [kill](/docs/v3/GSAP/Timeline/kill\(\).md)( ) : Timeline                                                                                                       | Immediately kills the timeline and removes it from its parent timeline, stopping its animation.                                                                                                                                                                                                                                              |
| #### [killTweensOf](/docs/v3/GSAP/Timeline/killTweensOf\(\).md)( targets:Selector text \| Array \| Object, props:String, onlyActive:Boolean ) : Timeline            | Kills all of the tweens inside this timeline that affect the provided `targets`. You can optionally specify specific properties that you want killed.                                                                                                                                                                                        |
| #### [nextLabel](/docs/v3/GSAP/Timeline/nextLabel\(\).md)( time:Number ) : String                                                                                   | Returns the next label in the timeline from the provided time. If no `time` is provided, the timeline's current playhead time will be used.                                                                                                                                                                                                  |
| #### [pause](/docs/v3/GSAP/Timeline/pause\(\).md)( atTime:\*, suppressEvents:Boolean ) : self                                                                       | Pauses the instance, optionally jumping to a specific time.                                                                                                                                                                                                                                                                                  |
| #### [paused](/docs/v3/GSAP/Timeline/paused\(\).md)( value:Boolean ) : \[Boolean \| self]                                                                           | Gets or sets the animation's paused state which indicates whether or not the animation is currently paused.                                                                                                                                                                                                                                  |
| #### [play](/docs/v3/GSAP/Timeline/play\(\).md)( from:\*, suppressEvents:Boolean ) : self                                                                           | Begins playing forward, optionally from a specific time (by default playback begins from wherever the playhead currently is).                                                                                                                                                                                                                |
| #### [previousLabel](/docs/v3/GSAP/Timeline/previousLabel\(\).md)( time:Number ) : String                                                                           | Returns the previous label in the timeline from the provided `time`. If no `time` is provided, the timeline's current playhead time will be used.                                                                                                                                                                                            |
| #### [progress](/docs/v3/GSAP/Timeline/progress\(\).md)( value:Number, suppressEvents:Boolean ) : \[Number \| self]                                                 | \[override] Gets or sets the timeline's progress which is a value between 0 and 1 indicating the position of the virtual playhead (excluding repeats) where 0 is at the beginning, 0.5 is halfway complete, and 1 is complete.                                                                                                               |
| #### [recent](/docs/v3/GSAP/Timeline/recent\(\).md)( ) : \[Tween \| Timeline \| Callback]                                                                           | Returns the most recently added child tween/timeline/callback regardless of its position in the timeline.                                                                                                                                                                                                                                    |
| #### [remove](/docs/v3/GSAP/Timeline/remove\(\).md)( value:\[Tween \| Timeline \| Callback \| Label] ) : self                                                       | Removes a tween, timeline, callback, or label (or array of them) from the timeline.                                                                                                                                                                                                                                                          |
| #### [removeLabel](/docs/v3/GSAP/Timeline/removeLabel\(\).md)( label:String ) : self                                                                                | Removes a label from the timeline and returns the time of that label.                                                                                                                                                                                                                                                                        |
| #### [removePause](/docs/v3/GSAP/Timeline/removePause\(\).md)( position:\[Number \| Label] ) : self                                                                 | Removes pauses that were added to a timeline via its `.addPause()` method.                                                                                                                                                                                                                                                                   |
| #### [repeat](/docs/v3/GSAP/Timeline/repeat\(\).md)( value:Number ) : \[Number \| self]                                                                             | Gets or sets the number of times that the timeline should repeat after its first iteration.                                                                                                                                                                                                                                                  |
| #### [repeatDelay](/docs/v3/GSAP/Timeline/repeatDelay\(\).md)( value:Number ) : \[Number \| self]                                                                   | Gets or sets the amount of time in seconds between repeats.                                                                                                                                                                                                                                                                                  |
| #### [restart](/docs/v3/GSAP/Timeline/restart\(\).md)( includeDelay:Boolean, suppressEvents:Boolean ) : self                                                        | Restarts and begins playing forward from the beginning.                                                                                                                                                                                                                                                                                      |
| #### [resume](/docs/v3/GSAP/Timeline/resume\(\).md)( ) : self                                                                                                       | Resumes playing without altering direction (forward or reversed).                                                                                                                                                                                                                                                                            |
| #### [reverse](/docs/v3/GSAP/Timeline/reverse\(\).md)( from:\*, suppressEvents:Boolean ) : self                                                                     | Reverses playback so that all aspects of the animation are oriented backwards including, for example, a tween's ease.                                                                                                                                                                                                                        |
| #### [reversed](/docs/v3/GSAP/Timeline/reversed\(\).md)( value:Boolean ) : \[Boolean \| self]                                                                       | Gets or sets the animation's reversed state which indicates whether or not the animation should be played backwards.                                                                                                                                                                                                                         |
| #### [revert](/docs/v3/GSAP/Timeline/revert\(\).md)( ) : Self                                                                                                       | Reverts the Timeline and kills it, returning the targets to their pre-animation state including the removal of inline styles added by the Timeline.                                                                                                                                                                                          |
| #### [seek](/docs/v3/GSAP/Timeline/seek\(\).md)( position:\*, suppressEvents:Boolean ) : self                                                                       | \[override] Jumps to a specific time (or label) without affecting whether or not the instance is paused or reversed.                                                                                                                                                                                                                         |
| #### [set](/docs/v3/GSAP/Timeline/set\(\).md)( target:\[ Object \| Array \| String ], vars:Object, position:\[ Number \| String ] ) : self                          | Adds a zero-duration tween to the end of the timeline (or elsewhere using the `position` parameter) that sets values immediately when the virtual playhead reaches that position on the timeline - this is a convenience method that accomplishes exactly the same thing as `add( gsap.to(target, {duration: 0, ...}) )` but with less code. |
| #### [shiftChildren](/docs/v3/GSAP/Timeline/shiftChildren\(\).md)( amount:Number, adjustLabels:Boolean, ignoreBeforeTime:Number ) : self                            | Shifts the startTime of the timeline's children by a certain amount and optionally adjusts labels too.                                                                                                                                                                                                                                       |
| #### [startTime](/docs/v3/GSAP/Timeline/startTime\(\).md)( value:Number ) : \[Number \| self]                                                                       | Gets or sets the time at which the animation begins on its parent timeline (after any delay that was defined).                                                                                                                                                                                                                               |
| #### [then](/docs/v3/GSAP/Timeline/then\(\).md)( callback:Function ) : Promise                                                                                      | Returns a promise so that you can uses promises to track when a tween or timeline is complete.                                                                                                                                                                                                                                               |
| #### [time](/docs/v3/GSAP/Timeline/time\(\).md)( value:Number, suppressEvents:Boolean ) : \[Number \| self]                                                         | \[override] Gets or sets the local position of the playhead (essentially the current time), not including any repeats or repeatDelays.                                                                                                                                                                                                       |
| #### [timeScale](/docs/v3/GSAP/Timeline/timeScale\(\).md)( value:Number ) : \[Number \| self]                                                                       | Factor that's used to scale time in the animation where 1 = normal speed (the default), 0.5 = half speed, 2 = double speed, etc.                                                                                                                                                                                                             |
| #### [to](/docs/v3/GSAP/Timeline/to\(\).md)( target:\[ Object \| Array \| String ], vars:Object, position:\[ Number \| String ] ) : self                            | Adds a `gsap.to()` tween to the end of the timeline (or elsewhere using the `position` parameter) - this is a convenience method that accomplishes exactly the same thing as `add( gsap.to(...) )` but with less code.                                                                                                                       |
| #### [totalDuration](/docs/v3/GSAP/Timeline/totalDuration\(\).md)( value:Number ) : \[Number \| self]                                                               | Gets or sets the total duration of the timeline in seconds including any repeats or repeatDelays.                                                                                                                                                                                                                                            |
| #### [totalProgress](/docs/v3/GSAP/Timeline/totalProgress\(\).md)( value:Number, suppressEvents:Boolean ) : \[Number \| self]                                       | \[override] Gets or sets the timeline's total progress which is a value between 0 and 1 indicating the position of the virtual playhead (including repeats) where 0 is at the beginning, 0.5 is at the halfway point, and 1 is at the end (complete).                                                                                        |
| #### [totalTime](/docs/v3/GSAP/Timeline/totalTime\(\).md)( time:Number, suppressEvents:Boolean ) : \[Number \| self]                                                | Gets or sets the position of the playhead according to the `totalDuration` which includes any repeats and repeatDelays.                                                                                                                                                                                                                      |
| #### [tweenFromTo](/docs/v3/GSAP/Timeline/tweenFromTo\(\).md)( fromPosition:\[Number \| Label], toPosition:\[Number \| Label], vars:Object ) : Tween                | Creates a linear tween that essentially scrubs the playhead from a particular time or label to another time or label and then stops.                                                                                                                                                                                                         |
| #### [tweenTo](/docs/v3/GSAP/Timeline/tweenTo\(\).md)( position:\[Number \| Label], vars:Object ) : Tween                                                           | Creates a linear tween that essentially scrubs the playhead to a particular time or label and then stops.                                                                                                                                                                                                                                    |
| #### [yoyo](/docs/v3/GSAP/Timeline/yoyo\(\).md)( value:Boolean ) : \[Boolean \| self]                                                                               | Gets or sets the timeline's yoyo state, where true causes the timeline to go back and forth, alternating backward and forward on each repeat.                                                                                                                                                                                                |

**Examples:**

Example 1 (unknown):
```unknown
// This is a Tween
gsap.to(".box", { rotation: 27, x: 100, duration: 1 });

// And this is a Timeline, containing three sequenced tweens
let tl = gsap.timeline();
tl.to("#green", {duration: 1, x: 786})
  .to("#blue", {duration: 2, x: 786})
  .to("#orange", {duration: 1, x: 786})
```

Example 2 (unknown):
```unknown
// WITHOUT Timelines (only using delays):
gsap.to("#id", { x: 100, duration: 1 });
gsap.to("#id", { y: 50, duration: 2, delay: 1 }); //wait 1 second
gsap.to("#id", { opacity: 0, duration: 1, delay: 3 }); //wait 3 seconds
```

Example 3 (unknown):
```unknown
// then we can control the whole thing easily...
tl.pause();
tl.resume();
tl.seek(1.5);
tl.reverse();
```

Example 4 (unknown):
```unknown
//insert exactly 3 seconds from the start of the timeline
tl.to(".class", { x: 100 }, 3);
```

---

## ExpoScaleEase

**URL:** https://gsap.com/docs/v3/Eases/ExpoScaleEase.md

**Contents:**
    - CDN Link
    - Minimal usage
  - Description[‚Äã](#description "Direct link to Description")
  - Video Explanation[‚Äã](#video-explanation "Direct link to Video Explanation")
  - Configuration[‚Äã](#configuration "Direct link to Configuration")
  - Simple Demo[‚Äã](#simple-demo "Direct link to Simple Demo")
    - loading...
  - Complex Demo[‚Äã](#complex-demo "Direct link to Complex Demo")
    - loading...

Not included in the Core

This ease is in the EasePack file. To learn how to include this in your project, see [the Installation page](/docs/v3/Installation).

There's an interesting phenomena that occurs when you animate an object's `scale` that makes it appear to change speed **even with a linear ease**; `ExpoScaleEase` compensates for this effect by bending the easing curve accordingly. This is the secret sauce for silky-smooth zooming/scaling animations.

[YouTube video player](https://www.youtube.com/embed/rwdlO3uIlwk)

In order for ExpoScaleEase to create the correct easing curve, you must pass in the **starting** and **ending** scale values in the string, like:

It can also accept a 3rd parameter, the ease that you'd like it to bend (the default is `"none"`). So, for example, if you'd like to use `"power2.inOut"`, your code would look like:

**Note:** The scale values passed into the `config()` method **must be non-zero** because the math wouldn't work with 0. You're welcome to use a small value like 0.01 instead. Using a *SUPER* small number like 0.00000001 may not be ideal because a large portion of the tween would be used going through the very small values.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/6239c068e182bdb8ff18926f519f8565?default-tab=result\&theme-id=41164)

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/qBBBxaL?default-tab=result\&theme-id=41164)

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(EasePack)
```

Example 2 (unknown):
```unknown
// we're starting at a scale of 1 and animating to 2, so pass those into config()...
gsap.to("#image", { duration: 1, scale: 2, ease: "expoScale(1, 2)" });
```

Example 3 (unknown):
```unknown
// we're starting at a scale of 1 and animating to 2, so pass those into config()...
gsap.to("#image", { duration: 1, scale: 2, ease: "expoScale(1, 2)" });
```

Example 4 (unknown):
```unknown
//scale from 0.5 to 3 using "power2.inOut" ...
gsap.fromTo(
  "#image",
  { scale: 0.5 },
  { duration: 1, scale: 3, ease: "expoScale(0.5, 3, power2.inOut)" }
);
```

---

## Plugins

**URL:** https://gsap.com/docs/v3/Plugins.md

**Contents:**
- Plugin Overview[‚Äã](#plugin-overview "Direct link to Plugin Overview")
- Included in GSAP's Core
  - Animate anything
  - [Eases](/docs/v3/Eases.md)
  - Animate efficiently
  - [Utility Methods](/docs/v3/GSAP/UtilityMethods.md)
  - Scroll Plugins
  - Text Plugins
  - SVG Plugins
  - UI Plugins

A plugin adds extra capabilities to GSAP's core. This allows the GSAP core to remain relatively small and lets you add features only when you need them.

* ## [GSAP](/docs/v3/GSAP/.md)
  CDN

[Tween](/docs/v3/GSAP/Tween.md)

[Timeline](/docs/v3/GSAP/Timeline.md)

* [CSS properties](/docs/v3/GSAP/CorePlugins/CSS.md)
* [Attributes](/docs/v3/GSAP/CorePlugins/Attributes.md)
* [Array Values](/docs/v3/GSAP/CorePlugins/EndArray.md)
* [and more...](/resources/get-started.md#any-numeric-value-color-or-complex-string-containing-numbers)

* ["none"](/docs/v3/Eases.md)
* ["power1"](/docs/v3/Eases.md)
* ["power2"](/docs/v3/Eases.md)
* ["power3"](/docs/v3/Eases.md)
* ["power4"](/docs/v3/Eases.md)
* ["back"](/docs/v3/Eases.md)
* ["bounce"](/docs/v3/Eases.md)
* ["circ"](/docs/v3/Eases.md)
* ["elastic"](/docs/v3/Eases.md)
* ["expo"](/docs/v3/Eases.md)
* ["sine"](/docs/v3/Eases.md)
* ["steps(n)"](/docs/v3/Eases/SteppedEase.md)

* [Staggers](/resources/getting-started/Staggers.md)
* [Callbacks](/resources/getting-started/control.md#callbacks)
* [Snapping](/docs/v3/GSAP/CorePlugins/Snap.md)
* [Modifiers](/docs/v3/GSAP/CorePlugins/Modifiers.md)
* [Keyframes](/resources/keyframes.md)
* [Ticker with lag smoothing](/docs/v3/GSAP/gsap.ticker\(\))
* [Cleanup - context() & revert()](/docs/v3/GSAP/gsap.context\(\).md)
* [Responsivity & Accessibility - matchMedia()](/docs/v3/GSAP/gsap.matchMedia\(\).md)

* [checkPrefix()](/docs/v3/GSAP/UtilityMethods/checkPrefix\(\).md)
* [clamp()](/docs/v3/GSAP/UtilityMethods/clamp\(\).md)
* [distribute()](/docs/v3/GSAP/UtilityMethods/distribute\(\).md)
* [getUnit()](/docs/v3/GSAP/UtilityMethods/getUnit\(\).md)
* [interpolate()](/docs/v3/GSAP/UtilityMethods/interpolate\(\).md)
* [mapRange()](/docs/v3/GSAP/UtilityMethods/mapRange\(\).md)
* [normalize()](/docs/v3/GSAP/UtilityMethods/normalize\(\).md)
* [pipe()](/docs/v3/GSAP/UtilityMethods/pipe\(\).md)
* [random()](/docs/v3/GSAP/UtilityMethods/random\(\).md)
* [selector()](/docs/v3/GSAP/UtilityMethods/selector\(\).md)
* [shuffle()](/docs/v3/GSAP/UtilityMethods/shuffle\(\).md)
* [snap()](/docs/v3/GSAP/UtilityMethods/snap\(\).md)
* [splitColor()](/docs/v3/GSAP/UtilityMethods/splitColor\(\).md)
* [toArray()](/docs/v3/GSAP/UtilityMethods/toArray\(\).md)
* [unitize()](/docs/v3/GSAP/UtilityMethods/unitize\(\).md)
* [wrap()](/docs/v3/GSAP/UtilityMethods/wrap\(\).md)
* [wrapYoyo()](/docs/v3/GSAP/UtilityMethods/wrapYoyo\(\).md)

* [ScrollTrigger](/docs/v3/Plugins/ScrollTrigger/.md)popular

CDN
* [ScrollTo](/docs/v3/Plugins/ScrollToPlugin.md)

CDN
* [ScrollSmoother](/docs/v3/Plugins/ScrollSmoother/.md)

requires [ScrollTrigger](/docs/v3/Plugins/ScrollTrigger/.md)

* [SplitText](/docs/v3/Plugins/SplitText/.md)popular

CDN
* [ScrambleText](/docs/v3/Plugins/ScrambleTextPlugin.md)

CDN
* [Text Replacement](/docs/v3/Plugins/TextPlugin.md)

* [DrawSVG](/docs/v3/Plugins/DrawSVGPlugin.md)popular

CDN
* [MorphSVG](/docs/v3/Plugins/MorphSVGPlugin.md)

CDN
* [MotionPath](/docs/v3/Plugins/MotionPathPlugin.md)

CDN
* [MotionPathHelper](/docs/v3/Plugins/MotionPathHelper)

* [Flip](/docs/v3/Plugins/Flip/.md)popular

CDN
* [Draggable](/docs/v3/Plugins/Draggable/.md)

CDN
* [Inertia](/docs/v3/Plugins/InertiaPlugin/.md)

CDN
* [Observer](/docs/v3/Plugins/Observer/.md)

* [Physics2D](/docs/v3/Plugins/Physics2DPlugin.md)

CDN
* [PhysicsProps](/docs/v3/Plugins/PhysicsPropsPlugin.md)

CDN
* [GSDevTools](/docs/v3/Plugins/GSDevTools.md)

CDN
* [Easel](/docs/v3/Plugins/EaselPlugin.md)

CDN
* [Pixi](/docs/v3/Plugins/PixiPlugin/.md)

* [CustomEase](/docs/v3/Eases/CustomEase.md)popular

CDN
* [EasePack](/docs/v3/Eases/CustomWiggle.md)

[rough](/docs/v3/Eases/RoughEase.md), [slow](/docs/v3/Eases/SlowMo.md), and [expoScale](/docs/v3/Eases/ExpoScaleEase.md)

CDN
* [CustomWiggle](/docs/v3/Eases/CustomWiggle.md)

requires [CustomEase](/docs/v3/Eases/CustomEase.md)

CDN
* [CustomBounce](/docs/v3/Eases/CustomBounce.md)

requires [CustomEase](/docs/v3/Eases/CustomEasee)

* [useGSAP()](https://gsap.com/resources/React)popular

At the end of the day, all the plugins are just JS files - just like the core library. You can install them with script tags, via npm, with yarn, or even with a tgz file.

Head on over to our [install helper](/docs/v3/Installation) to choose your own adventure.

Registering a plugin with the GSAP core ensures that the two work seamlessly together and also prevents tree shaking issues in build tools/bundlers. You only need to register a plugin once before using it, like:

Obviously you need to load the plugin file first. There is no harm in registering the same plugin multiple times (but it doesn't help either).

**Examples:**

Example 1 (unknown):
```unknown
//list as many as you'd like
gsap.registerPlugin(MotionPathPlugin, ScrollTrigger, MorphSVGPlugin);
```

---

## .vars

**URL:** https://gsap.com/docs/v3/Plugins/ScrollSmoother/vars.md

**Contents:**
  - .vars : Object
  - Details[‚Äã](#details "Direct link to Details")

The configuration object passed into the [ScrollSmoother.create()](/docs/v3/Plugins/ScrollSmoother/static.create\(\).md) initially.

The configuration object passed into the [ScrollSmoother.create()](/docs/v3/Plugins/ScrollSmoother/static.create\(\).md) initially.

---

## labels

**URL:** https://gsap.com/docs/v3/GSAP/Timeline/labels.md

**Contents:**
  - labels : Object
  - Details[‚Äã](#details "Direct link to Details")

This stores any labels that have been added to the timeline.

This stores any labels that have been added to the timeline. You can get the full object with all labels by using `timeline.labels`. For example:

**Examples:**

Example 1 (unknown):
```unknown
var tl = gsap.timeline();

tl.addLabel("myLabel", 3);
tl.addLabel("anotherLabel", 5);

//now the label object has those labels and times, like:
console.log(tl.labels.myLabel); // 3
console.log(tl.labels.anotherLabel); // 5
```

---

## SteppedEase

**URL:** https://gsap.com/docs/v3/Eases/SteppedEase.md

**Contents:**
  - Description[‚Äã](#description "Direct link to Description")

SteppedEase is included in GSAP's core

Most easing equations give a smooth, gradual transition between the start and end values, but SteppedEase provides an easy way to define a specific number of steps that the transition should take.

For example, if x is 0 and you want to tween it to 100 with 5 steps (20, 40, 60, 80, and 100) over the course of 2 seconds, you'd do:

**Note:** SteppedEase is optimized for use with the GreenSock Animation Platform, so it isn't intended to be used with other engines. Specifically, its easing equation always returns values between 0 and 1.

**Examples:**

Example 1 (unknown):
```unknown
gsap.to(obj, {duration: 2, x: 100, ease: "steps(5)"});
```

---

## autoScroll

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/autoScroll.md

**Contents:**
  - autoScroll : Number
  - Details[‚Äö√Ñ√£](#details "Direct link to Details")
    - loading...

How fast to scroll the container element when `autoScroll` is `true`.

*Number* - To enable auto-scrolling when a Draggable is dragged within 40px of an edge of a scrollable container, set `autoScroll` to a non-zero value, where `1` is normal speed, `2` is double-speed, etc. (you can use any number). For a more intuitive or natural feel, it will scroll faster as the mouse/touch gets closer to the edge. The default value is `0` (no auto-scrolling).

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/YPvdYv?default-tab=result\&theme-id=41164)

---

## MorphSVGPlugin.rawPathToString

**URL:** https://gsap.com/docs/v3/Plugins/MorphSVGPlugin/static.rawPathToString.md

**Contents:**
  - MorphSVGPlugin.rawPathToString( rawPath:Array ) : String
    - Parameters
  - Returns : String[‚Äã](#returns--string "Direct link to Returns : String")
  - Details[‚Äã](#details "Direct link to Details")

Converts a RawPath (array) into a string of path data, like `"M0,0 C100,20 300,50 400,0..."` which is what's typically found in the `d` attribute of a `<path>`.

* #### **rawPath**: Array

The RawPath to be converted to a string.

The string of path data commands in cubic bezier format, like `"M0,0 C10,20,15,30,5,18 M0,100 C50,120,80,110,100,100"`.

Converts a RawPath (array) into a string of cubic-bezer path data, like `"M0,0 C100,20 300,50 400,0..."` which is what's typically found in the `d` attribute of a `<path>`.

A **RawPath** is essentially an array containing an array for each contiguous segment with alternating x, y, x, y cubic bezier data. It's like an SVG `<path>` where there's one segment (array) for each `M` command. That segment (array) contains all of the cubic bezier coordinates in alternating x/y format (just like SVG path data) in raw numeric form which is nice because that way you don't have to parse a long string and convert things.

For example, this SVG `<path>` has two separate segments because there are two "M" commands:

The resulting RawPath would be:

Keep in mind that this function converts raw paths (like the second code block) to their string form (like the d= part of the first code block).

For simplicity, the example above only has one cubic bezier in each segment, but there could be an unlimited quantity inside each segment. No matter what path commands are in the original`<path>` data string (cubic, quadratic, arc, lines, whatever), the resulting RawPath will **ALWAYS** be cubic beziers.

There is also a corresponding [`MorphSVGPlugin.stringToRawPath()`](/docs/v3/Plugins/MorphSVGPlugin/static.stringToRawPath.md) method so that you can convert back and forth.

**Examples:**

Example 1 (unknown):
```unknown
<path d="M0,0 C10,20,15,30,5,18 M0,100 C50,120,80,110,100,100" />
```

Example 2 (unknown):
```unknown
[
  [0, 0, 10, 20, 15, 30, 5, 18],
  [0, 100, 50, 120, 80, 110, 100, 100],
];
```

---

## ScrollTrigger

**URL:** https://gsap.com/docs/v3/Plugins/ScrollTrigger.md

**Contents:**
    - CDN Link
    - Minimal usage
- Simple example[‚Äã](#simple-example "Direct link to Simple example")
- Advanced example[‚Äã](#advanced-example "Direct link to Advanced example")
- Standalone/Custom example[‚Äã](#standalonecustom-example "Direct link to Standalone/Custom example")
- Features[‚Äã](#features "Direct link to Features")
- **Config Object**[‚Äã](#config-object "Direct link to config-object")
- **Properties**[‚Äã](#properties "Direct link to properties")
- **Methods**[‚Äã](#methods "Direct link to methods")
- FAQs[‚Äã](#faqs "Direct link to FAQs")

added in v<!-- -->3.3.0

ScrollTrigger enables anyone to create [jaw-dropping scroll-based animations](https://youtu.be/uYMYlipIReA) with minimal code. Infinitely flexible. Scrub, pin, snap, or just trigger anything scroll-related, even if it has nothing to do with animation.

[Introducing ScrollTrigger for GSAP](https://www.youtube.com/embed/X7IBa7vZjmo?si=P44VEzYVIObZe1rc)

Get ahead of the game by also learning about [the most common ScrollTrigger mistakes.](/resources/st-mistakes.md)

You don't need to put ScrollTriggers directly into animations (though that's probably the most common use case). Use the callbacks for anything...

* **Link any animation to a particular element** so that it only plays when that element is in the viewport. This improves performance and ensures that your beautiful animations actually get seen!
* ScrollTriggers can perform an actions on an animation (play, pause, resume, restart, reverse, complete, reset) when entering/leaving the defined area or link it directly to the scrollbar so that it acts like a **scrubber** (`scrub: true`).
* **Soften the link between the animation and the the scrollbar** so that takes a certain amount of time to "catch up", like `scrub: 1` would take one second to catch up.
* **Integrated with [ScrollSmoother](/docs/v3/Plugins/ScrollSmoother/.md)**, GreenSock's smooth-scrolling tool built on native scroll technology (members-only benefit).

* **Snap to certain points in the animation** based on velocity. In fact, you can `getVelocity()` of the scrolling anytime. Snap to the closest label in a timeline or progress value in an Array, or run your own custom function-based logic for snapping
* **Embed scroll triggers directly into any GSAP animation** (including timelines) or create **standalone instances** and tap into the rich callback system to do anything you want.
* **Advanced pinning** capabilities can lock an element in place between certain scroll positions. Padding is automatically added to push other elements down accordingly, so they catch up when the element gets unpinned (disable this with `pinSpacing: false`). You can even pin the same element multiple times at different points.
* **Incredible flexibility for defining scroll positions** - like *"start when the center of this element hits the center of the viewport, and end when the bottom of that other element hits the bottom of the viewport"*, use keywords (top, center, bottom, left, right), percentages, pixels, or even relative values like `"+=300px"`. Once you get the hang of the syntax, it's remarkably intuitive.
* Accommodates **vertical or horizontal scrolling**.
* **Rich callback system** including onEnter, onLeave, onEnterBack, onLeaveBack, onToggle, onUpdate, onScrubComplete, and onRefresh.
* **Automatically recalculates positions** when the window resizes.
* **Enable visual markers** during development to see exactly where the start/end/trigger points are. Customization options abound, like `markers: {startColor:"green", endColor:"red", fontSize:"12px"}`.
* **Toggle a CSS class**. For example, `toggleClass: "active"` adds the "active" class to the trigger element while the ScrollTrigger is active. You can affect other elements too.
* **Responsive** - use the [matchMedia()](/docs/v3/GSAP/gsap.matchMedia\(\).md) method to create different setups for various screen sizes using standard media queries.
* **Custom containers** - you don't need to use the viewport; define a custom scroller like a `<div>` instead.
* **Highly optimized for maximum performance** - scroll events are debounced, updates are synchronized with GSAP and screen refreshes, resize recalculations are throttled, etc.
* **No scroll-jacking**, so it can be combined with native technologies like CSS scroll snapping. If you want scroll-smoothing, you can use [ScrollSmoother](/docs/v3/Plugins/ScrollSmoother/.md) which integrates seamlessly with ScrollTrigger, or use the [scrollerProxy()](/docs/v3/Plugins/ScrollTrigger/static.scrollerProxy\(\).md) method to integrate with a 3rd party smooth-scrolling library.

`scrollTrigger` can be used as either a shorthand for the `trigger` (described below) or as a configuration object with any of the following properties:

Tween | Timeline - A GSAP [Tween](/docs/v3/GSAP/Tween.md) or [Timeline](/docs/v3/GSAP/Timeline.md) instance that should be controlled by the ScrollTrigger. Only one animation is controlled per ScrollTrigger, but you can wrap all your animations in a single Timeline (recommended) or create multiple ScrollTriggers if you prefer.

* #### anticipatePin[](#anticipatePin)

Number - If you pin large sections/panels you may notice what looks like a slight delay in pinning when you scroll quickly. That's caused by the fact that most modern browsers handle scroll repaints on a separate thread, so at the moment of pinning the browser may have already painted the pre-pinned content, making it visible for perhaps 1/60th of a second. The only way to counteract that is to have ScrollTrigger monitor the scroll velocity and anticipate the pin, applying it slightly early to avoid that flash of unpinned content. A value of `anticipatePin: 1` is typically fine, but you can reduce or increase that number to control how early it does the pinning. In many cases, however, you don't need any anticipatePin (the default is 0).

* #### containerAnimation[](#containerAnimation)

Tween | Timeline Easily trigger animations inside 'horizontally' scrolling sections that are controlled by vertical scrolling

A popular effect is to create horizontally-moving sections that are tied to vertical scrolling but since that horizontal movement isn't a native scroll, a regular ScrollTrigger can't know when, for example, an element comes into view horizontally, so you must tell ScrollTrigger to monitor the container's \[horizontal] animation to know when to trigger, like `containerAnimation: yourTween`.

[Horizontal "containerAnimation" - ScrollTrigger](https://codepen.io/GreenSock/embed/WNjaxKp?default-tab=result\&theme-id=41164)

**Caveats****:** the container's animation must use a linear ease ( `ease: "none"`). Also, pinning and snapping aren't available on containerAnimation-based ScrollTriggers. You should avoid animating the `trigger` element horizontally or if you do, just offset the start/end values according to how far you're animating the trigger.

[more information here](/blog/3-8/#containeranimation).

String | Number | Function - Determines the ending position of the ScrollTrigger.

It can be any of the following:

* **String** - Describes a place on the **endTrigger** (or trigger if one isn't defined) and a place on the **scroller** that must meet in order to end the ScrollTrigger. So, for example, `"bottom center"` means *"when the bottom of the endTrigger hits the center of the scroller"*. `"center 100px"` means *"when the center of the endTrigger hits 100px down from the top of the scroller"* (assuming vertical scroll). You can use keywords like "top", "bottom", "center" (or "left" and "right" if `horizontal: true`) or percentages like "80%" or pixel values like "100px". Percentages and pixels are always relative to the top/left of the element/viewport. You can also define a single relative value like "+=300" which means *"300px beyond where the start is"*, or "+=100%" means *"the height of the scroller beyond where the start is".&#x20;*`"max"` is a special keyword indicating the maximum scroll position.
  * **Number** - An exact scroll value, so `200` would trigger when the viewport/scroller scrolls by exactly 200 pixels.
  * **Function** - A function that gets called whenever the ScrollTrigger refreshes and calculates its positions (typically upon creation and any time the scroller resizes). It should return a String or Number, as described above. This makes it easy to dynamically calculate values. Like all callbacks, the function receives the ScrollTrigger instance itself as the only parameter.

This is a *static* position that is calculated when the ScrollTrigger is created and when the scroller is resized, based on where things are in the normal document flow. It is not constantly recalculated, so for example if you animate the trigger/endTrigger, it won't constantly update the start/end values accordingly because ScrollTrigger is highly optimized for performance. You can call `ScrollTrigger.refresh()` to force things to be recalculated. The default is `"bottom top"`. **clamp() the value** *(version 3.12+)*&#x57;rap your end value in `"clamp()"` to tell ScrollTrigger to always keep the calculated value between 0 (the top of the page) and the maximum scroll position so that it'll never leak outside the page bounds. Practically-speaking, this ensures that any trigger elements toward the very bottom of the page won't end with partially-scrubbed animations. For example, `end: "clamp(bottom top)"` - any normal string-based value can be inside the clamp(). Like `"clamp(20px 80%)"`. Here's a video explaining further:

* #### endTrigger[](#endTrigger)

String | Element - The element (or selector text for the element) whose position in the normal document flow is used for calculating where the ScrollTrigger ends. You don't need to define an `endTrigger` unless it's DIFFERENT than the `trigger` element because that's the default.

* #### fastScrollEnd[](#fastScrollEnd)

Boolean | Number - if `true`, it will force the current ScrollTrigger's animation to completion if you **leave** its trigger area faster than a certain velocity (default 2500px/s). This helps avoid overlapping animations when the user scrolls quickly. You can specify a number for the minimum velocity, so `fastScrollEnd: 3000` would only activate if the velocity exceeds 3000px/s. See a [demo here](https://codepen.io/GreenSock/pen/7d22c763b9edd0c0c48150ecd1c921c9).

* #### horizontal[](#horizontal)

Boolean - By default, it assumes your setup uses vertical scrolling but simply set `horizontal: true` if your setup uses horizontal scrolling instead.

String - An arbitrary unique identifier for the ScrollTrigger instance which can be used with `ScrollTrigger.getById()`. This id is also added to the markers.

* #### invalidateOnRefresh[](#invalidateOnRefresh)

Boolean - If `true`, the animation associated with the ScrollTrigger will have its [invalidate()](/docs/v3/GSAP/Tween/invalidate\(\).md) method called whenever a refresh() occurs (typically on resize). This flushes out any internally-recorded starting values.

* #### markers[](#markers)

Object | Boolean - Adds markers that are helpful during development/troubleshooting. `markers: true` adds them with the defaults (startColor: "green", endColor: "red", fontSize: "16px", fontWeight: "normal", indent: 0) but you can customize them by using an object like

Boolean - If `true`, the ScrollTrigger will kill() itself as soon as the end position is reached once. This causes it to stop listening for scroll events and it becomes eligible for garbage collection. This will only call onEnter a maximum of one time as well. It does **not** kill the associated animation. It's perfect for times when you only want an animation to play once when scrolling forward and never get reset or replayed. It also sets the toggleActions to "play none none none".

* #### onEnter[](#onEnter)

Function - A callback for when the scroll position moves forward past the "start" (typically when the trigger is scrolled into view). It receives one parameter - the ScrollTrigger instance itself which has properties/methods like `progress`, `direction`, `isActive`, and `getVelocity()`. Example:

* #### onEnterBack[](#onEnterBack)

Function - A callback for when the scroll position moves backward past the "end" (typically when the trigger is scrolled back into view). It receives one parameter - the ScrollTrigger instance itself which has properties/methods like `progress`, `direction`, `isActive`, and `getVelocity()`. Example:

* #### onLeave[](#onLeave)

Function - A callback for when the scroll position moves forward past the "end" (typically when the trigger is scrolled out of view). It receives one parameter - the ScrollTrigger instance itself which has properties/methods like `progress`, `direction`, `isActive`, and `getVelocity()`. Example:

* #### onLeaveBack[](#onLeaveBack)

Function - A callback for when the scroll position moves backward past the "start" (typically when the trigger is scrolled all the way backward past the start). It receives one parameter - the ScrollTrigger instance itself which has properties/methods like `progress`, `direction`, `isActive`, and `getVelocity()`. Example:

* #### onRefresh[](#onRefresh)

Function - A callback for when the a refresh occurs (typically a resize event) which forces the ScrollTrigger to recalculate all of its positioning. It receives one parameter - the ScrollTrigger instance itself which has properties/methods like `progress`, `direction`, `isActive`, and `getVelocity()`. Example:

* #### onUpdate[](#onUpdate)

Function - A callback that gets called every time the progress of the ScrollTrigger changes (meaning the scroll position changed). If you have a numeric `scrub` applied, keep in mind that the associated animation will keep scrubbing for a little while after the scroll position stops, so if your goal is to update something whenever the animation updates, it's best to apply an `onUpdate` to the animation itself rather than the ScrollTrigger. [See a demo here](https://codepen.io/osublake/pen/2152a28cffe2c2c0cca8a3e47f7b21c6?editors=0010).

The onUpdate callback receives one parameter - the ScrollTrigger instance itself which has properties/methods like `progress`, `direction`, `isActive`, and `getVelocity()`.

* #### onScrubComplete[](#onScrubComplete)

Function - A callback for when a numerical scrub has completed. This is only useful when a numerical scrub (like `scrub: 1`) is applied. The callback receives one parameter - the ScrollTrigger instance itself which has properties/methods like `progress`, `direction`, `isActive`, and `getVelocity()`. Example:

* #### onSnapComplete[](#onSnapComplete)

Function - A callback for when the snapping has completed. This only applies when there's a `snap` defined. A snap will be cancelled if/when the user (or anything else) interacts in any way with scrolling, so the onSnapComplete would not be triggered at all in that case. The callback receives one parameter - the ScrollTrigger instance itself which has properties/methods like `progress`, `direction`, `isActive`, and `getVelocity()`. Example:

* #### onToggle[](#onToggle)

Function - A callback for when the ScrollTrigger toggles from inactive to active **or** the other way around. This is typically when the scroll position moves past the "start" or "end" in either direction, but if it shoots past BOTH on the same tick, like if the user scrolls extremely fast, onToggle won't fire because the state hasn't changed. You can often use this one callback in the place of onEnter, onLeave, onEnterBack, and onLeaveBack by just checking the isActive property for toggling things. It receives one parameter - the ScrollTrigger instance itself which has properties/methods like `progress`, `direction`, `isActive`, and `getVelocity()`. Example:

Boolean | String | Element - An element (or selector text for the element) that should be pinned during the time that the ScrollTrigger is active, meaning it will appear to "stick" in its starting position while the rest of the content continues scrolling underneath it. Only one pinned element is allowed, but it can contain as many elements as you want. Setting `pin: true` will cause it to pin the `trigger` element.

**Warning** don't animate the pinned element itself because that will throw off the measurements (ScrollTrigger is highly optimized for performance and pre-calculates as much as possible). Instead, you could nest things such that you're animating only elements INSIDE the pinned element.

**Note:** if you are pinning something that is nested *inside* another element that *also* gets pinned, make sure you define a `pinnedContainer` so that ScrollTrigger knows to offset the start/end positions accordingly.

Using React? Make sure to do proper cleanup - read [this article](/resources/React.md).

* #### pinnedContainer[](#pinnedContainer)

Element | String - If your ScrollTrigger's `trigger`/`endTrigger` element is **INSIDE** an element that gets pinned by *another* ScrollTrigger (pretty uncommon), that would cause the start/end positions to be thrown off by however long that pin lasts, so you can set the `pinnedContainer` to that parent/container element to have ScrollTrigger calculate those offsets accordingly. Again, this is very rarely needed. **Important**: nested pinning is not supported, so this feature is only for non-pinning ScrollTriggers

* #### pinReparent[](#pinReparent)

Boolean - If `true`, the pinned element will be reparented to the `<body>` while it is actively pinned so that it can escape any ancestor containing blocks. If you notice odd behavior while pinning (like the pinned element suddenly shifting and then moving with the scroll), you probably have a `transform` or `will-change` on an ancestor element which [breaks](https://stackoverflow.com/questions/15194313/transform3d-not-working-with-position-fixed-children) `position: fixed` behavior (it's a browser thing, not ScrollTrigger). It's best to set up your project to avoid those because reparenting can be expensive, but `pinReparent: true` can bail you out if you can't avoid them. Only use this feature if you must.

**Warning:** if you have CSS rules that rely on specific nesting that'd be affected by the reparenting, they'll break. For example, a CSS rule like `.section .panel p {color: white}` wouldn't apply to the nested `<p>` anymore if you pin the `.panel` element with `pinReparent: true` because during the pin, it would no longer be inside the `<section>`, so make sure you write your CSS rules to accommodate the reparenting.

* #### pinSpacer[](#pinSpacer)

Element | String - normally ScrollTrigger creates a `<div>` internally to wrap around pinned elements but in the *extremely* rare scenario where you're loading an iframe into the pinned element, it can cause the iframe to refresh when ScrollTrigger refreshes (like on window resize), so this feature allows you to specify an element that should be used as the spacer instead of the internally-created one. That way, ScrollTrigger won't remove/add it during its refresh, keeping iframe content intact.

* #### pinSpacing[](#pinSpacing)

Boolean | String - By default, padding will be added to the bottom (or right for `horizontal: true`) to push other elements down so that when the pinned element gets unpinned, the following content catches up perfectly. Otherwise, things may scroll UNDER the pinned element. You can tell ScrollTrigger not to add any padding by setting `pinSpacing: false`.

If you'd rather it use margin instead of padding, you can set `pinSpacing: "margin"`.

**Note:** pinSpacing works in most cases, but it really depends on the way you set up your DOM and CSS. For example, if you pin something in a parent that has display: flex or position: absolute, the extra padding won't push other elements down/right so you may need to manually space things out. pinSpacing is just a convenience that works in most situations.

**Important**: if the container is `display: flex`, `pinSpacing` is set to `false` by default because that's typically what is desired since padding works differently in that context.

This video on pinning that's part of SnorklTV's [ScrollTrigger Express course](https://www.creativecodingclub.com/courses/scrolltrigger-express?ref=44f484) may help your understanding.

* #### pinType[](#pinType)

"fixed" | "transform" - by default, `position: fixed` is used for pinning only if the scroller is the `<body>`, otherwise transforms are used (because `position: fixed` won't work in various nested scenarios), but you can **force** ScrollTrigger to use `position: fixed` by setting `pinType: "fixed"`. Typically this isn't necessary or helpful. Beware that if you set the CSS property `will-change: transform`, browsers treat it just like having a transform applied, breaking `position: fixed` elements (this is unrelated to ScrollTrigger/GSAP).

* #### preventOverlaps[](#preventOverlaps)

Boolean | String - this feature activates as a ScrollTrigger is about to trigger an animation; it finds preceding scrollTrigger-based animations and forces those previous animations to their end state ‚Äì avoiding unsightly overlaps. if `true`, it will affect all preceding ScrollTriggers. You can use an arbitrary string to limit their effect to only others with a matching string. So `preventOverlaps: "group1"` would only affect other ScrollTriggers with `preventOverlaps: "group1"`. See a [demo here](https://codepen.io/GreenSock/pen/7d22c763b9edd0c0c48150ecd1c921c9).

* #### refreshPriority[](#refreshPriority)

number - it's **VERY** unlikely that you'd need to define a `refreshPriority` as long as you create your ScrollTriggers in the order they'd happen on the page (top-to-bottom or left-to-right)...which we *strongly* recommend doing. Otherwise, use `refreshPriority` to influence the order in which ScrollTriggers get refreshed to ensure that the pinning distance gets added to the start/end values of subsequent ScrollTriggers further down the page (that's why order matters). See the [sort()](/docs/v3/Plugins/ScrollTrigger/static.sort\(\).md) method for details. A ScrollTrigger with `refreshPriority: 1` will get refreshed earlier than one with `refreshPriority: 0` (the default). You're welcome to use negative numbers too, and you can assign the same number to multiple ScrollTriggers.

* #### scroller[](#scroller)

String | Element - By default, the `scroller` is the **viewport** itself, but if you'd like to add a ScrollTrigger to a scrollable `<div>`, for example, just define that as the scroller. You can use selector text like "#elementID" or the element itself.

* #### scrub[](#scrub)

Boolean | Number - Links the progress of the animation directly to the scrollbar so it acts like a scrubber. You can apply smoothing so that it takes a little time for the playhead to catch up with the scrollbar's position! It can be any of the following

* **Boolean** - `scrub: true` links the animation's progress directly to the ScrollTrigger's progress.
  * **Number** - The amount of time (in seconds) that the playhead should take to "catch up", so `scrub: 0.5` would cause the animation's playhead to take 0.5 seconds to catch up with the scrollbar's position. It's great for smoothing things out.

Number | Array | Function | Object | "labels" | "labelsDirectional" - Allows you to snap to certain progress values (between 0 and 1) after the user stops scrolling. So `snap: 0.1` would snap in increments of 0.1 (10%, 20%, 30%, etc.). `snap: [0, 0.1, 0.5, 0.8, 1]` would only let it come to rest on one of those specific progress values. It can be any of the following...

* **Number** - `snap: 0.1` snaps in increments of 0.1 (10%, 20%, 30%, etc.). If you have a certain number of sections, simply do `1 / (sections - 1)`.

* **Array** - `snap: [0, 0.1, 0.5, 0.8, 1]` snaps to the closest progress value in the Array in the direction of the last scroll (unless you set `directional: false`).

* **Function** - `snap: (value) => Math.round(value / 0.2) * 0.2` feeds the natural destination value (based on velocity) into the function and uses whatever is returned as the final progress value (in this case increments of 0.2), so you can run whatever logic you want. These values should always be between 0 and 1 indicating the progress of the animation, so 0.5 would be in the middle.

* **"labels"** - `snap: "labels"` snaps to the closest label in the timeline (animation must be a timeline with labels, of course)

* **"labelsDirectional"** - `snap: "labelsDirectional"` snaps to the closest label in the timeline that's in the direction of the most recent scroll. So if you scroll a little bit toward the next label (and stop), even if the current scroll position is technically closest to the current/last label, it'll snap to the next one in that direction instead. This can make it feel more intuitive for users.

* **Object** - Like `snap: {snapTo: "labels", duration: 0.3, delay: 0.1, ease: "power1.inOut"}`, fully customizable with any of the following properties (only "snapTo" is required):

* **snapTo** \[Number | Array | Function | "labels"] - determines the snapping logic (described above)
    * **delay** \[Number] - the delay (in seconds) between the last scroll event and the start of the snapping animation. Default is half the scrub amount (or 0.1 if scrub isn't a number)
    * **directional** \[Boolean] - by default (as of version 3.8.0), snapping is directional by default meaning it'll go in the direction the user last scrolled, but you can disable this by setting `directional: false`.
    * **duration** \[Number | Object] - the duration of the snapping animation (in seconds). `duration: 0.3` would always take 0.3 seconds, but you can also define a range as an object like `duration: {min: 0.2, max: 3}` to clamp it within the provided range, based on the velocity. That way, if the user stops scrolling close to a snapping point, it'd take less time to snap than if the natural stopping point is far from a snapping point.
    * **ease** \[String | Function] - the [ease](/docs/v3/Eases.md) that the snapping animation should use. The default is "power3".
    * **inertia** \[Boolean] - to tell ScrollTrigger **not** to factor in the inertia, set `inertia: false`
    * **onStart** \[Function] - a function that should be called when snapping starts
    * **onInterrupt** \[Function] - a function that should be called when snapping gets interrupted (like if the user starts scrolling mid-snap)
    * **onComplete** \[Function] - a function that should be called when snapping completes

* #### start[](#start)

String | Number | Function - Determines the starting position of the ScrollTrigger.

It can be any of the following:

* **String** - Describes a place on the **trigger** and a place on the **scroller** that must meet in order to start the ScrollTrigger. So, for example, `"top center"` means *"when the top of the trigger hits the center of the scroller"* (and the scroller is the viewport by default). `"bottom 80%"` means *"when the bottom of the trigger hits 80% down from the top of the viewport" (assuming vertical scroll). You can use keywords like "top", "bottom", "center" (or "left" and "right"* if `horizontal: true`) or percentages like "80%" or pixel values like "100px". Percentages and pixels are always relative to the top/left of the element/scroller. You can even use a complex relative value like `"top bottom-=100px"` which means *"when the top of the trigger hits 100px above the bottom of the viewport/scroller"*
  * **Number** - An exact scroll value, so `200` would trigger when the viewport/scroller scrolls by exactly 200 pixels.
  * **Function** - A function that gets called whenever the ScrollTrigger calculates its positions (typically upon creation and any time the scroller resizes). It should return a String or Number, as described above. This makes it easy to dynamically calculate values. Like all callbacks, the function receives the ScrollTrigger instance itself as the only parameter, so you can, for example, base the position on the previous ScrollTrigger's end like `start: self => self.previous().end`

This is a *static* position that is calculated when the ScrollTrigger is created and when the scroller is resized, based on where things are in the normal document flow. It is not constantly recalculated, so for example if you animate the trigger/endTrigger, it won't constantly update the start/end values accordingly because ScrollTrigger is highly optimized for performance. You can call `ScrollTrigger.refresh()` to force things to be recalculated. The default is `"top bottom"` unless `pin: true` is set in which case the default value is `"top top"`. **clamp() the value** *(version 3.12+)*&#x57;rap your start value in `"clamp()"` to tell ScrollTrigger to always keep the calculated value between 0 (the top of the page) and the maximum scroll position so that it'll never leak outside the page bounds. Practically-speaking, this ensures that any "above the fold" (triggers inside the viewport at the top of the page) won't start out with partially-scrubbed animations. For example, `start: "clamp(top bottom)"` - any normal string-based value can be inside the clamp(). Like `"clamp(20px 80%)"`. Here's a video explaining further:

* #### toggleActions[](#toggleActions)

String - Determines how the linked animation is controlled at the 4 distinct toggle places - **onEnter**, **onLeave**, **onEnterBack**, and **onLeaveBack**, in that order. The default is `play none none none`. So `toggleActions: "play pause resume reset"` will play the animation when entering, pause it when leaving, resume it when entering again backwards, and reset (rewind back to the beginning) when scrolling all the way back past the beginning. You can use any of the following keywords for each action: "play", "pause", "resume", "reset", "restart", "complete", "reverse", and "none".

* #### toggleClass[](#toggleClass)

String | Object - Adds/removes a class to an element (or multiple elements) when the ScrollTrigger toggles active/inactive. It can be either of the following:

* **String** - The name of the class to add to the `trigger` element, like `toggleClass: "active"`
  * **Object** - To toggle a class for elements other than just the trigger, use the object syntax like `toggleClass: {targets: ".my-selector", className: "active"}`. The "targets" can be selector text, a direct reference to an element, or an Array of elements.

Note that `toggleActions` don't apply to `toggleClass`. To have toggle class names in a different way, use the callback functions (onEnter, onLeave, onLeaveBack, and onEnterBack).

* #### trigger[](#trigger)

String | Element - The element (or selector text for the element) whose position in the normal document flow is used to calculate where the ScrollTrigger starts.

Looking for Smooth Scrolling?

GSAP's own [ScrollSmoother](/docs/v3/Plugins/ScrollSmoother/.md) tool is built on top of ScrollTrigger, so it is totally integrated and super easy to use. Built on native scroll technology, it avoids most of the accessibility issues that plague other smooth-scrolling libraries.

|                                                                                                 |                                                                                                                                                                                         |
| ----------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| #### [.animation](/docs/v3/Plugins/ScrollTrigger/animation.md) : Tween \| Timeline \| undefined | \[read-only] The [Tween](/docs/v3/GSAP/Tween.md) or [Timeline](/docs/v3/GSAP/Timeline.md) associated with the ScrollTrigger instance (if any).                                          |
| #### [.direction](/docs/v3/Plugins/ScrollTrigger/direction.md) : Number                         | \[read-only] Reflects the moment-by-moment direction of scrolling where `1` is forward and `-1` is backward.                                                                            |
| #### [.end](/docs/v3/Plugins/ScrollTrigger/end.md) : Number                                     | \[read-only] The ScrollTrigger's ending scroll position (numeric, in pixels).                                                                                                           |
| #### [.isActive](/docs/v3/Plugins/ScrollTrigger/isActive.md) : Boolean                          | \[read-only] Only `true` if the scroll position is between the start and end positions of the ScrollTrigger instance.                                                                   |
| #### [ScrollTrigger.isTouch](/docs/v3/Plugins/ScrollTrigger/static.isTouch.md) : Number         | A way to discern the touch capabilities of the current device - `0` is mouse/pointer only (no touch), `1` is touch-only, `2` accommodates both.                                         |
| #### [.pin](/docs/v3/Plugins/ScrollTrigger/pin.md) : Element \| undefined                       | \[read-only] The pin element (if one was defined). If selector text was used, like ".pin", the `pin` will be the element itself (not selector text)                                     |
| #### [progress](/docs/v3/Plugins/ScrollTrigger/progress.md) : Number                            | \[read-only] The overall progress of the ScrollTrigger instance where 0 is at the start, 0.5 is in the middle, and 1 is at the end.                                                     |
| #### [scroller](/docs/v3/Plugins/ScrollTrigger/scroller.md) : Element \| window                 | \[read-only] The scroller element (or window) associated with the ScrollTrigger. It's the thing whose scrollbar is linked to the ScrollTrigger. By default, it's the window (viewport). |
| #### [start](/docs/v3/Plugins/ScrollTrigger/start.md) : Number                                  | \[read-only] The ScrollTrigger's starting scroll position (numeric, in pixels).                                                                                                         |
| #### [.trigger](/docs/v3/Plugins/ScrollTrigger/trigger.md) : Element \| undefined               | \[read-only] The trigger element (if one was defined). If selector text was used, like ".trigger", the `trigger` will be the element itself (not selector text)                         |
| #### [.vars](/docs/v3/Plugins/ScrollTrigger/vars.md) : Object                                   | \[read-only] The vars configuration object used to create the ScrollTrigger instance                                                                                                    |

|                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| #### [.disable](/docs/v3/Plugins/ScrollTrigger/disable\(\).md)( revert:boolean, allowAnimation:Boolean )                                                                                            | Disables the ScrollTrigger instance, immediately unpinning and restoring any pin-related changes made to the DOM by ScrollTrigger.                                                                                                                                                                                                                                                                                                         |
| #### [.enable](/docs/v3/Plugins/ScrollTrigger/enable\(\).md)( reset:Boolean )                                                                                                                       | Enables the ScrollTrigger instance                                                                                                                                                                                                                                                                                                                                                                                                         |
| #### [.getTween](/docs/v3/Plugins/ScrollTrigger/getTween\(\).md)( snap:Boolean ) : Tween                                                                                                            | Returns the `scrub` tween (default) or the snapping tween (`getTween(true)`)                                                                                                                                                                                                                                                                                                                                                               |
| #### [.getVelocity](/docs/v3/Plugins/ScrollTrigger/getVelocity\(\).md)( ) : Number                                                                                                                  | Gets the scroll velocity in pixels-per-second                                                                                                                                                                                                                                                                                                                                                                                              |
| #### [.kill](/docs/v3/Plugins/ScrollTrigger/kill\(\).md)( revert:boolean, allowAnimation:Boolean )                                                                                                  | Kills the ScrollTrigger instance, immediately unpinning and restoring any pin-related changes made to the DOM by ScrollTrigger and removing all scroll-related listeners, etc. so that the instance is eligible for garbage collection. If you only want to temporarily disable the ScrollTrigger, use the [disable()](/docs/v3/Plugins/ScrollTrigger/disable\(\).md) method instead.                                                      |
| #### [.labelToScroll](/docs/v3/Plugins/ScrollTrigger/labelToScroll\(\).md)( label:String ) : Number                                                                                                 | Converts a timeline label into the associated scroll position (only applicable to ScrollTriggers whose "animation" is a timeline)                                                                                                                                                                                                                                                                                                          |
| #### [.next](/docs/v3/Plugins/ScrollTrigger/next\(\).md)( ) : ScrollTrigger instance                                                                                                                | Returns the next ScrollTrigger in the refresh order.                                                                                                                                                                                                                                                                                                                                                                                       |
| #### [.previous](/docs/v3/Plugins/ScrollTrigger/previous\(\).md)( ) : ScrollTrigger instance                                                                                                        | Returns the previous ScrollTrigger in the refresh order.                                                                                                                                                                                                                                                                                                                                                                                   |
| #### [.refresh](/docs/v3/Plugins/ScrollTrigger/refresh\(\).md)()                                                                                                                                    | Forces the ScrollTrigger instance to re-calculate its start and end values (the scroll positions where it'll be activated).                                                                                                                                                                                                                                                                                                                |
| #### [.scroll](/docs/v3/Plugins/ScrollTrigger/scroll\(\).md)( position:Number ) : Number \| null                                                                                                    | Gets/Sets the scroll position of the associated scroller (numeric).                                                                                                                                                                                                                                                                                                                                                                        |
| #### [ScrollTrigger.addEventListener](/docs/v3/Plugins/ScrollTrigger/static.addEventListener\(\).md)( type:String, callback:Function ) : null                                                       | Add a listener for any of the following events: "scrollStart", "scrollEnd", "refreshInit", "revert", "matchMedia", or"refresh" which get dispatched globally when **any** such ScrollTrigger-related event occurs (it is not tied to a particular instance).                                                                                                                                                                               |
| #### [ScrollTrigger.batch](/docs/v3/Plugins/ScrollTrigger/static.batch\(\).md)( triggers:Selector text \| Array, vars:Object ) : Array                                                              | Creates a coordinated group of ScrollTriggers (one for each target element) that batch their callbacks (onEnter, onLeave, etc.) within a certain interval, delivering a neat Array so that you can easily do something like create a staggered animation of all the elements that enter the viewport around the same time.                                                                                                                 |
| #### [ScrollTrigger.clearMatchMedia](/docs/v3/Plugins/ScrollTrigger/static.clearMatchMedia\(\).md)( query:String )                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| #### [ScrollTrigger.clearScrollMemory](/docs/v3/Plugins/ScrollTrigger/static.clearScrollMemory\(\).md)( scrollRestoration:String )                                                                  | Clears any recorded scroll positions in ScrollTrigger so that no scroll positions get restored after a refresh(). Normally, this isn't necessary but in some frameworks that handle routing in unconventional ways, it can be useful.                                                                                                                                                                                                      |
| #### [ScrollTrigger.config](/docs/v3/Plugins/ScrollTrigger/static.config\(\).md)( vars:Object )                                                                                                     | Allows you to configure certain global behaviors of ScrollTrigger like `limitCallbacks`                                                                                                                                                                                                                                                                                                                                                    |
| #### [ScrollTrigger.create](/docs/v3/Plugins/ScrollTrigger/static.create\(\).md)( vars:Object ) : ScrollTrigger                                                                                     | Creates a standalone ScrollTrigger instance                                                                                                                                                                                                                                                                                                                                                                                                |
| #### [ScrollTrigger.defaults](/docs/v3/Plugins/ScrollTrigger/static.defaults\(\).md)( config:Object ) : null                                                                                        | Allows you to set the default values that apply to every ScrollTrigger upon creation, like `toggleActions`, `markers`, etc.                                                                                                                                                                                                                                                                                                                |
| #### [ScrollTrigger.getAll](/docs/v3/Plugins/ScrollTrigger/static.getAll\(\).md)( ) : Array                                                                                                         | Returns an Array of all ScrollTrigger instances                                                                                                                                                                                                                                                                                                                                                                                            |
| #### [ScrollTrigger.getById](/docs/v3/Plugins/ScrollTrigger/static.getById\(\).md)( id:String ) : ScrollTrigger                                                                                     | Returns the ScrollTrigger that was assigned the corresponding `id`                                                                                                                                                                                                                                                                                                                                                                         |
| #### [ScrollTrigger.isInViewport](/docs/v3/Plugins/ScrollTrigger/static.isInViewport\(\).md)( Element:Element \| String, proportion:Number, horizontal:Boolean ) : Boolean                          | Returns `true` if the element is in the viewport. You can optionally specify a minimum proportion, like `ScrollTrigger.isInViewport(element, 0.2)` would only return `true` if at least 20% of the element is in the viewport.                                                                                                                                                                                                             |
| #### [ScrollTrigger.isScrolling](/docs/v3/Plugins/ScrollTrigger/static.isScrolling\(\).md)( ) : Boolean                                                                                             | Indicates whether or not any ScrollTrigger-related scroller is in the process of scrolling.                                                                                                                                                                                                                                                                                                                                                |
| #### [ScrollTrigger.killAll](/docs/v3/Plugins/ScrollTrigger/static.killAll\(\).md)( ) ;                                                                                                             | Immediately calls `kill()` on **all** ScrollTriggers (except the main ScrollSmoother one if it exists).                                                                                                                                                                                                                                                                                                                                    |
| #### [ScrollTrigger.matchMedia](/docs/v3/Plugins/ScrollTrigger/static.matchMedia\(\).md)( vars:Object )                                                                                             | \[DEPRECATED] Allows you to set up ScrollTriggers that only apply to certain viewport sizes (using media queries).                                                                                                                                                                                                                                                                                                                         |
| #### [ScrollTrigger.maxScroll](/docs/v3/Plugins/ScrollTrigger/static.maxScroll\(\).md)( scroller:Element \| window, horizontal:Boolean ) : Number                                                   | A utility function for getting the maximum scroll value for a particular element/scroller. For example, if the element/scroller is 500px tall and contains 800px of content, maxScroll() would return 300.                                                                                                                                                                                                                                 |
| #### [ScrollTrigger.normalizeScroll](/docs/v3/Plugins/ScrollTrigger/static.normalizeScroll\(\).md)( normalize:Boolean \| Object ) : ScrollObserver \| null                                          | Forces scrolling to be done on the JavaScript thread, ensuring screen updates are synchronized and the address bar doesn't show/hide on \[most] mobile devices.                                                                                                                                                                                                                                                                            |
| #### [ScrollTrigger.observe](/docs/v3/Plugins/ScrollTrigger/static.observe\(\).md)( config:Object ) : Observer                                                                                      | Super-flexible, unified way to sense meaningful events across all (touch/mouse/pointer) devices without wrestling with all the implementation details. Trigger simple callbacks like onUp, onDown, onLeft, onRight, onChange, onHover, onDrag, etc. Functionally identical to [Observer.create()](/docs/v3/Plugins/Observer/static.create\(\).md)                                                                                          |
| #### [ScrollTrigger.positionInViewport](/docs/v3/Plugins/ScrollTrigger/static.positionInViewport\(\).md)( element:Element \| String, referencePoint:String \| Number, horizontal:Boolean ) : Number | Returns a normalized value representing the element's position in relation to the viewport where 0 is at the top of the viewport, 0.5 is in the center, and 1 is at the bottom. So, for example, if the top of the element is 80% down from the top of the viewport, the following code would return 0.8: `ScrollTrigger.positionInViewport(element, "top");`                                                                              |
| #### [ScrollTrigger.refresh](/docs/v3/Plugins/ScrollTrigger/static.refresh\(\).md)( safe:Boolean )                                                                                                  | Recalculates the positioning of all of the ScrollTriggers on the page; this typically happens automatically when the window/scroller resizes but you can force it by calling `ScrollTrigger.refresh()`                                                                                                                                                                                                                                     |
| #### [ScrollTrigger.removeEventListener](/docs/v3/Plugins/ScrollTrigger/static.removeEventListener\(\).md)( type:String, callback:Function ) : null                                                 | Removes an event listener                                                                                                                                                                                                                                                                                                                                                                                                                  |
| #### [ScrollTrigger.saveStyles](/docs/v3/Plugins/ScrollTrigger/static.saveStyles\(\).md)( targets:String \| Element \| Array )                                                                      | Internally records the current inline CSS styles for the given elements so that when ScrollTrigger reverts (typically for a refresh() or matchMedia() change) those elements will be reverted accordingly even if they had animations that added/changed inline styles. Think of it like taking a snapshot of the inline CSS and telling ScrollTrigger "re-apply these inline styles only and dump all others when you revert internally". |
| #### [ScrollTrigger.scrollerProxy](/docs/v3/Plugins/ScrollTrigger/static.scrollerProxy\(\).md)( scroller:String \| Element, vars:Object )                                                           | Allows you to hijack the `scrollTop` and/or `scrollLeft` getters/setters for a particular scroller element so that you can implement things like smooth scrolling or other custom effects.                                                                                                                                                                                                                                                 |
| #### [ScrollTrigger.snapDirectional](/docs/v3/Plugins/ScrollTrigger/static.snapDirectional\(\).md)( incrementOrArray:Number \| Array ) : Function                                                   | Returns a snapping function to which you can feed any value to snap, along with a direction where `1` is forward (greater than) and `-1` is backward (less than).                                                                                                                                                                                                                                                                          |
| #### [ScrollTrigger.sort](/docs/v3/Plugins/ScrollTrigger/static.sort\(\).md)( func:Function ) : Array                                                                                               | Sorts the internal Array of ScrollTrigger instances to control the order in which they [refresh()](/docs/v3/Plugins/ScrollTrigger/static.refresh\(\).md) (calculate their start/end values).                                                                                                                                                                                                                                               |
| #### [ScrollTrigger.update](/docs/v3/Plugins/ScrollTrigger/static.update\(\).md)( )                                                                                                                 | Checks where the scrollbar is and updates all ScrollTrigger instances' `progress` and `direction` values accordingly, controls the animation (if necessary) and fires the appropriate callbacks.                                                                                                                                                                                                                                           |

ScrollTrigger does **NOT** constantly watch every element and check its positioning in the viewport on each tick. We're obsessed with performance and that'd be far too costly. Instead, ScrollTrigger does the processing up-front to figure out where the start/end points are *in the natural document flow*. In other words, *"this ScrollTrigger will be active when the scrollbar is between \_\_\_ and \_\_\_\_"*. Then, it debounces the "scroll" events and only updates things on the next requestAnimationFrame, perfectly synced with GSAP and screen refreshes. It **ONLY** watches the scroll position. **Period.** That means it's ***FAST***.

ScrollTrigger automatically listens for viewport/scroller "resize" events and recalculates all the start/end positions accordingly (`onRefresh`). In fact, since resizing/refreshing is CPU-intensive, it waits until there's a 200ms gap in resize events before starting its work. Yeah, we looked for every opportunity to maximize performance.

[IntersectionObserver](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API) is a native feature in most modern browsers that's different in the following ways:

* It constantly "watches" elements to sense when they enter/leave regardless of scrolling.
* It's **not** helpful for tracking an element's position between two points, like for scrubbing an animation accordingly.
* It does let you watch multiple elements and have a single callback triggered that could loop through and fire a staggered animation on just the elements that entered, for example.

ScrollTrigger does not use IntersectionObserver under the hood because it lacks the necessary functionality and compatibility. You can certainly use IntersectionObserver and ScrollTrigger together.

* The pinned element gets immediately wrapped in a `<div>` with a **fixed** width/height to match. A class of "pin-spacer" is added to that wrapper. Think of it like a proxy element that props open the space where the pinned element was in the DOM so that when it flips to `position: fixed` things don't collapse.
* By default, padding will be added to the bottom (or right for horizontal: true) of the pin-spacer so that \[in most cases] things get pushed further down/right. When the pinned element gets unpinned, the content below/right will have caught up. So if, for example, the pinned element stays pinned for 300px, there would be padding of 300px added.

This video on pinning that's part of SnorklTV's [ScrollTrigger Express course](https://www.creativecodingclub.com/courses/scrolltrigger-express?ref=44f484) may help your understanding.

* When the ScrollTrigger is active (when the scroll position is between the start and end), it sets the pinned element to `position: fixed` and positions it with fixed top/left/width/height values...unless the scroller isn't the viewport in which case it never uses `position: fixed` because that'd break sub-scrolling, so it uses pure transforms. If `pinReparent` is set to `true` (we recommend avoiding that if you can), the pinned element will get reparented to the `<body>` and styles will be moved inline to ensure appearance is maintained.
* When the ScrollTrigger becomes inactive, the pinned element reverts to its original `position` value and a **transform** is applied to place it correctly.
* When the window/scroller gets resized, all ScrollTriggers re-calculate their start/end positions (`onRefresh`). As a part of that process, the pin-spacer is removed from the DOM and the pinned element is swapped back in so that measurements are accurate with the original CSS. Then the pin-spacer is swapped back in as a wrapper.

Why not just use transforms and avoid `position: fixed`? Many browsers don't render consistently using that technique. There are annoying visual glitches due to the fact that scroll repaints are handled on a different thread in most modern browsers. Surprisingly, `position: fixed` seemed to deliver better performance overall. And performance is EXTREMELY important for scrolling.

If you have a ScrollTrigger `scrub: true` and that ScrollTrigger has a timeline or tween animation associated with it, the durations of tweens within that animation serve as proportions for the total amount of distance that the tween will play. The proportion of how much distance it's animated between is in regards to the total duration of the animation. It's easiest to understand with an example:

Say you have a timeline with three sequenced tweens: a 1 second tween, a 3 second tween, and then another 1 second tween. And the ScrollTrigger applied to it will animate for a full viewport height's distance (perhaps the trigger uses the values of `start: "center bottom"` and `end: "center top"`).

If `scrub: true` (or a number) is applied, then the first tween will be animated between when the center of the trigger element is between the 100% mark (from the top; the bottom of the viewport) and the 80% mark (from the top) of the viewport. The second tween will fire when the center of the element is at the 80% mark until the 20% mark. And the third tween will fire when the center of the element is between the 20% mark and the 0% mark. This is because the total duration of the timeline is 5 seconds. So ‚Öï is 20% and ‚Öó is 60%.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/yLegBwO?default-tab=result\&theme-id=41164)

If you change the duration of all the tweens to the same number, say 1, then the percentages would all be equal: 100% -> 66%, 66% -> 33%, 33% -> 0%. This is because the total duration is 3, so ‚Öì is 33%.

In other words, the duration values don't matter as much as the proportions of the duration of each tween compared to the total time of the timeline.

If you want to make the animation take a longer distance of scroll to complete, affect the distance from start to end longer. For example you could set `end: "+=4000"` to make it take a lot of scrolling to complete.

See the [installation page](/docs/v3/Installation) for all the options (CDN, NPM, download, etc.) where there's even an interactive helper that provides the necessary code. Easy peasy. Don't forget to [register undefined](/docs/v3/GSAP/gsap.registerPlugin\(\).md) like this in your project:

No, you must load/import it separately

Your build tool is probably dropping the plugin when [tree shaking](https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking) and you forgot to [register undefined](/docs/v3/GSAP/gsap.registerPlugin\(\).md) (which protects it from tree shaking). Just register the plugin like this:

No, it's perfectly fine. It doesn't help anything, nor does it hurt.

See the [installation page](/docs/v3/Installation) for all the options (CDN, NPM, download, etc.) where there's even an interactive helper that provides the necessary code. Easy peasy. Don't forget to [register ScrollTrigger](/docs/v3/GSAP/gsap.registerPlugin\(\).md) like this in your project:

No, you must load/import it separately

Your build tool is probably dropping the plugin when [tree shaking](https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking) and you forgot to [register ScrollTrigger](/docs/v3/GSAP/gsap.registerPlugin\(\).md) (which protects it from tree shaking). Just register the plugin like this:

No, it's perfectly fine. It doesn't help anything, nor does it hurt.

Check out the full collection of [Scroll animation demos](https://codepen.io/collection/bNPYOw) on CodePen.

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(ScrollTrigger)
```

Example 2 (unknown):
```unknown
gsap.to('.box', {
	scrollTrigger: '.box', // start animation when ".box" enters the viewport
	x: 500
});
```

Example 3 (unknown):
```unknown
gsap.to('.box', {
	scrollTrigger: '.box', // start the animation when ".box" enters the viewport (once)
	x: 500
});
```

Example 4 (unknown):
```unknown
let tl = gsap.timeline({
	// yes, we can add it to an entire timeline!
	scrollTrigger: {
		trigger: '.container',
		pin: true, // pin the trigger element while active
		start: 'top top', // when the top of the trigger hits the top of the viewport
		end: '+=500', // end after scrolling 500px beyond the start
		scrub: 1, // smooth scrubbing, takes 1 second to "catch up" to the scrollbar
		snap: {
			snapTo: 'labels', // snap to the closest label in the timeline
			duration: { min: 0.2, max: 3 }, // the snap animation should be at least 0.2 seconds, but no more than 3 seconds (determined by velocity)
			delay: 0.2, // wait 0.2 seconds from the last scroll event before doing the snapping
			ease: 'power1.inOut' // the ease of the snap animation ("power3" by default)
		}
	}
});

// add animations and labels to the timeline
tl.addLabel('start')
	.from('.box p', { scale: 0.3, rotation: 45, autoAlpha: 0 })
	.addLabel('color')
	.from('.box', { backgroundColor: '#28a92b' })
	.addLabel('spin')
	.to('.box', { rotation: 360 })
	.addLabel('end');
```

---

## Find a nested label's time

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/getNestedLabelTime.md

Labels are timeline-specific, so you can't tell a timeline to move its playhead to a label that exists in a **nested** timeline. So here's a helper function that lets you find a nested label and calculate where that lines up on the \[parent/ancestor] timeline:

So here's an example usage: `tl.seek(getNestedLabelTime(tl, "someNestedLabel"))`

**Examples:**

Example 1 (unknown):
```unknown
function getNestedLabelTime(timeline, label) {
  let children = timeline.getChildren(true, false, true),
    i = children.length,
    tl,
    time;
  while (i--) {
    if (label in children[i].labels) {
      tl = children[i];
      time = tl.labels[label];
      break;
    }
  }
  if (tl) {
    while (tl !== timeline) {
      time = tl.startTime() + time / tl.timeScale();
      tl = tl.parent;
    }
  }
  return time;
}
```

---

## .progress

**URL:** https://gsap.com/docs/v3/Plugins/ScrollSmoother/progress.md

**Contents:**
  - .progress : Number
  - Details[‚Äã](#details "Direct link to Details")

The progress value of the overall page scroll where 0 is at the very top and 1 is at the very bottom and 0.5 is halfway scrolled. This value will animate during the smooth scrolling and end when the `onStop` fires.

The progress value of the overall page scroll where 0 is at the very top and 1 is at the very bottom and 0.5 is halfway scrolled. This value will animate during the smooth scrolling and end when the `onStop` fires.

**Examples:**

Example 1 (unknown):
```unknown
ScrollSmoother.create({
  smooth: 1,
  onUpdate: (self) => console.log("progress", self.progress),
});
```

---

## Align transformOrigin of two elements smoothly

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/alignOrigins.md

Instantly change the `transformOrigin` of one element to align with another element's `transformOrigin` without a jump (requires [MotionPathPlugin](/docs/v3/Plugins/MotionPathPlugin/static.convertCoordinates\(\).md)):

**Examples:**

Example 1 (unknown):
```unknown
// fromElement is the one whose transformOrigin should change to match up with the toElement's transformOrigin.
function alignOrigins(fromElement, toElement) {
  let [fromEl, toEl] = gsap.utils.toArray([fromElement, toElement]),
    a = window.getComputedStyle(toEl).transformOrigin.split(" "),
    newOrigin = MotionPathPlugin.convertCoordinates(toEl, fromEl, {
      x: parseFloat(a[0]),
      y: parseFloat(a[1]),
    }),
    bounds1 = fromEl.getBoundingClientRect(),
    bounds2;
  gsap.set(fromEl, {

    transformOrigin: newOrigin.x + "px " + newOrigin.y + "px",
  });
  bounds2 = fromEl.getBoundingClientRect();
  gsap.set(fromEl, {
    x: "+=" + (bounds1.left - bounds2.left),
    y: "+=" + (bounds1.top - bounds2.top),
  });
}
```

---

## CSS

**URL:** https://gsap.com/docs/v3/GSAP/CorePlugins/CSS.md

**Contents:**
- CSS properties[‚Äã](#css-properties "Direct link to CSS properties")
  - Non-animatable properties...[‚Äã](#non-animatable-properties "Direct link to Non-animatable properties...")
- Transforms[‚Äã](#transforms "Direct link to Transforms")
  - Quick reference[‚Äã](#quick-reference "Direct link to Quick reference")
  - Complex strings[‚Äã](#complex-strings "Direct link to Complex strings")
  - Units[‚Äã](#units "Direct link to Units")
- 3D Transforms[‚Äã](#3d-transforms "Direct link to 3D Transforms")
  - force3D[‚Äã](#force3d "Direct link to force3D")
- transformOrigin[‚Äã](#transformorigin "Direct link to transformOrigin")
- SVG[‚Äã](#svg "Direct link to SVG")

**GSAP can animate pretty much ANY CSS-related property** of DOM elements. Commonly animated properties are transforms, opacity and colors. But GSAP can handle anything you throw at it. There is no official list as it would be far too long, but **if in doubt - try it out!**

GSAP can animate any [animatable CSS property](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties), and many that aren't *officially* animatable using CSS.

Hyphenated CSS properties

It's important to note that hyphenated-names become CamelCaseNames. So instead of "font-size", you'd use "fontSize". "background-color" will be "backgroundColor".

If you define a property that is non-animatable ‚Äî like `position: "absolute"` or `borderStyle: "solid"` ‚Äî GSAP will instantly apply the property for you . These non-tweenable properties will be set at the beginning of the tween (except `display: "none"` which will be applied at the end of the tween for obvious reasons).

What's a 'non-animatable property'?

In order for a property to be animatable, the start, end and in between values must be valid. If you animate between `rotation: 0` and `rotation: 360`, there are valid numerical values in between. Following this logic, you can't animate between two different background images as there is no valid CSS for **a little bit of that image and a tiny bit of that one**. background-image is a binary property, there is either an image or there isn't an image, there's no inbetween to animate.

Some other "impossible properties" are **layout** properties. These are far too complex for a normal tween - but will be handled *magically* by GSAP's [FLIP plugin](/docs/v3/Plugins/Flip/.md)

GSAP provides built in aliases for transforms which are cross browser friendly, more performant and more reliable than animating the transform string.

In regular CSS, the order that you list the transforms matters but GSAP always applies them in the same order for consistency: translation (`x`, `y`, `z`), then `scale`, then `rotationX`, then `rotationY`, then `skew`, then `rotation` (same as `rotationZ`).

Deep Dive - Why use shorthand transforms?

When you define a transform as a string, like `"transform: translateX(50px)"`, GSAP applies it to the element and then reads back and parses the `matrix()` or `matrix3d()` that the browser creates. This process is necessary because the string can contain any number or order of transform values, such as `"translateX(50px) rotate(40deg) scale(0.5,0.5) translateY(100px) rotate(30deg)"`. This approach involves a lot of extra work. Additionally, according to the CSS spec, the order of operation matters which can lead to unexpected results for people unfamiliar with CSS transforms.

When you define properties using the shorthand like `x:50` instead of `"transform: translateX(50px)"`, GSAP can directly handle that one value without the need for extra calculations. In short, using GSAP for transforms offers performance gains, optimizations for speed and an intuitive and consistent order-of-operation.

We strongly recommend using GSAP's built-in aliases for transforms unless you specifically require a non-standard order-of-operation, which is rare.

Here's a list of the shorthand transforms and some other commonly used properties.

| GSAP                          | Description or equivalent CSS       |
| ----------------------------- | ----------------------------------- |
| x: 100                        | transform: translateX(100px)        |
| y: 100                        | transform: translateY(100px)        |
| xPercent: 50                  | transform: translateX(50%)          |
| yPercent: 50                  | transform: translateY(50%)          |
| scale: 2                      | transform: scale(2)                 |
| scaleX: 2                     | transform: scaleX(2)                |
| scaleY: 2                     | transform: scaleY(2)                |
| rotation: 90                  | transform: rotate(90deg)            |
| rotation: "1.25rad"           | transform: rotate(1.25rad)          |
| skew: 30                      | transform: skew(30deg)              |
| skewX: 30                     | transform: skewX(30deg)             |
| skewY: "1.23rad"              | transform: skewY(1.23rad)           |
| transformOrigin: "center 40%" | transform-origin: center 40%        |
| opacity: 0                    | adjust the elements opacity         |
| autoAlpha: 0                  | shorthand for opacity & visibility  |
| duration: 1                   | animation-duration: 1s              |
| repeat: -1                    | animation-iteration-count: infinite |
| repeat: 2                     | animation-iteration-count: 3        |
| delay: 2                      | animation-delay: 2s                 |
| yoyo: true                    | animation-direction: alternate      |

Notes about transforms

* To do percentage-based translation use `xPercent` and `yPercent` instead of `x` or `y` which are typically pixel based. This allows you to combine px and percentage transformations.
* You can use scale as a shortcut to control both the `scaleX` and `scaleY` properties identically.
* You can define relative values, like `rotation: "+=30"`.
* The order in which you declare the transform properties makes no difference.
* GSAP has nothing to do with the rendering quality of the element in the browser. Some browsers seem to render transformed elements beautifully while others don't handle anti-aliasing as well.
* Percentage-based x/y translations also work on SVG elements.

GSAP can animate complex values like `boxShadow: "0px 0px 20px 20px red"`, `borderRadius: "50% 50%"`, and `border: "5px solid rgb(0,255,0)"`. When necessary, it attempts to figure out if the property needs a vendor prefix and applies it accordingly.

GSAP has sensible defaults for units. If you want to set the x property, you can say `x: 24` instead of x: "24px" because GSAP uses pixels as the default unit for x. If you want to specify a particular unit you can append the unit value on the end and wrap the value in a string.

If the unit of measurement that's currently used doesn't match the current one, GSAP will convert them for you. e.g. Tweening an element's width from "50%" to "200px".

You can animate 3D properties like `rotationX`, `rotationY`, `rotationZ` (identical to regular `rotation`), `z`, `perspective`, and `transformPerspective` in all modern browsers (see [Can I Use](//caniuse.com/transforms3d) for details about browser support for 3D transforms). You can animate 3D transform properties and 2D properties together intuitively:

To get your elements to have a true 3D visual perspective applied, you must either set the perspective property of the parent element or set the special `transformPerspective` of the element itself

The `transformPerspective` is like adding a `perspective()` directly inside the CSS `transform` style, like: `transform: perspective(500px) rotateX(45deg)` which only applies to that specific element. Common values range from around 200 to 1000, the lower the number the stronger the perspective distortion. If you want a group of elements to share a common perspective (the same vanishing point), you should set the regular `perspective` *property* on the parent/container of those elements.

For more information about perspective, see [this article](//3dtransforms.desandro.com/perspective).

Notes about 3D transforms

* In browsers that don't support 3D transforms, they'll be ignored. For example, rotationX may not work, but rotation would. See [can I use](https://caniuse.com/transforms3d) for a chart of which browser versions support 3D transforms.
* All transforms are cached, so you can tween individual properties without worrying that they'll be lost. You don't need to define all of the transform properties on every tween - only the ones you want to animate. You can read the transform-related values (or any property) anytime using the method. If you'd like to clear those values (including the transform applied to the inline style of the element), you can use `clearProps: "transform"`. If you'd like to force GSAP to re-parse the transform data from the CSS (rather than use the data it had recorded from previous tweens), you can pass `parseTransform: true` into the `config` object.
* GSAP has nothing to do with the rendering quality of the element in the browser. Some browsers seem to render transformed elements beautifully while others don't handle anti-aliasing as well.
* To learn more about CSS 3D transforms, see [this article](https://www.smashingmagazine.com/2012/01/adventures-in-the-third-dimension-css-3-d-transforms/)
* Opera mini does not support 3D transforms

`force3D` defaults to `"auto"` mode which means transforms are automatically optimized for speed by using `translate3d()` instead of `translate()`. This typically results in the browser putting that element onto its own compositor layer, making animation updates more efficient. In `"auto"` mode, GSAP will automatically switch back to 2D when the tween is done (if 3D isn't necessary) to free up more GPU memory. If you'd prefer to keep it in 3D mode, you can set `force3D: true`. Or, to stay in 2D mode whenever possible, set `force3D: false`. See [Myth Busting CSS Animations vs JavaScript"](//css-tricks.com/myth-busting-css-animations-vs-javascript/) for more details about performance.

Sets the origin around which all transforms (2D and/or 3D) occur. By default, it is in the center of the element (`"50% 50%"`). You can define the values using the keywords `"top"`, `"left"`, `"right"`, or `"bottom"` or you can use percentages (bottom right corner would be `"100% 100%"`) or pixels. If, for example, you want an object to spin around its top left corner you can do this:

The first value in the quotes corresponds to the x-axis and the second corresponds to the y-axis, so to make the object transform around exactly 50px in from its left edge and 20px from its top edge, you could do:

This even works with SVG elements!

You can define a transformOrigin as a **3D value** by adding a 3rd number, like to rotate around the y-axis from a point that is offset 400px in the distance, you could do:

GSAP does make `transformOrigin` work on SVG elements consistently across browsers. But keep in mind that SVG elements don't officially support 3D transforms according to the spec.

**Only for SVG elements** Works exactly like `transformOrigin` but it uses the SVG's global coordinate space instead of the element's local coordinate space. This can be very useful if, for example, you want to make a bunch of SVG elements rotate around a common point. You can either define an `svgOrigin` or a `transformOrigin`, not both (for obvious reasons). So you can do `gsap.to(svgElement, {duration: 1, rotation: 270, svgOrigin: "250 100"})` if you'd like to rotate `svgElement` as though its origin is at x: 250, y: 100 in the SVG canvas's global coordinates. Units are not required. It also records the value in a `data-svg-origin` attribute so that it can be parsed back in. `svgOrigin` doesn't accommodate percentage-based values.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/ZYRqRx?default-tab=result\&theme-id=41164)

**Only for SVG elements** When changing the `transformOrigin` (or `svgOrigin`) of an SVG element, CSSPlugin will now automatically record/apply some offsets to ensure that the element doesn't "jump". You can disable this by setting `CSSPlugin.defaultSmoothOrigin = false`, or you can control it on a per-tween basis using `smoothOrigin: true` or `smoothOrigin: false`.

Deep Dive - Why use shorthand transforms?

The way transforms and transform-origins work in the browser (and according to the official spec), changing the origin causes the element jump in a jarring way. For example, if you rotate 180 degrees when the `transform-origin` is in the element's top left corner, it ends up at a very different position than if you applied the same rotation around its bottom right corner. Since GSAP is focused on solving real-world problems for animators (most of whom prefer to smoothly alter the `transformOrigin`), the `smoothOrigin` feature in GSAP solves this issue. This also means that if you create SVG artwork in an authoring program like Adobe Flash where it may not be easy/obvious to control where the element's origin is, things will "just work" when you define a `transformOrigin` via GSAP. Currently, this feature only applies to SVG elements, as that is where it is more commonly a pain-point.

Tweens rotation for a CSS property in a particular direction which can be either **clockwise** (`"_cw"` suffix), **counter-clockwise** (`"_ccw"` suffix), or in the **shortest direction** (`"_short"` suffix) in which case the plugin chooses the direction for you based on the shortest path. For example, if the element's rotation is currently 170 degrees and you want to tween it to -170 degrees, a normal rotation tween would travel a total of 340 degrees in the counter-clockwise direction, but if you use the \_short suffix, it would travel 20 degrees in the clockwise direction instead. Example:

Notice that the value is in quotes, thus a string with a particular suffix indicating the direction (`_cw`, `_ccw`, or `_short`). You can also use the `"+="` or `"-="` prefix to indicate relative values. Directional rotation suffixes are supported in all rotational properties (`rotation`, `rotationX`, and `rotationY`); you don't need to use `directionalRotation` as the property name. There is a [DirectionalRotationPlugin](/docs/v3/GSAP/CorePlugins/CSS.md#directionalrotation) that you can use to animate objects that aren't DOM elements, but there's no need to load that plugin if you're just animating CSS-related properties with CSSPlugin because it has DirectionalRotationPlugin's capabilities baked-in. Check out an [interactive example here](http://codepen.io/GreenSock/pen/jiEyG).

Identical to `opacity` except that when the value hits `0` the `visibility` property will be set to `hidden` in order to improve browser rendering performance and prevent clicks/interactivity on the target. When the value is anything other than `0`, `visibility` will be set to `inherit`. It is not set to `visible` in order to honor inheritance (imagine the parent element is hidden - setting the child to visible explicitly would cause it to appear when that's probably not what was intended). And for convenience, if the element's `visibility` is initially set to `hidden` and `opacity` is `1`, it will assume `opacity` should also start at `0`. This makes it simple to start things out on your page as invisible (set your CSS `visibility: hidden`) and then fade them in whenever you want.

GSAP can animate CSS variables in browsers that support them.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/e1a338a481c001eb5f8654c8d155170f?default-tab=result\&theme-id=41164)

You may enter a comma-delimited list of property names into `clearProps` that you want to clear from the element's `style` property when the tween completes (or use `"all"` or `true` to clear all properties). This can be useful if, for example, you have a class (or some other selector) that should apply certain styles to an element when the tween is over that would otherwise get overridden by the `element.style`-specific data that was applied during the tween. Typically you do **not** need to include vendor prefixes. `clearProps` also clears the "transform" attribute of SVG elements that have been affected by GSAP because GSAP always applies transforms (like x, y, rotation, scale, etc.) via the transform **attribute** to avoid browser bugs/quirks. Clearing any transform-related property (like `x`, `y`, `scale`, `rotation`, etc.) will clear the *entire* `transform` because those are all merged into one "transform" CSS property.

By default, CSSPlugin will round pixel values and `zIndex` to the closest integer during the tween (the inbetween values) because it improves browser performance, but if you'd rather disable that behavior, pass `autoRound: false` in the CSS object. You can still use the [SnapPlugin](/docs/v3/GSAP/CorePlugins/Snap.md) to manually define properties that you want rounded.

If you need to animate numeric attributes (rather than CSS-related properties), you can use the [AttrPlugin](/docs/v3/GSAP/CorePlugins/Attributes.md). And to replace the text in a DOM element, use the [TextPlugin](/docs/v3/Plugins/TextPlugin.md).

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/BaGvbXb?default-tab=js%2Cresult\&editable=true\&theme-id=41164)

Simply load GSAP's core - CSSPlugin is included automatically!

Nope. That was required *wayyy* back when GSAP was first created but due to the frequency of animating DOM elements, GSAP removed the need to use that for animating CSS properties.

**Examples:**

Example 1 (unknown):
```unknown
// some example properties.
gsap.to(element, {
  backgroundColor: "red", // background-color
  fontSize: 12, // font-size
  boxShadow: "0px 0px 20px 20px red", // animate complex strings
  borderRadius: "50% 50%",
  height: "auto", // animate between auto and a px value ü™Ñ
});
```

Example 2 (unknown):
```unknown
gsap.to(element, {
  // writing out the transform string üî•
  // transform: "translate(-50%,-50%)"
  xPercent: -50,
  yPercent: -50,
});
```

Example 3 (unknown):
```unknown
gsap.to(HTMLelement, {
  rotation: 360 // default deg
  rotation: "1.25rad" // use radians instead
  x: 24 // using px
  x: "20vw" // use viewport widths instead
});
```

Example 4 (unknown):
```unknown
gsap.to(element, {
  duration: 2,
  rotationX: 45,
  scaleX: 0.8,
  z: -300,
});
```

---

## scroller

**URL:** https://gsap.com/docs/v3/Plugins/ScrollTrigger/scroller.md

**Contents:**
  - scroller : Element | window
  - Returns : Element | window[‚Äã](#returns--element--window "Direct link to Returns : Element | window")
  - Details[‚Äã](#details "Direct link to Details")

\[read-only] The scroller element (or window) associated with the ScrollTrigger. It's the thing whose scrollbar is linked to the ScrollTrigger. By default, it's the window (viewport).

The element (or window) associated with the ScrollTrigger instance

\[read-only] The scroller element (or window) associated with the ScrollTrigger. It's the thing whose scrollbar is linked to the ScrollTrigger. By default, it's the window (viewport).

---

## .direction

**URL:** https://gsap.com/docs/v3/Plugins/ScrollTrigger/direction.md

**Contents:**
  - .direction : Number
  - Details[‚Äã](#details "Direct link to Details")
- Example[‚Äã](#example "Direct link to Example")

\[read-only] Reflects the moment-by-moment direction of scrolling where `1` is forward and `-1` is backward.

\[read-only] Reflects the moment-by-moment direction of scrolling where `1` is forward and `-1` is backward.

**Examples:**

Example 1 (unknown):
```unknown
ScrollTrigger.create({
  trigger: ".trigger",
  start: "top center",
  end: "+=500",
  onUpdate: (self) => console.log("direction:", self.direction),
});
```

---

## endRotation

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/endRotation.md

**Contents:**
  - endRotation : Number
  - Details[‚Äã](#details "Direct link to Details")

\[read-only] \[only applies to type:"rotation"] The ending rotation of the Draggable instance which is calculated as soon as the mouse/touch is released after a drag, meaning you can use it to predict precisely where it'll land after a `inertia` flick.

*Number* - \[only applies to `type: "rotation"` Draggable objects] The ending rotation of the Draggable instance. `endRotation` gets populated immediately when the mouse (or touch) is released after dragging, even before tweening has completed. This makes it easy to predict exactly what angle the element will land at (useful for `inertia: true` Draggables where momentum gets applied and you want to predict where it'll land).

---

## MotionPathPlugin.pointsToSegment

**URL:** https://gsap.com/docs/v3/Plugins/MotionPathPlugin/methods/static-pointsToSegment.md

**Contents:**
  - MotionPathPlugin.pointsToSegment( points:Array, curviness:Number ) : Array
    - Parameters
  - Returns : Array[‚Äã](#returns--array "Direct link to Returns : Array")
  - Details[‚Äã](#details "Direct link to Details")

Plots a curved cubic bezier path through the provided x,y point coordinates, returning a segment Array that's typically dropped into a RawPath Array

* #### **points**: Array

An Array of alternating x, y, x, y point coordinates like \[x, y, x, y, x, y...]

* #### **curviness**: Number

\[optional] This determines how "curvy" the resulting path is. So 0 would make straight lines (hard corners), 1 (the default) creates a nicely curved path, and 2 would make it much more curvy. Think of it like pulling the control points further and further outward from the anchors as the number goes higher.

Cubic Bezier data in alternating x, y, x, y format (ordered like: anchor, two control points, anchor, two control points, anchor, etc.)

Plots a curved cubic bezier path through the provided x,y point coordinates, returning a segment Array that's typically dropped into a RawPath Array.

---

## Pluck random elements from an array until it's empty...then start over

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/pluckRandomFrom.md

Randomly pluck values from an array one-by-one until they've all been plucked (almost as if when you pluck one, it's no longer available to be plucked again until ALL of them have been uniquely plucked):

All you've gotta do is feed the array in each time and it keeps track of things for you!

Alternatively, if you just want to pull a random element from an array that's not the PREVIOUS one that was pulled (so not emptying the array, just pulling randomly while ensuring the same element isn't pulled twice in a row), you can use this:

**Examples:**

Example 1 (unknown):
```unknown
function pluckRandomFrom(array) {
  return (
    array.eligible && array.eligible.length
      ? array.eligible
      : (array.eligible = gsap.utils.shuffle(array.slice(0)))
  ).pop();
}
```

Example 2 (unknown):
```unknown
function getRandomFrom(array) {
  var selected = array.selected;
  while (
    selected === (array.selected = Math.floor(Math.random() * array.length))
  ) {}
  return array[array.selected];
}
```

---

## gsap.version

**URL:** https://gsap.com/docs/v3/GSAP/gsap.version.md

**Contents:**
  - Type : String[‚Äã](#type--string "Direct link to Type : String")

The GSAP version that is currently being used (in String form). For example, `3.14.1`

---

## ScrollTrigger.isTouch

**URL:** https://gsap.com/docs/v3/Plugins/ScrollTrigger/static.isTouch.md

**Contents:**
  - ScrollTrigger.isTouch : Number
  - Details[‚Äã](#details "Direct link to Details")

A way to discern the touch capabilities of the current device - `0` is mouse/pointer only (no touch), `1` is touch-only, `2` accommodates both.

A way to discern the touch capabilities of the device:

* `0` - **no touch** (pointer/mouse only)
* `1` - **touch-only** device (like a phone)
* `2` - device can accept **touch** input and **mouse/pointer** (like Windows tablets)

**Examples:**

Example 1 (unknown):
```unknown
if (ScrollTrigger.isTouch) {
  // any touch-capable device...
}

// or get more specific:
if (ScrollTrigger.isTouch === 1) {
  // touch-only device
}
```

---

## isDragging

**URL:** https://gsap.com/docs/v3/Plugins/Observer/isDragging.md

**Contents:**
  - isDragging : Boolean
  - Details[‚Äã](#details "Direct link to Details")

When the user presses on the `target` and drags more than the `dragMinimum` (0 by default), `isDragging` is set to `true` until the touch/pointer is released (even if the user continues dragging *outside the bounds of the target*).

When the user presses on the `target` and drags more than the `dragMinimum` (0 by default), `isDragging` is set to `true` until the touch/pointer is released (even if the user continues dragging *outside the bounds of the target*).

---

## Kill all tweens applied to child elements of a given target

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/killChildTweensOf.md

**Contents:**
- Demo[‚Äã](#demo "Direct link to Demo")
    - loading...

You can kill all tweening elements that are children of a given target by using this function:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/yLOPRQG?default-tab=result\&theme-id=41164)

**Examples:**

Example 1 (unknown):
```unknown
function killChildTweensOf(ancestor) {
  ancestor = gsap.utils.toArray(ancestor)[0];
  gsap.globalTimeline
    .getChildren(true, true, false)
    .forEach((tween) =>
      tween
        .targets()
        .forEach((e) => e.nodeType && ancestor.contains(e) && tween.kill(e))
    );
}
```

---

## Call a function after viewport resizing stops (debounced)

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/callAfterResize.md

**Contents:**
- Usage[‚Äã](#usage "Direct link to Usage")

"resize" events get dispatched **many** times while the user is dragging the browser window's edges, so if you run an expensive function on every resize event, it can really bog things down. Here's a function that will wait to call your function until a certain amount of time has elapsed since the user STOPPED resizing the window (by default, it's 0.2 seconds):

**Examples:**

Example 1 (unknown):
```unknown
function callAfterResize(func, delay) {
  let dc = gsap.delayedCall(delay || 0.2, func).pause(),
    handler = () => dc.restart(true);
  window.addEventListener("resize", handler);
  return handler; // in case you want to window.removeEventListener() later
}
```

Example 2 (unknown):
```unknown
callAfterResize(myFunction);
```

---

## CustomWiggle

**URL:** https://gsap.com/docs/v3/Eases/CustomWiggle.md

**Contents:**
    - CDN Link
    - Minimal usage
  - Description[‚Äã](#description "Direct link to Description")
  - Demo[‚Äã](#demo "Direct link to Demo")
    - loading...
  - Config Object[‚Äã](#config-object "Direct link to Config Object")
  - Sample code[‚Äã](#sample-code "Direct link to Sample code")
  - Demo collection[‚Äã](#demo-collection "Direct link to Demo collection")

CustomWiggle extends [CustomEase](/docs/v3/Eases/CustomEase.md) (which you must include in your project as well), and it lets you set a wiggle amount and type.

[YouTube video player](https://www.youtube.com/embed/5lk5sLTd6N4)

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/ebdbdadcd678a211681b4aa66cb58c4f?default-tab=result\&theme-id=41164)

Integer - The number of oscillations back and forth. Default: 10.

String (‚ÄúeaseOut‚Äù | ‚ÄúeaseInOut‚Äù | ‚Äúanticipate‚Äù | ‚Äúuniform‚Äù | ‚Äúrandom‚Äù) - The type (or style) of wiggle (see demo above). Default: ‚ÄúeaseOut‚Äù.

* #### amplitudeEase[](#amplitudeEase)

Ease Provides advanced control over the shape of the amplitude (y-axis in the [ease visualizer](/ease-visualizer/)). You define an ease that controls the amplitude‚Äôs progress from 1 toward 0 over the course of the tween. Defining an amplitudeEase (or timingEase) will override the ‚Äútype‚Äù (think of the 5 ‚Äútypes‚Äù as convenient presets for amplitudeEase and timingEase combinations). See the [example CodePen](//codepen.io/GreenSock/pen/a8a7bc33cf80a74165dd966244a6cc00?editors=0010) to play around and visualize how it works.

* #### timingEase[](#timingEase)

Ease Provides advanced control over how the waves are plotted over time (x-axis in the [ease visualizer](/ease-visualizer/)). Defining an timingEase (or amplitudeEase) will override the ‚Äútype‚Äù (think of the 5 ‚Äútypes‚Äù as convenient presets for amplitudeEase and timingEase combinations). See the [example CodePen](//codepen.io/GreenSock/pen/a8a7bc33cf80a74165dd966244a6cc00?editors=0010) to play around and visualize how it works.

How do you control the strength of the wiggle (or how far it goes)? Simply by setting the tween property values themselves. For example, a wiggle to `rotation:30` would be stronger than `rotation:10`. Remember that an ease just controls the ratio of movement toward whatever value you supply for each property in your tween.

Wiggling isn't just for "rotation"; you can use it for any property. For example, you could create a swarm effect by using just 2 randomized wiggle tweens on "x" and "y", as [demonstrated here](https://codepen.io/GreenSock/pen/wzkBYZ).

* [CustomWiggle demos](https://codepen.io/collection/AxZmqK)

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(CustomEase, CustomWiggle)
```

Example 2 (unknown):
```unknown
//Create a wiggle with 6 oscillations (default type:"easeOut")
CustomWiggle.create("myWiggle", {wiggles: 6});

//now use it in an ease. "rotation" will wiggle to 30 and back just as much in the opposite direction, ending where it began.
gsap.to(".class", {duration: 2, rotation: 30, ease: "myWiggle"});
```

Example 3 (unknown):
```unknown
gsap.registerPlugin(CustomEase, CustomWiggle); // register

//Create a wiggle with 6 oscillations (default type:"easeOut")
CustomWiggle.create("myWiggle", {wiggles: 6});

//now use it in an ease. "rotation" will wiggle to 30 and back just as much in the opposite direction, ending where it began.
gsap.to(".class", {duration: 2, rotation: 30, ease: "myWiggle"});

//Create a 10-wiggle anticipation ease:
CustomWiggle.create("funWiggle", {wiggles: 10, type: "anticipate"});
gsap.to(".class", {duration: 2, rotation: 30, ease: "funWiggle"});

//Alternatively, make sure CustomWiggle is loaded and use GSAP's string ease format
ease: "wiggle(15)" //<-- easy!
ease: "wiggle({type:anticipate, wiggles:8})" //advanced
```

---

## smoothChildTiming

**URL:** https://gsap.com/docs/v3/GSAP/Timeline/smoothChildTiming.md

**Contents:**
  - smoothChildTiming : Boolean
  - Details[‚Äã](#details "Direct link to Details")

Controls whether or not child tweens and timelines are repositioned automatically (changing their `startTime`) in order to maintain smooth playback when properties are changed on-the-fly.

Controls whether or not child tweens and timelines are repositioned automatically (changing their `startTime`) in order to maintain smooth playback when properties are changed on-the-fly.

For example, imagine that the timeline's playhead is on a child tween that is 75% complete, moving `obj.x` from 0 to 100 and then that tween's `reverse()` method is called. If `smoothChildTiming` is `false` (the default except for the root timelines), the tween would flip in place, keeping its `startTime` consistent. Therefore the playhead of the timeline would now be at the tween's 25% completion point instead of 75%. Remember, the timeline's playhead position and direction are unaffected by child tween/timeline changes. `obj.x` would jump from 75 to 25, but the tween's position in the timeline would remain consistent.

However, if `smoothChildTiming` is `true`, that child tween's `startTime` would be adjusted so that the timeline's playhead intersects with the same spot on the tween (75% complete) as it had immediately before `reverse()` was called, thus playback appears perfectly smooth. `obj.x` would still be 75 and it would continue from there as the playhead moves on, but since the tween is reversed now `obj.x` will travel back towards 0 instead of 100. Ultimately it's a decision between prioritizing smooth on-the-fly playback (`true`) or consistent position(s) of child tweens and timelines (`false`).

Some examples of properties/methods that on-the-fly changes could affect `startTime` (when `smoothChildTiming` is `true`) : `reversed`, `timeScale`, `progress`, `totalProgress`, `time`, `totalTime`, `delay`, `pause`, `resume`, `duration`, and `totalDuration`.

The `gsap.globalTimeline` has `smoothChildTiming` set to `true`.

---

## velocityX

**URL:** https://gsap.com/docs/v3/Plugins/Observer/velocityX.md

**Contents:**
  - velocityX : Number
  - Details[‚Äã](#details "Direct link to Details")

The horizontal velocity (in pixels per second).

The horizontal velocity (in pixels per second).

This is only affected by the event types that the Observer is watching. So, for example, `type: "wheel,touch"` would track the velocity based on wheel and touch events (not pointer or scroll). By default, touch and pointer events are only tracked **while pressing/dragging** but if you define an `onMove` (which is mapped to "pointermove"/"mousemove" events), it'll be tracked during any movement while hovering over the target.

---

## endY

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/endY.md

**Contents:**
  - endY : Number
  - Details[‚Äã](#details "Direct link to Details")

\[read-only] The ending y (vertical) position of the Draggable instance which is calculated as soon as the mouse/touch is released after a drag, meaning you can use it to predict precisely where it'll land after a `inertia` flick.

*Number* - The ending `y` (vertical) position of the Draggable instance. `endY` gets populated immediately when the mouse (or touch) is released after dragging, even before tweening has completed. This makes it easy to predict exactly where the element will land (useful for `inertia: true` Draggables where momentum gets applied). For a Draggable of `type: "x,y"`, `endY` would pertain to the `y` transform translation, as in the CSS `transform: translateY(...)`. For `type: "top,left"`, the Draggable's `y` would refer to the CSS `top` value that's applied. This is not the global coordinate - it is the inline CSS-related value applied to the element.

---

## MorphSVGPlugin.defaultRender

**URL:** https://gsap.com/docs/v3/Plugins/MorphSVGPlugin/static.defaultRender.md

**Contents:**
  - MorphSVGPlugin.defaultRender : Function
  - Details[‚Äã](#details "Direct link to Details")
- Video explanation[‚Äã](#video-explanation "Direct link to Video explanation")
- Demo: MorphSVG canvas rendering[‚Äã](#demo-morphsvg-canvas-rendering "Direct link to Demo: MorphSVG canvas rendering")
    - loading...

Sets the default function that should be called whenever a morphSVG tween updates. This is useful if you're rendering to `<canvas>`.

Sets the default function that should be called whenever a morphSVG tween updates. This is useful if you're rendering to `<canvas>`.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/WYWZab?default-tab=result\&theme-id=41164)

Here's an example of a tween and a render function that'd draw the morphing shape to canvas:

**Examples:**

Example 1 (unknown):
```unknown
var canvas = document.querySelector("canvas"),
  ctx = canvas.getContext("2d"),
  vw = (canvas.width = window.innerWidth),
  vh = (canvas.height = window.innerHeight);
ctx.fillStyle = "#ccc";
MorphSVGPlugin.defaultRender = draw;
gsap.to("#hippo", { duration: 2, morphSVG: "#circle" });
function draw(rawPath, target) {
  var l, segment, j, i;
  ctx.clearRect(0, 0, vw, vh);
  ctx.beginPath();
  for (j = 0; j < rawPath.length; j++) {
    segment = rawPath[j];
    l = segment.length;
    ctx.moveTo(segment[0], segment[1]);
    for (i = 2; i < l; i += 6) {
      ctx.bezierCurveTo(
        segment[i],
        segment[i + 1],
        segment[i + 2],
        segment[i + 3],
        segment[i + 4],
        segment[i + 5]
      );
    }
    if (segment.closed) {
      ctx.closePath();
    }
  }
  ctx.fill("evenodd");
}
```

---

## masks

**URL:** https://gsap.com/docs/v3/Plugins/SplitText/masks.md

**Contents:**
  - masks : Array\<Element>
  - Details[‚Äã](#details "Direct link to Details")
    - loading...

Wrapper elements created when using `mask: "lines"`, `"words"` or `"chars"`.

An array containing all of the wrapper elements created by the `mask` feature. When you use `mask: "lines"`, `"words"`, or `"chars"`, SplitText wraps each corresponding part in an extra `<div>` with `overflow: clip`, allowing for simple masked reveal animations. Access them in a "masks" Array on the SplitText instance. If you set a class name for the `lines/words/chars`, it'll append `"-mask"` for easy selecting.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/a28f78aa1b47e6fa3ad56684564fdf81?default-tab=result\&theme-id=41164)

---

## .isActive

**URL:** https://gsap.com/docs/v3/Plugins/ScrollTrigger/isActive.md

**Contents:**
  - .isActive : Boolean
  - Details[‚Äã](#details "Direct link to Details")
- Example[‚Äã](#example "Direct link to Example")

\[read-only] Only `true` if the scroll position is between the start and end positions of the ScrollTrigger instance.

\[read-only] Only `true` if the scroll position is between the start and end positions of the ScrollTrigger instance.

**Examples:**

Example 1 (unknown):
```unknown
ScrollTrigger.create({
  trigger: ".trigger",
  start: "top center",
  end: "+=500",
  onToggle: (self) => console.log("toggled. active?", self.isActive),
});
```

---

## MorphSVGPlugin.defaultType

**URL:** https://gsap.com/docs/v3/Plugins/MorphSVGPlugin/static.defaultType.md

**Contents:**
  - MorphSVGPlugin.defaultType : String
  - Details[‚Äã](#details "Direct link to Details")

Sets the default `"type"` for all MorphSVG animations. The default `type` is `"linear"` but you can change it to `"rotational"`.

Sets the default `type` for all MorphSVG animations. The default `type` is `"linear"` but you can change it to `"rotational"` by doing:

For more information about `type: "rotational"`, see the video below:

**Examples:**

Example 1 (unknown):
```unknown
MorphSVGPlugin.defaultType = "rotational";
```

---

## Snap

**URL:** https://gsap.com/docs/v3/GSAP/CorePlugins/Snap.md

**Contents:**
- Description[‚Äã](#description "Direct link to Description")
  - FAQs[‚Äã](#faqs "Direct link to FAQs")
    - How do I include this plugin in my project?
    - Do I need to register SnapPlugin?

What are internal plugins?

SnapPlugin is an internal plugin, It is **automatically included in GSAP's core** and **doesn't have to be loaded using gsap.registerPlugin()**.

You can think of internal plugins as just a part of GSAP.

The SnapPlugin allows tweens to "snap" to the closest value in a given array or increment. It basically adds a modifier to any property that implements one of the following snapping behaviors to every value DURING the tween (live, not just to the end value).

You can define as many snap properties as you want.

Simply load GSAP's core - SnapPlugin is included automatically!

Nope. SnapPlugin is built into the core and doesn't need to be registered.

**Examples:**

Example 1 (unknown):
```unknown
// snap all of the properties in the comma-delimited list ("x,y" in this case) to the closest whole number:
gsap.to(".class", {
  x: 1000,
  y: 250,
  snap: "x,y",
});

// snap to an increment:
gsap.to(".class", {
  x: 1000,
  snap: {
    x: 20, // x snaps to the closest increment of 20 (0, 20, 40, 60, etc.)
  },
});

// snap to the closest value in an array:
gsap.to(".class", {
  x: 1000,
  snap: {
    x: [0, 50, 150, 500], // x snaps to the closest value in this array
  },
});

// snap to a value in an array, but only when it's within a certain distance/radius of one of those values:
gsap.to(".class", {
  x: 1000,
  snap: {
    x: { values: [0, 50, 150, 500], radius: 20 }, // x snaps to the closest value in the array but only when it's within 20 pixels of it.
  },
});
```

---

## Directional snapping

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/getDirectionalSnapFunc.md

**Contents:**
- Usage[‚Äã](#usage "Direct link to Usage")

Normally when you snap a value, it goes to the **CLOSEST** one (either an increment or the value in an Array), like:

But what if you want to apply **directional** snapping so that, for example, you want to snap to the closest increment of 5 that's GREATER than the value? You need a function that'll accept a value and a direction where `1` means "greater" and `-1` means "lesser". Here's the helper function:

Note that you can use an Array of values instead of an increment. Super convenient!

**Examples:**

Example 1 (unknown):
```unknown
let snap = gsap.utils.snap(5); // returns a function that snaps any value to the closest increment of 5
console.log(snap(2)); // 0
console.log(snap(3.5)); // 5
console.log(snap(19)); // 20
```

Example 2 (unknown):
```unknown
function getDirectionalSnapFunc(snapIncrementOrArray) {
  let snap = gsap.utils.snap(snapIncrementOrArray),
    a =
      Array.isArray(snapIncrementOrArray) &&
      snapIncrementOrArray.slice(0).sort((a, b) => a - b);
  return a
    ? (value, direction) => {
        let i;
        if (!direction) {
          return snap(value);
        }
        if (direction > 0) {
          value -= 1e-4; // to avoid rounding errors. If we're too strict, it might snap forward, then immediately again, and again.
          for (i = 0; i < a.length; i++) {
            if (a[i] >= value) {
              return a[i];
            }
          }
          return a[i - 1];
        } else {
          i = a.length;
          value += 1e-4;
          while (i--) {
            if (a[i] <= value) {
              return a[i];
            }
          }
        }
        return a[0];
      }
    : (value, direction) => {
        let snapped = snap(value);
        return !direction ||
          Math.abs(snapped - value) < 0.001 ||
          snapped - value < 0 === direction < 0
          ? snapped
          : snap(
              direction < 0
                ? value - snapIncrementOrArray
                : value + snapIncrementOrArray
            );
      };
}
```

Example 3 (unknown):
```unknown
let snap = getDirectionalSnapFunc(5); // returns a function that snaps any value to the closest increment of 5 in a particular direction
console.log(snap(2, 1)); // 5
console.log(snap(3.5, -1)); // 0
console.log(snap(19, -1)); // 15
```

---

## Pixi

**URL:** https://gsap.com/docs/v3/Plugins/PixiPlugin.md

**Contents:**
    - CDN Link
    - Minimal usage
- PixiJS examples[√¢‚Ç¨‚Äπ](#pixijs-examples "Direct link to PixiJS examples")
- Colors[√¢‚Ç¨‚Äπ](#colors "Direct link to Colors")
- ColorMatrixFilter[√¢‚Ç¨‚Äπ](#colormatrixfilter "Direct link to ColorMatrixFilter")
    - loading...
- BlurFilter[√¢‚Ç¨‚Äπ](#blurfilter "Direct link to BlurFilter")
- Directional rotation[√¢‚Ç¨‚Äπ](#directional-rotation "Direct link to Directional rotation")
- Other properties[√¢‚Ç¨‚Äπ](#other-properties "Direct link to Other properties")
- **Methods**[√¢‚Ç¨‚Äπ](#methods "Direct link to methods")

PixiPlugin makes it much easier to animate things in [PixiJS](//www.pixijs.com/), a popular canvas library that's extremely performant. Without the plugin, it's a tad cumbersome with certain properties because they're tucked inside sub-objects in PixiJS's API, like `object.position.x`, `object.scale.y`, `object.skew.x`, etc. Plus PixiJS defines rotational values in radians instead of degrees which isn't as intuitive for most developers and designers. PixiPlugin saves you a bunch of headaches:

Notice **rotational values are defined in degrees, not radians**. Yay!

Be sure to include the PixiPlugin correctly:

There are a bunch of GSAP-based examples in the [PixiJS documentation here](https://pixijs.io/examples/#/gsap3-interaction/gsap3-basic.js)! It's a great place to start.

PixiJS requires that you define color-related values in a format like `0xFF0000` but with PixiPlugin, you can define them the same way you would in CSS, like `"red"`, `"#F00"`, `"#FF0000"`, `"rgb(255,0,0)"`, `"hsl(0, 100%, 50%)"`, or `0xFF0000`. You can even do relative HSL values! `"hsl(+=180, +=0%, +=0%)"`.

Another big convenience is that PixiPlugin recognizes some special values like `saturation`, `brightness`, `contrast`, `hue`, and `colorize` (which all leverage a `ColorMatrixFilter` under the hood).

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/e1f256723ce102d6b9a776fa7f6da9f4?default-tab=result\&theme-id=41164)

Or if you have a custom `ColorMatrixFilter`, just pass that in as the `colorMatrixFilter` property and it'll handle animating between states:

PixiPlugin recognizes `blur`, `blurX`, and `blurY` properties, so it's very simple to apply a blur without having to create a new `BlurFilter` instance, add it to the filters array, and animate its properties separately.

You can control which direction a rotation tween goes by appending a suffix for **clockwise** (`"_cw"`), **counter-clockwise** (`"_ccw"`), or the **shortest direction** (`"_short"`). For example, if the element's rotation is currently 170 degrees and you want to tween it to -170 degrees, a normal rotation tween would travel a total of 340 degrees in the counter-clockwise direction, but `rotation: "-170_short"` suffix, it would travel 20 degrees in the clockwise direction instead! Example:

Directional rotation capabilities were added in GSAP 3.2, so make sure you've got the latest update.

PixiPlugin can handle almost any other property as well - there is no pre-determined list of "allowed" properties. PixiPlugin simply improves developer ergonomics for anyone animating in PixiJS. Less code, fewer headaches, and faster production. For a full listing of properties that the PixiPlugin helps with, see [the PixiPlugin Typescript declarations](https://github.com/greensock/GSAP/blob/master/types/pixi-plugin.d.ts).

|                                                                                                         |                                                                                                                                                  |
| ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| #### [PixiPlugin.registerPIXI](/docs/v3/Plugins/PixiPlugin/static.registerPIXI\(\).md)( PIXI:Object ) ; | Registers the main PIXI library object with the PixiPlugin so that it can find the necessary classes/objects. You only need to register it once. |

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(PixiPlugin)
```

Example 2 (unknown):
```unknown
gsap.to(graphics, { duration: 2, pixi: { lineColor: "purple" } });
```

Example 3 (unknown):
```unknown
//old way (without plugin):
gsap.to(pixiObject.scale, { x: 2, y: 1.5, duration: 1 });
gsap.to(pixiObject.skew, { x: (30 * Math.PI) / 180, duration: 1 });
gsap.to(pixiObject, { rotation: (60 * Math.PI) / 180, duration: 1 });

//new way (with plugin):
gsap.to(pixiObject, {
  pixi: { scaleX: 2, scaleY: 1.5, skewX: 30, rotation: 60 },
  duration: 1,
});
```

Example 4 (unknown):
```unknown
import * as PIXI from "pixi.js";
import { gsap } from "gsap";
import { PixiPlugin } from "gsap/PixiPlugin";

// register the plugin
gsap.registerPlugin(PixiPlugin);

// give the plugin a reference to the PIXI object
PixiPlugin.registerPIXI(PIXI);
```

---

## GSDevTools

**URL:** https://gsap.com/docs/v3/Plugins/GSDevTools.md

**Contents:**
    - CDN Link
    - Minimal usage
- Description[‚Äã](#description "Direct link to Description")
- Get Started[‚Äã](#get-started "Direct link to Get Started")
    - loading...
- Select an animation by id[‚Äã](#select-an-animation-by-id "Direct link to Select an animation by id")
    - loading...
- Persistence between refreshes[‚Äã](#persistence-between-refreshes "Direct link to Persistence between refreshes")
- Config Object[‚Äã](#config-object "Direct link to Config Object")
- Keyboard Controls[‚Äã](#keyboard-controls "Direct link to Keyboard Controls")

GSDevTools gives you a **visual UI** for interacting with and debugging [GSAP](/docs/v3/GSAP/.md) animations, complete with advanced playback controls, keyboard shortcuts, global synchronization and more. Jump to specific scenes, set in/out points, play in slow motion to reveal intricate details, and even switch to a "minimal" mode on small screens. GSDevTools makes building and reviewing GSAP animations simply delightful.

![](/assets/images/GSDevTools-gui-683279c3022faec0481c1332043dd117.png)

1. Import GSDevTools through a script tag or import the plugin from the GSAP package

2. Create a GSDevTools instance

Though we suggest linking it to a particular animation instance because then GSDevTools doesn't need to worry all the global syncing of things. You can do that by setting the `animation` value of the dev tools instance:

The demo below shows GSDevTools running with its default settings. It automatically gives you control over every animation on the global timeline.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/611c82e0d3531b431617f8adbfeb71fd?default-tab=result\&theme-id=41164)

Any GSAP animation (tween or timeline) can be assigned an `id` (a string) which causes it to show up in the animation menu. That makes it easy to jump to any scene. Notice how the timeline *and* each tween below have an `id` assigned:

Now each id shows up in the animations menu (lower left).

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/afc5e9aaa3c5fa91298f1e41501c1c66?default-tab=result\&theme-id=41164)

For added convenience, when you manually set the in/out points, animation, `timeScale`, or looping state in the UI, they persist between refreshes! This means you can drag the in/out points to isolate a particular section and then tweak the code, hit refresh, and see the changes immediately within that cropped area. Any values set in the `GSDevTools.create({...})` method will override manual selections. Set `persist: false` to disable persistence. If you encounter persistence contamination (e.g. setting `timeScale` in one affects another), simply assign a unique `id` to the GSDevTools instance (the recorded values are segregated by `id`, session, and domain).

GSDevTools can be configured extensively. Optionally define any of these properties in the config object:

\[*String* | *Animation*] - If you define an animation, like `animation: myTimeline`, `animation: myTween` or `animation: "id"`, that animation will be initially selected. By default, the global timeline is selected.

* #### container[](#container)

\[*String* | *Element*] - Specify the container element for GSDevTools, like: `"#devTools"` or `document.getElementById ("devTools")`.

\[*Object* | *String*] - The CSS you want on the outer div, like `{width: "50%", bottom: "30px"}` or a string of CSS like `"width: 50%; bottom: 30px"`.

* #### globalSync[](#globalSync)

Boolean - Animations can be kept in context and synchronized with the root timeline (scrubbing one scrubs them all). To enable this, set `globalSync: true` to hook it to the global timeline.

* #### hideGlobalTimeline[](#hideGlobalTimeline)

Boolean - If `true`, the Global Timeline will be removed from the animation menu.

String - A unique string to identify the GSDevTools instance.

* #### inTime[](#inTime)

\[*Number* | *String*] - Position of the in marker (time, in seconds, or label or animation `id`).

* #### keyboard[](#keyboard)

Boolean - If `true` (the default), keyboard shortcuts will work. Note: Only one GSDevTools instance can listen for keyboard shortcuts.

Boolean - Initial loop state.

* #### minimal[](#minimal)

Boolean - If `true`, the UI will only show minimal controls (scrubber, play/pause, and timeScale). Note: When the screen is less than 600px it automatically switches to minimal mode anyway.

* #### outTime[](#outTime)

\[*Time* | *Label*] - Position of the out marker (time, in seconds, or label, or animation `id`).

* #### paused[](#paused)

Boolean - Initial paused state.

* #### persist[](#persist)

Boolean - By default, GSDevTools remembers the in and out points, selected animation, timeScale, and looping state between refreshes in the same domain session, but you can disable that behavior by setting `persist: false`.

* #### timeScale[](#timeScale)

Number - Initial `timeScale`.

* #### visibility[](#visibility)

String - `"auto"` causes the controls to automatically hide when you roll off of them for about 1 second, and return when you move your mouse over the area again.

* **SPACEBAR:** play/pause
* **UP/DOWN ARROWS:** increase/decrease timeScale
* **LEFT ARROW:** rewind
* **RIGHT ARROW:** jump to end
* **L:** toggle loop
* **I:** set the in point to current position of playhead
* **O:** set the out point to current position of playhead
* **H:** hide/show toggle

* It is almost always best to define an animation directly like `GSDevTools.create({ animation: yourAnimation... });` so that it doesn't need to worry about mergine all the global animations in.

* Clicking the GSAP logo (bottom right) gets you right to the [docs](/docs/v3/.md)!

* Double-click on the in/out marker(s) to reset them both immediately.

* If the playback UI is obscuring part of your animation, just tap the "H" key to hide it (and again to bring it back) - you can still use all the keyboard shortcuts even when it's invisible.

We purposefully chose very basic animations for the demos above, but here's one that illustrates how easy GSDevTools makes it to control and debug even complex animation sequences.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/4bffdb4fc44f09fcb4c4e8f1c8f46298?default-tab=result\&theme-id=41164)

GSDevTools doesn't work with ScrollTrigger-driven animations because that would be logically impossible to have the scrollbar and the GSDevTools scrubber both control the same animation.

|                                                                                                          |   |
| -------------------------------------------------------------------------------------------------------- | - |
| #### [GSDevTools.create](/docs/v3/Plugins/GSDevTools/static.create\(\).md)( config:Object ) : GSDevTools |   |

That means you've probably got an infinitely repeating animation somewhere. GSDevTools caps its duration at 1000 seconds. Scrubbing to Infinity is awkward.

If you have a reference to the dev tools (it's probably easiest to give the dev tools instance an id, i.e.

then you can kill the instance by using

Nope, it depends on some unique capabilities baked into the GSAP architecture.

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(GSDevTools)
```

Example 2 (unknown):
```unknown
GSDevTools.create();
```

Example 3 (unknown):
```unknown
<script src="https://cdn.jsdelivr.net/npm/gsap@3.14.1/dist/GSDevTools.min.js"></script>
```

Example 4 (unknown):
```unknown
import { GSDevTools } from "gsap/GSDevTools";
```

---

## Step-by-step function calls progressively build timeline

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/progressiveBuild.md

**Contents:**
  - Usage[‚Äã](#usage "Direct link to Usage")

Maybe you can't pre-build your entire timeline because you need to call individual functions in a sequenced fashion. Perhaps they each change the state of elements, creating an animation that must finish before the next step (function) is called. This helper function lets you organize your code quite easily into a simple sequence of arguments you pass, and you can even have a delay between each step:

**Examples:**

Example 1 (unknown):
```unknown
function progressiveBuild() {
  let data = Array.from(arguments),
    i = 0,
    tl = gsap.timeline({
      onComplete: function () {
        let isNum = typeof data[i] === "number",
          delay = isNum ? data[i++] : 0,
          func = data[i++];
        typeof func === "function" && tl.add(func(), "+=" + delay);
      },
    });
  tl.vars.onComplete();
  return tl;
}
```

Example 2 (unknown):
```unknown
progressiveBuild(
  step1,
  step2,
  1.5, // 1.5-second delay (sprinkle between any two functions)
  step3
);
```

---

## SplitText lines in nested elements

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/nestedLinesSplit.md

**Contents:**
- Demo[‚Äã](#demo "Direct link to Demo")
    - loading...

SplitText doesn't natively support splitting nested elements by "lines", but if you really need that we've put together a helper function for it.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/d754bcc333a42b5e654e67595951901b?default-tab=result\&theme-id=41164)

**Examples:**

Example 1 (unknown):
```unknown
function nestedLinesSplit(target, vars) {
  var split = SplitText.create(target, vars),
    words = vars.type.indexOf("words") !== -1,
    chars = vars.type.indexOf("chars") !== -1,
    insertAt = function (a, b, i) {
      //insert the elements of array "b" into array "a" at index "i"
      var l = b.length,
        j;
      for (j = 0; j < l; j++) {
        a.splice(i++, 0, b[j]);
      }
      return l;
    },
    children,
    child,
    i;

  if (typeof target === "string") {
    target = document.querySelectorAll(target);
  }
  if (target.length > 1) {
    for (i = 0; i < target.length; i++) {
      split.lines = split.lines.concat(nestedLinesSplit(target[i], vars).lines);
    }
    return split;
  }

  //mark all the words and character  elements as _protected so that we can identify the non-split stuff.
  children = (words ? split.words : []).concat(chars ? split.chars : []);
  for (i = 0; i < children.length; i++) {
    children[i]._protect = true;
  }

  children = split.lines;
  for (i = 0; i < children.length; i++) {
    child = children[i].firstChild;
    //if the first child isn't protected and it's not a text node, we found a nested element that we must bust up into lines.
    if (!child._protect && child.nodeType !== 3) {
      children[i].parentNode.insertBefore(child, children[i]);
      children[i].parentNode.removeChild(children[i]);
      children.splice(i, 1);
      i += insertAt(children, nestedLinesSplit(child, vars).lines, i) - 1;
    }
  }
  return split;
}

//used like
var mySplitText = nestedLinesSplit(assetTexts, { type: "lines" });
```

---

## ScrollTo

**URL:** https://gsap.com/docs/v3/Plugins/ScrollToPlugin.md

**Contents:**
    - CDN Link
    - Minimal usage
- Description[‚Äã](#description "Direct link to Description")
    - loading...
    - loading...

If you want to do scroll-driven animations where things get triggered at certain scrollbar positions, use the [ScrollTrigger](/docs/v3/Plugins/ScrollTrigger/.md) plugin.

Animates the scroll position of the window (like doing `window.scrollTo(x, y)`) or a DOM element (like doing `myDiv.scrollTop = y; myDiv.scrollLeft = x;`).

using alongside `scroll-behavior: smooth` in CSS will cause conflicts

To scroll the window to a particular position, use window as the target of the tween like this:

To tween the content of a div, make sure you've set the `overflow: scroll` on the div and then:

You can define an x or y value or both (to scroll on both the x and y axis). For example, to scroll to 400 pixels from the top and 200 pixels from the left, do this:

You can also optionally pass offsetX and/or offsetY numeric values if you want to offset the destination from the element.

The demo below uses the offsetY so that each section scrolls into view just under the navigation. Click the section buttons in the demo below. Check out the JS source.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/4be7ea5c962b62bcd156612524687a5a?default-tab=result\&theme-id=41164)

To have ScrollToPlugin automatically sense if the scroll position was changed outside of itself (like if the user manually started dragging the scrollbar mid-tween) and cancel that portion of the tween, set `autoKill: true`inside the `scrollTo` object, like:

If you would like to detect when autoKill gets triggered you can define an `onAutoKill` callback.

You can also set autoKill globally via [`ScrollToPlugin.config()`](/docs/v3/Plugins/ScrollToPlugin/config\(\).md)

To scroll to the maximum scroll position, use the string `"max"` as the value, like this:

If you don't wrap the value in an object, it will assume you want to scroll in the "y" direction, so these two lines are functionally equivalent:

Here's a basic example using anchors:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/ExKNEXY?default-tab=result\&theme-id=41164)

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(ScrollToPlugin)
```

Example 2 (unknown):
```unknown
//scroll to 400 pixels down from the top
  gsap.to(window, { duration: 2, scrollTo: 400 });
```

Example 3 (unknown):
```unknown
//scroll to 400 pixels down from the top
gsap.to(window, { duration: 2, scrollTo: 400 });

//or to scroll to the element with the ID "#someID" (as of GSAP 1.19.0):
gsap.to(window, { duration: 2, scrollTo: "#someID" });
```

Example 4 (unknown):
```unknown
//scroll to 250 pixels down from the top of the content in the div
gsap.to(myDiv, { duration: 2, scrollTo: 250 });
```

---

## parent

**URL:** https://gsap.com/docs/v3/GSAP/Timeline/parent.md

**Contents:**
  - parent : Timeline
  - Details[‚Äã](#details "Direct link to Details")
- How do timelines work?[‚Äã](#how-do-timelines-work "Direct link to How do timelines work?")

The parent [Timeline](/docs/v3/GSAP/Timeline.md) to which the animation is attached. Anything that's not in a Timeline that you create is placed on the [gsap.globalTimeline](/docs/v3/GSAP/gsap.globalTimeline.md) by default.

The parent [Timeline](/docs/v3/GSAP/Timeline.md) to which the Timeline is attached. Anything that's not inside a Timeline that you create is placed on the [gsap.globalTimeline](/docs/v3/GSAP/gsap.globalTimeline\(\)) by default.

Each animation ([Tweens](/docs/v3/GSAP/Tween.md) and [Timelines](/docs/v3/GSAP/Timeline.md)) can only exist in one parent. Think of it like a DOM element that can't have multiple parents. If you [add()](/docs/v3/GSAP/Timeline/add\(\).md) an animation to a different Timeline, its `parent` will change to that Timeline.

See the [Timeline docs for details](/docs/v3/GSAP/Timeline.md#mechanics). It's very helpful to understand how the mechanics work conceptually.

---

## pointerEvent

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/pointerEvent.md

**Contents:**
  - pointerEvent : Object
  - Details[‚Äö√Ñ√£](#details "Direct link to Details")

\[read-only] The last pointer event (either a mouse event or touch event) that affected the Draggable instance.

*Object* - The last pointer event (either a mouse event or touch event) that affected the Draggable instance. This can be useful to, for example, check its `pageX`, `pageY`, `target`, `currentTarget`, etc.

---

## Flip

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/FLIP.md

**Contents:**
    - loading...

If you're shifting things around in the DOM and then you want elements to animate to their new positions, the most full-featured way to handle it is with the [Flip Plugin](/docs/v3/Plugins/Flip/.md), but if you're only doing basic things you can use this helper function (see the comments at the top to learn how to use it):

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/eYJLOdj?default-tab=result\&theme-id=41164)

**Examples:**

Example 1 (unknown):
```unknown
/*
Copy this to your project. Pass in the elements (selector text or NodeList or Array), then a
function/callback that actually performs your DOM changes, and optionally a vars
object that contains any of the following properties to customize the transition:

- duration [Number] - duration (in seconds) of each animation
- stagger [Number | Object | Function] - amount to stagger the starting time of each animation. You may use advanced staggers too (see https://codepen.io/GreenSock/pen/jdawKx)
- ease [Ease] - controls the easing of the animation. Like "power2.inOut", or "elastic", etc.
- onComplete [Function] - a callback function that should be called when all the animation has completed.
- delay [Number] - time (in seconds) that should elapse before any of the animations begin.

This function will return a Timeline containing all the animations.
*/
function flip(elements, changeFunc, vars) {
  elements = gsap.utils.toArray(elements);
  vars = vars || {};
  let tl = gsap.timeline({
      onComplete: vars.onComplete,
      delay: vars.delay || 0,
    }),
    bounds = elements.map((el) => el.getBoundingClientRect()),
    copy = {},
    p;
  elements.forEach((el) => {
    el._flip && el._flip.progress(1);
    el._flip = tl;
  });
  changeFunc();
  for (p in vars) {
    p !== "onComplete" && p !== "delay" && (copy[p] = vars[p]);
  }
  copy.x = (i, element) =>
    "+=" + (bounds[i].left - element.getBoundingClientRect().left);
  copy.y = (i, element) =>
    "+=" + (bounds[i].top - element.getBoundingClientRect().top);
  return tl.from(elements, copy);
}
```

---

## ratio

**URL:** https://gsap.com/docs/v3/GSAP/Tween/ratio.md

**Contents:**
  - ratio
  - Details[‚Äã](#details "Direct link to Details")

**\[read-only]** the progress of the Tween (a value between 0 and 1 where 0.5 is in the middle) **after** being run through the `ease`. So this value may exceed the 0-1 range, like in the case of `ease: "back"` or `ease: "elastic"`. It can be useful as a multiplier for your own interpolation, like in an `onUpdate` callback.

\[read-only] the progress of the Tween (a value between 0 and 1 where 0.5 is in the middle) **after** being run through the `ease`. So this value may exceed the 0-1 range, like in the case of `ease: "back"` or `ease: "elastic"`. It can be useful as a multiplier for your own interpolation, like in an `onUpdate` callback.

So if you have a one second tween with an ease of `"power2.out"`, at the 0.5 second mark (where the progress is also half way), `tween.progress()` will report 0.5 while `tween.ratio` will report 0.875. As the code below shows, `this.ratio` is always equal to value you can obtain from passing the tween's `.progress()` into the ease function.

**Examples:**

Example 1 (unknown):
```unknown
const easeFunc = gsap.parseEase("power2.out");
const tween = gsap.to({ foo: 0 }, { foo: 10, duration: 1, ease: "power2.out" });
tween.pause(0.5); // pause at 0.5 seconds which is halfway in this 1-second tween

console.log(tween.progress()); // 0.5
console.log(tween.ratio); // 0.875
console.log(easeFunc(tween.progress())); // 0.875
```

---

## maxX

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/maxX.md

**Contents:**
  - maxX : Number
  - Details[‚Äã](#details "Direct link to Details")

When bounds are applied, `maxX` refers to the maximum "legal" horizontal property.

*Number* - When bounds are `applied`, `maxX` refers to the maximum "legal" value of the horizontal property (either `"x"` or `"left"`, depending on which type the Draggable is). This makes it easier to run your own custom logic inside the snap or callback function(s) if you so choose. So for a Draggable of `type: "x,y"`, `maxX` would correlate with `x` transform translation, as in the CSS `transform: translateX(...)`. For `type: "top,left"`, the Draggable's `maxX` would correlate with the CSS `left` value that's applied. This is not the global coordinate - it is the inline CSS-related value applied to the element.

---

## Scrub through a `<canvas>` image sequence

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/imageSequenceScrub.md

**Contents:**
    - loading...

Create an Array of image URLs, feed it to this helper function along with a reference to your `<canvas>` object and a ScrollTrigger config object to have it scrub through those, drawing the appropriate one to the canvas.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/VwgevYW?default-tab=result\&theme-id=41164)

**Examples:**

Example 1 (unknown):
```unknown
/*
Helper function that handles scrubbing through a sequence of images, drawing the appropriate one to the provided canvas.
Config object properties:
  - urls [Array]: an Array of image URLs
  - canvas [Canvas]: the <canvas> object to draw to
  - scrollTrigger [Object]: an optional ScrollTrigger configuration object like {trigger: "#trigger", start: "top top", end: "+=1000", scrub: true, pin: true}
  - onUpdate [Function]: optional callback for when the Tween updates (probably not used very often)

 Returns a Tween instance
*/
function imageSequence(config) {
  let playhead = {frame: 0},
      ctx = gsap.utils.toArray(config.canvas)[0].getContext("2d"),
      onUpdate = config.onUpdate,
      images,
      updateImage = function() {
        ctx.drawImage(images[Math.round(playhead.frame)], 0, 0);
        onUpdate && onUpdate.call(this);
      };
    images = config.urls.map((url, i) => {
      let img = new Image();
      img.src = url;
      i || (img.onload = updateImage);
      return img;
    });
    return gsap.to(playhead, {
      frame: images.length - 1,
      ease: "none",
      onUpdate: updateImage,
      scrollTrigger: config.scrollTrigger
    });
}
```

Example 2 (unknown):
```unknown
imageSequence({
  urls, // Array of image URLs
  canvas: "#image-sequence", // <canvas> object to draw images to
  scrollTrigger: {
    start: 0,   // start at the very top
    end: "max", // entire page
    scrub: true // important!
  }
});
```

---

## minX

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/minX.md

**Contents:**
  - minX : Number
  - Details[‚Äã](#details "Direct link to Details")

When bounds are applied, `minX` refers to the minimum "legal" horizontal property.

*Number* - When bounds are `applied`, `minX` refers to the minimum "legal" value of the horizontal property (either `"x"` or `"left"`, depending on which type the Draggable is). This makes it easier to run your own custom logic inside the snap or callback function(s) if you so choose. So for a Draggable of `type: "x,y"`, `minX` would correlate with `x` transform translation, as in the CSS `transform: translateX(...)`. For `type: "top,left"`, the Draggable's `minX` would correlate with the CSS `left` value that's applied. This is not the global coordinate - it is the inline CSS-related value applied to the element.

---

## ScrambleText

**URL:** https://gsap.com/docs/v3/Plugins/ScrambleTextPlugin.md

**Contents:**
    - CDN Link
    - Minimal usage
    - loading...
- Description[‚Äã](#description "Direct link to Description")
- **Config Object**[‚Äã](#config-object "Direct link to config-object")
- Usage[‚Äã](#usage "Direct link to Usage")
- **Demos**[‚Äã](#demos "Direct link to demos")

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/jOjaoYJ?default-tab=result\&theme-id=41164)

Scrambles the text in a DOM element with randomized characters (uppercase by default, but you can define lowercase or a set of custom characters), refreshing new randomized characters at regular intervals while gradually revealing your new text (or the original text) over the course of the tween (left to right by default). Visually it looks like a computer decoding a string of text. Great for rollovers.

You can simply pass a string of text directly as the `scrambleText` and it'll use the defaults for revealing it, or you can customize the settings by using a generic object with any of the following properties:

String - The text that should replace the existing text in the DOM element. If omitted (or if `"{original}"`), the original text will be used.

* #### chars[](#chars)

String - The characters that should be randomly swapped in to the scrambled portion the text. You can use `"upperCase"`, `"lowerCase"`, `"upperAndLowerCase"`, or a custom string of characters, like `"XO"` or `"TMOWACB"`, or `"jompaWB!^"`, etc. Default: `"upperCase"`.

* #### tweenLength[](#tweenLength)

Boolean - If the length of the replacement text is different than the original text, the difference will be gradually tweened so that the length doesn‚Äôt suddenly jump. For example, if the original text is 50 characters and the replacement text is 100 characters, during the tween the number of characters would gradually move from 50 to 100 instead of jumping immediatley to 100. However, if you‚Äôd prefer to have it immediately jump, set `tweenLength` to `false`. Default: `true`.

* #### revealDelay[](#revealDelay)

Number - If you‚Äôd like the reveal (unscrambling) of the new text to be delayed for a certain portion of the tween so that the scrambled text is entirely visible for a while, use revealDelay to define the time you‚Äôd like to elapse before the reveal begins. For example, if the tween‚Äôs duration is 3 seconds but you‚Äôd like the scrambled text to remain entirely visible for first 1 second of the tween, you‚Äôd set `revealDelay` to `1`. Default: `0`.

* #### newClass[](#newClass)

String - If you‚Äôd like the new text to have a particular class applied (using a ``tag wrapped around it), use `newClass: "YOUR_CLASS_NAME"`. This makes it easy to create a distinct look for the new text. Default: `null`.

* #### oldClass[](#oldClass)

String - If you‚Äôd like the **old** (original) text to have a particular class applied (using a ``tag wrapped around it), use `oldClass: "YOUR_CLASS_NAME"`. This makes it easy to create a distinct look for the old text. Default: `null`.

* #### speed[](#speed)

Number - Controls how frequently the scrambled characters are refreshed. The default is `1` but you could slow things down by using `0.2` for example (or any number). Default: `1`.

* #### delimiter[](#delimiter)

String - By default, each character is replaced one-by-one, but if you‚Äôd prefer to have things revealed word-by-word, you could use a delimiter of `" "` (space). Default: `""`.

* #### rightToLeft[](#rightToLeft)

Boolean - If `true` the text will be revealed from right to left. Default: `false`.

Check out the full collection of [text animation demos](https://codepen.io/collection/ExBwoK) on CodePen.

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(ScrambleTextPlugin)
```

Example 2 (unknown):
```unknown
gsap.to(element, {
  duration: 1, 
  scrambleText: "THIS IS NEW TEXT"
});
```

Example 3 (unknown):
```unknown
//use the defaults
gsap.to(element, {duration: 1, scrambleText: "THIS IS NEW TEXT"});//or customize things:

gsap.to(element, {
  duration: 1, 
  scrambleText: {
    text: "THIS IS NEW TEXT", 
    chars: "XO", 
    revealDelay: 0.5, 
    speed: 0.3, 
    newClass: "myClass"
  }
});
```

---

## Hook a Lottie animation up to ScrollTrigger

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/LottieScrollTrigger.md

**Contents:**
  - Usage[‚Äã](#usage "Direct link to Usage")
    - loading...

If you create an animation in After Effects and export it using [Lottie](https://airbnb.io/lottie/), you can hook it up to the scroll position with this handy function so that as the user scrolls, the animation progresses:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/QWdjEbx?default-tab=result\&theme-id=41164)

Special thanks to Chris Gannon for his work on a [tool](https://github.com/chrisgannon/ScrollLottie) that inspired this.

**Examples:**

Example 1 (unknown):
```unknown
function LottieScrollTrigger(vars) {
  let playhead = { frame: 0 },
    target = gsap.utils.toArray(vars.target)[0],
    speeds = { slow: "+=2000", medium: "+=1000", fast: "+=500" },
    st = {
      trigger: target,
      pin: true,
      start: "top top",
      end: speeds[vars.speed] || "+=1000",
      scrub: 1,
    },
    ctx = gsap.context && gsap.context(),
    animation = lottie.loadAnimation({
      container: target,
      renderer: vars.renderer || "svg",
      loop: false,
      autoplay: false,
      path: vars.path,
      rendererSettings: vars.rendererSettings || {
        preserveAspectRatio: "xMidYMid slice",
      },
    });
  for (let p in vars) {
    // let users override the ScrollTrigger defaults
    st[p] = vars[p];
  }
  animation.addEventListener("DOMLoaded", function () {
    let createTween = function () {
      animation.frameTween = gsap.to(playhead, {
        frame: animation.totalFrames - 1,
        ease: "none",
        onUpdate: () => animation.goToAndStop(playhead.frame, true),
        scrollTrigger: st,
      });
      return () => animation.destroy && animation.destroy();
    };
    ctx && ctx.add ? ctx.add(createTween) : createTween();
    // in case there are any other ScrollTriggers on the page and the loading of this Lottie asset caused layout changes
    ScrollTrigger.sort();
    ScrollTrigger.refresh();
  });
  return animation;
}
```

Example 2 (unknown):
```unknown
LottieScrollTrigger({
  target: "#animationWindow",
  path: "https://assets.codepen.io/35984/tapered_hello.json",
  speed: "medium",
  scrub: 2, // seconds it takes for the playhead to "catch up"
  // you can also add ANY ScrollTrigger values here too, like trigger, start, end, onEnter, onLeave, onUpdate, etc. See /docs/v3/Plugins/ScrollTrigger
});
```

---

## DrawSVG

**URL:** https://gsap.com/docs/v3/Plugins/DrawSVGPlugin.md

**Contents:**
    - CDN Link
    - Minimal usage
  - Description[‚Äã](#description "Direct link to Description")
    - loading...
  - How do I animate many strokes and stagger animations?[‚Äã](#how-do-i-animate-many-strokes-and-stagger-animations "Direct link to How do I animate many strokes and stagger animations?")
  - Add `"live"` to recalculate length throughout animation[‚Äã](#add-live-to-recalculate-length-throughout-animation "Direct link to add-live-to-recalculate-length-throughout-animation")
  - Splitting a multi-segment `<path>`[‚Äã](#splitting-a-multi-segment-path "Direct link to splitting-a-multi-segment-path")
    - loading...
  - Caveats / Notes[‚Äã](#caveats--notes "Direct link to Caveats / Notes")
- **Methods**[‚Äã](#methods "Direct link to methods")

DrawSVGPlugin allows you to progressively reveal (or hide) the stroke of an SVG `<path>`, `<line>`, `<polyline>`, `<polygon>`, `<rect>`, or `<ellipse>`. You can even animate outward from the center of the stroke (or any position/segment). It does this by controlling the `stroke-dashoffset` and `stroke-dasharray` CSS properties.

Think of the drawSVG value as describing the stroked portion of the overall SVG element (which doesn't necessarily have to start at the beginning). For example, `drawSVG:"20% 80%"` renders the stroke between the 20% and 80% positions, meaning there's a 20% gap on each end. If you started at `"50% 50%"` and animated to `"0% 100%"`, it would draw the stroke from the middle outward to fill the whole path.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/d99f307bef8b65451613ba899154515b?default-tab=result\&theme-id=41164)

Remember, the `drawSVG` value doesn't describe the values between which you want to animate - it describes the end state to which you're animating (or the beginning if you're using a `from()` tween). So `gsap.to("#path", {duration: 1, drawSVG: "20% 80%"})` animates it from wherever the stroke is currently to a state where the stroke exists between the 20% and 80% positions along the path. It does **NOT** animate it from 20% to 80% over the course of the tween.

This is a **good** thing because it gives you much more flexibility. You're not limited to starting out at a single point along the path and animating in one direction only. You control the whole segment (starting and ending positions). So you could even animate a dash from one end of the path to the other, never changing size, like `gsap.fromTo("#path", {drawSVG: "0 5%"}, {duration: 1, drawSVG: "95% 100%"});`

You may use either percentages or absolute lengths. If you use a single value, `0` is assumed for the starting value, so `"100%"` is the same as `"0 100%"` and `"true"`.

**IMPORTANT:** In order to animate the stroke, you must first actually apply one using either CSS or SVG attributes:

[YouTube video player](https://www.youtube.com/embed/6UAoyBcn2fk)

The great thing about having DrawSVGPlugin integrated into GSAP is that you can tap into the rich API to quickly create complex effects and have total control (`pause`, `resume`, `reverse`, `seek`, nesting, etc.). So let's say you have 20 SVG elements that all have the class `draw-me` applied to them, and you want to draw them in a staggered fashion. You could do:

Or you could create a timeline and drop the tweens into it so that you can control the entire sequence as a whole:

In rare situations, the length of the SVG element itself may change during the drawSVG animation (like if the window is resized and things are responsive). In that case, you can simply append `"live"` to the value which will cause DrawSVGPlugin to update the length on every tick of the animation. So, for example, `drawSVG: "20% 70% live"`.

Usually it's best to use DrawSVGPlugin on `<path>` elements that are just one segment (doesn't contain multiple "M" commands) because browsers have a hard time properly rendering a single stroke through multiple segments, but we've crafted a helper function that automatically splits a multi-segment `<path>` into a `<path>` for each segment, as seen in this demo:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/yLEzJNE?default-tab=result\&theme-id=41164)

* DrawSVGPlugin does not animate the fill of the SVG at all - it only affects the stroke using `stroke-dashoffset` and `stroke-dasharray` CSS properties.

* In some rare situations, Firefox doesn't properly calculate the total length of `<path>` elements, so you may notice that the path stops a bit short even if you animate to 100%. In this (uncommon) scenario, there are two solutions: either add more anchors to your path to make the control points hug closer to the path, or overshoot the percentage a bit, like use `102%` instead of `100%`. To be clear, this is a Firefox bug, not a bug with DrawSVGPlugin.

* As of December 2014, iOS Safari has a bug that causes it to render `<rect>` strokes incorrectly in some cases (too thick, and slight artifacts around the edges, plus it misplaces the origin). The best workaround is to either convert your `<rect>` to a `<path>` or `<polyline>`.

* You cannot affect the contents of a `<use>` element because browsers simply don't allow it. Well, you can tween them but you won't see any changes on the screen.

|                                                                                                                                            |                                                                                                                                                                   |
| ------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| #### [DrawSVGPlugin.getLength](/docs/v3/Plugins/DrawSVGPlugin/static.getLength\(\).md)( element:\[Element \| Selector text] ) : Number     | Provides an easy way to get the length of an SVG element's stroke including: `<path>`, `<rect>`, `<circle>`, `<ellipse>`, `<line>`, `<polyline>`, and `<polygon>` |
| #### [DrawSVGPlugin.getPosition](/docs/v3/Plugins/DrawSVGPlugin/static.getPosition\(\).md)( element:\[Element \| Selector text] ) : Number | Provides an easy way to get the current position of the DrawSVG.                                                                                                  |

Check out the full collection of [How-to demos](https://codepen.io/collection/XRqLgd) and our favourite [inspiring community demos](https://codepen.io/collection/DYmKKD) on CodePen.

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(DrawSVGPlugin)
```

Example 2 (unknown):
```unknown
//draws all elements with the "draw-me" class applied
gsap.from('.draw-me', { duration: 1, drawSVG: 0 });
```

Example 3 (unknown):
```unknown
/* Define a stroke and stroke-width in CSS: */
.yourPath {
  stroke-width: 10px;
  stroke: red;
}

/* or as SVG attributes: */
<path ... stroke-width="10px" stroke="red" />
```

Example 4 (unknown):
```unknown
//draws all elements with the "draw-me" class applied with staggered start times 0.1 seconds apart
gsap.from('.draw-me', { duration: 1, stagger: 0.1, drawSVG: 0 });
```

---

## gsap.utils

**URL:** https://gsap.com/docs/v3/GSAP/gsap.utils.md

**Contents:**
  - Type : Object[‚Äã](#type--object "Direct link to Type : Object")

Combining utility Methods

[YouTube video player](https://www.youtube.com/embed/NqiF5xIuMd0)

`gsap.utils` provides access to some surprisingly helpful utility functions. Note that many of them can optionally return FUNCTIONS so that they can be plugged directly into tweens, leveraging GSAP's function-based capabilities. In that case, they'll get called once for each target rather than just using the same end value for them all.

| Utility                                                          | Description                                                                                                                                                                                                                                                                                                                                                                                                                               |
| ---------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [checkPrefix()](/docs/v3/GSAP/UtilityMethods/checkPrefix\(\).md) | Prefixes the provided CSS property if necessary (ex: `checkPrefix("transform")` --> `"msTransform"` when run in IE9; returns null if the property isn't supported at all).                                                                                                                                                                                                                                                                |
| [clamp()](/docs/v3/GSAP/UtilityMethods/clamp\(\).md)             | Clamp a value to fit within a specific range (ex: `clamp(0, 100, -12)` --> `0`).                                                                                                                                                                                                                                                                                                                                                          |
| [distribute()](/docs/v3/GSAP/UtilityMethods/distribute\(\).md)   | Distribute a value among an array of objects either linearly or according to their position in a grid, optionally with easing applied.                                                                                                                                                                                                                                                                                                    |
| [getUnit()](/docs/v3/GSAP/UtilityMethods/getUnit\(\).md)         | Get the unit of a string (ex: `getUnit("30px")` --> `"px"`).                                                                                                                                                                                                                                                                                                                                                                              |
| [interpolate()](/docs/v3/GSAP/UtilityMethods/interpolate\(\).md) | Interpolate between almost any two values (numbers, colors, strings, arrays, complex strings, or even objects with multiple properties) (ex: `interpolate("red", "blue", 0.5)` --> `"rgba(128,0,128,1)"`).                                                                                                                                                                                                                                |
| [mapRange()](/docs/v3/GSAP/UtilityMethods/mapRange\(\).md)       | Map one range to another (ex: `mapRange(-10, 10, 0, 100, 5)` --> `75`).                                                                                                                                                                                                                                                                                                                                                                   |
| [normalize()](/docs/v3/GSAP/UtilityMethods/normalize\(\).md)     | Map a number within a range to a progress between 0 to 1 (ex: `normalize(100, 200, 150)` --> `0.5`).                                                                                                                                                                                                                                                                                                                                      |
| [`pipe()`](/docs/v3/GSAP/UtilityMethods/pipe\(\).md)             | Sequence a number of function calls, passing the result of each into the next (ex: `pipe(clamp(0, 100), snap(5))(8)` --> `10`).                                                                                                                                                                                                                                                                                                           |
| [random()](/docs/v3/GSAP/UtilityMethods/random\(\).md)           | Generate a random number based on parameters (ex: `random(0, 100, 5)` --> `65`) or randomly pick an element from in a supplied array (ex. `random(["red", "green", "blue"])` --> `"red"`).                                                                                                                                                                                                                                                |
| [selector()](/docs/v3/GSAP/UtilityMethods/selector\(\).md)       | Returns a selector **function** that is scoped to a particular Element (or React ref or Angular ElementRef). (ex: `selector(myElement)`)                                                                                                                                                                                                                                                                                                  |
| [shuffle()](/docs/v3/GSAP/UtilityMethods/shuffle\(\).md)         | Shuffles the contents of an array in-place. (ex: `shuffle([1, 2, 3, 4, 5])` --> `[4, 2, 1, 5, 3]`)                                                                                                                                                                                                                                                                                                                                        |
| [snap()](/docs/v3/GSAP/UtilityMethods/snap\(\).md)               | Snap a value to either an increment (ex: `snap(5, 13)` --> `15`) or to the closest value in an array (ex: `snap([0, 5, 10], 7)` --> `5`).                                                                                                                                                                                                                                                                                                 |
| [splitColor()](/docs/v3/GSAP/UtilityMethods/splitColor\(\).md)   | Split any color into its red, green, blue (and optionally alpha) components. Or hue, saturation, and brightness. (ex: `splitColor("red")` --> `[255, 0, 0]`).                                                                                                                                                                                                                                                                             |
| [toArray()](/docs/v3/GSAP/UtilityMethods/toArray\(\).md)         | Convert almost any array-like object to an array, including selector text! (ex: `toArray(".class")` --> `[element1, element2]`).                                                                                                                                                                                                                                                                                                          |
| [unitize()](/docs/v3/GSAP/UtilityMethods/unitize\(\).md)         | Wraps around another utility function, allowing it to accept values with units like `"20px"` or `"50%"`, stripping off the unit when feeding into the wrapped utility function, and then adding it back to the result (ex. `var wrap = gsap.utils.unitize( gsap.utils.wrap(0, 100) ); wrap("150px");` --> `"50px"`). Or force a specific unit (ex: `unitize( gsap.utils.mapRange(-10, 10, 0, 100), "%");` --> always returns with `"%"`). |
| [wrap()](/docs/v3/GSAP/UtilityMethods/wrap\(\).md)               | Place a number into a specified range such that when it exceeds the maximum, it wraps back to the start and if it is less than the minimum, it wraps to the end (ex. `wrap(5, 10, 12)` --> `7`). Or cycle through an **Array** such that when the provided index is greater than the length of the array, it wraps back to the start (ex: `wrap([0, 10, 20], 4)` --> `10`).                                                               |
| [wrapYoyo()](/docs/v3/GSAP/UtilityMethods/wrapYoyo\(\).md)       | Place a number into a specified range such that when it exceeds the maximum, it yoyos back toward the start and if it is less than the minimum, it yoyos forward to the end (ex. `wrapYoyo(5, 10, 12)` --> `8`). Or cycle through an **Array** such that when the provided index is greater than the length of the array, it yoyos back to the start (ex: `wrap([0, 10, 20, 30], 4)` --> `20`)                                            |

---

## PhysicsProps

**URL:** https://gsap.com/docs/v3/Plugins/PhysicsPropsPlugin.md

**Contents:**
    - CDN Link
    - Minimal usage
- Description[‚Äã](#description "Direct link to Description")
- **Config Object**[‚Äã](#config-object "Direct link to config-object")
- **Demos**[‚Äã](#demos "Direct link to demos")

Sometimes it's useful to tween a value at a particular velocity and/or acceleration without a specific end value in mind. PhysicsPropsPlugin allows you to tween **any** numeric property of **any** object based on these concepts. Keep in mind that any easing equation you define for your tween will be completely ignored for these properties. Instead, the physics parameters will determine the movement/easing.

Number - The initial velocity of the object measured in units per second. Default: `0`.

* #### acceleration[](#acceleration)

Number - The amount of acceleration applied to the object, measured in units per second. Default: `0`.

* #### friction[](#friction)

Number - A value between 0 and 1 where 0 is no friction, 0.08 is a small amount of friction, and 1 will completely prevent any movement. This is not meant to be precise or scientific in any way, but it serves as an easy way to apply a friction-like physics effect to your tween. Generally it is best to experiment with this number a bit, starting at a very low value like `0.02`. Also note that friction requires more processing than physics tweens without any friction. Default: `0`.

These parameters are not intended to be dynamically updateable. But one unique convenience is that everything is reverseable. So if you create several physics-based tweens, for example, and throw them into a timeline, you could simply call reverse() on the timeline to watch the objects retrace their steps right back to the beginning. Here are the parameters you can define (note that `friction` and `acceleration` are both completely optional):

* [PhysicsProps demos](https://codepen.io/collection/nwMRgp)

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(PhysicsPropsPlugin)
```

Example 2 (unknown):
```unknown
gsap.to(obj, {
  duration: 2,
  physicsProps: {
    x: { velocity: 100, acceleration: 200 },
    y: { velocity: -200, friction: 0.1 },
  },
});
```

---

## Easel

**URL:** https://gsap.com/docs/v3/Plugins/EaselPlugin.md

**Contents:**
    - CDN Link
    - Minimal usage
  - Description[‚Äã](#description "Direct link to Description")

Tweens special EaselJS-related properties for things like `saturation`, `contrast`, `tint`, `colorize`, `brightness`, `exposure`, and `hue` which leverage EaselJS's `ColorFilter` and `ColorMatrixFilter` (see [the EaselJS website](//www.createjs.com/#!/EaselJS) for more information about EaselJS). You don't need the plugin to tween normal numeric properties of EaselJS objects (like `x` and `y`), but some filters or effects require special manipulation which is what EaselPlugin is for. Currently it only handles special properties related to `ColorFilter` and `ColorMatrixFilter`, and it can tween the `frame` property of a `MovieClip`.

GreenSock's EaselPlugin exposes convenient properties that aren't a part of EaselJS's API like `tint`, `tintAmount`, `exposure`, and `brightness` for `ColorFilter`, as well as `saturation`, `hue`, `contrast`, `colorize`, and `colorizeAmount` for `ColorMatrixFilter`. Simply wrap the values that you'd like to tween in an `easel: {}` object. Here are some examples:

You can also tween any individual properties of the `ColorFilter` object like this:

Or you can tween things like the `exposure` of an image which is a value from 0-2 where 1 is normal exposure, 2 is completely overexposed (white) and 0 is completely underexposed (black). Or define a `brightness` value which uses the same concept: a value from 0-2. These effects can be very useful for images in particular.

A common mistake is to forget to wrap EaselJS-related properties in an easel object which is essential for specifying your intent. You also must load the EaselJS's `ColorFilter` and/or `ColorMatrixFilter` JavaScript files.

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(EaselPlugin)
```

Example 2 (unknown):
```unknown
gsap.ticker.add(() => stage.update());

gsap.to(circle, {
  duration: 2,
  scaleX: 0.5,
  scaleY: 0.5,
  easel: { tint: 0x00ff00 },
});
```

Example 3 (unknown):
```unknown
//setup stage and create a Shape into which we'll draw a circle later...
var canvas = document.getElementById("myCanvas"),
  stage = new createjs.Stage(canvas),
  circle = new createjs.Shape(),
  g = circle.graphics;

//draw a red circle in the Shape
g.beginFill(createjs.Graphics.getRGB(255, 0, 0));
g.drawCircle(0, 0, 100);
g.endFill();

//in order for the ColorFilter to work, we must cache() the circle
circle.cache(-100, -100, 200, 200);

//place the circle at 200,200
circle.x = 200;
circle.y = 200;

//add the circle to the stage
stage.addChild(circle);

//setup a "tick" event listener so that the EaselJS stage gets updated on every frame/tick
gsap.ticker.add(() => stage.update());
stage.update();

//tween the tint of the circle to green and scale it to half-size
gsap.to(circle, {
  duration: 2,
  scaleX: 0.5,
  scaleY: 0.5,
  easel: { tint: 0x00ff00 },
});

//tween to a different tint that is only 50% (mixing with half of the original color) and animate the scale, position, and rotation simultaneously.
gsap.to(circle, {
  duration: 3,
  scaleX: 1.5,
  scaleY: 0.8,
  x: 250,
  y: 150,
  rotation: 180,
  easel: { tint: "#0000FF", tintAmount: 0.5 },
  delay: 3,
  ease: "elastic",
});

//then animate the saturation down to 0
gsap.to(circle, { duration: 2, easel: { saturation: 0 }, delay: 6 });
```

Example 4 (unknown):
```unknown
gsap.to(circle, {
  duration: 3,
  easel: {
    colorFilter: { redMultiplier: 0.5, blueMultiplier: 0.8, greenOffset: 100 },
  },
});
```

---

## data

**URL:** https://gsap.com/docs/v3/GSAP/Timeline/data.md

**Contents:**
  - data : \*
  - Details[‚Äã](#details "Direct link to Details")

A place to store any data you want (initially populated with `vars.data` if it exists).

A place to store any data you want (initially populated with `vars.data` if it exists).

---

## Force GSAP to update while in hidden tab

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/tickGSAPWhileHidden.md

Most browsers pause requestAnimationFrame() calls while a browser tab is hidden in order to reduce CPU/battery drain, but if you'd like GSAP to continue to update (at a reduced rate, typically about 2fps due to browsers throttling setInterval()/setTimeout()), you can use this function:

**Examples:**

Example 1 (unknown):
```unknown
function tickGSAPWhileHidden(value) {
  if (value === false) {
    document.removeEventListener("visibilitychange", tickGSAPWhileHidden.fn);
    return clearInterval(tickGSAPWhileHidden.id);
  }
  const onChange = () => {
    clearInterval(tickGSAPWhileHidden.id);
    if (document.hidden) {
      gsap.ticker.lagSmoothing(0); // keep the time moving forward (don't adjust for lag)
      tickGSAPWhileHidden.id = setInterval(gsap.ticker.tick, 500);
    } else {
      gsap.ticker.lagSmoothing(500, 33); // restore lag smoothing
    }
  };
  document.addEventListener("visibilitychange", onChange);
  tickGSAPWhileHidden.fn = onChange;
  onChange(); // in case the document is currently hidden.
}

tickGSAPWhileHidden(true);
```

---

## Change transformOrigin without a jump

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/smoothOriginChange.md

**Contents:**
    - loading...

If you want to change `transformOrigin` dynamically without a jump, you'd need to compensate its translation (x/y). Here's a function I whipped together for that purpose:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/feb24447fb7c6a82e777a0110c281a31?default-tab=result\&theme-id=41164)

**Examples:**

Example 1 (unknown):
```unknown
function smoothOriginChange(targets, transformOrigin) {
  gsap.utils.toArray(targets).forEach(function (target) {
    var before = target.getBoundingClientRect();
    gsap.set(target, { transformOrigin: transformOrigin });
    var after = target.getBoundingClientRect();
    gsap.set(target, {
      x: "+=" + (before.left - after.left),
      y: "+=" + (before.top - after.top),
    });
  });
}
```

---

## gsap.effects

**URL:** https://gsap.com/docs/v3/GSAP/gsap.effects.md

**Contents:**
  - Type : Object[‚Äã](#type--object "Direct link to Type : Object")
    - loading...
    - loading...

Once an effect has been [registered](/docs/v3/GSAP/gsap.registerEffect\(\).md), you can access it directly on the `gsap.effects` object like this:

Or, if you set `extendTimeline: true` on the effect when registering it, you'll even be able to call it DIRECTLY on timelines in order to have the results of the effect inserted into that timeline (see below). Effects make it easy for anyone to author custom animation code wrapped in a function (which accepts `targets` and a `config` object) and then associate it with a specific `name` so that it can be called anytime with new targets and configurations. For example, maybe we want to be able to make things fade (which is rather silly because it's so simplistic, but the goal here is to show how it could work):

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/MWgmQmM?default-tab=result\&theme-id=41164)

GSAP provides 4 key services here:

* It parses the "targets" into an array. So if selector text is passed in, it becomes an array of elements passed to the effect function.
* It applies defaults to the config object every time. No need to add a bunch of if statements or apply the defaults yourself.
* It provides a centralized way of registering/accessing these "effects".
* If you set `extendTimeline: true`, the effect's name will be added as a method to GSAP's Timeline prototype, meaning that you can insert an instance of that effect directly into any timeline like:

So it can save you a lot of typing if you're making heavy use of an effect in your sequences.

**important**: any effect with `extendTimeline:true` **must** return a GSAP-compatible animation that could be inserted into a timeline (a Tween or Timeline instance)

For a quick overview of how to register effects, check out this video from the Snorkl.tv's [Creative Coding Club](https://www.creativecodingclub.com/bundles/creative-coding-club?ref=44f484) - one of the best ways to learn the basics of how to use GSAP.

Effects are also easily shared between different projects and people. To view effects that have already been created, check out [the CodePen collection](https://codepen.io/collection/bdffa09755cbd27a69b22771bd98e565/).

Here's an example of multiple pre-made fade effects being generated so that they can be reused later:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/Rwajpyb?default-tab=result\&theme-id=41164)

**Examples:**

Example 1 (unknown):
```unknown
//assumes that an effect named "explode" has already been registered

gsap.effects.explode(".box", {
  direction: "up", //can reference any properties that the author decides - in this case "direction"
  duration: 3,
});
```

Example 2 (unknown):
```unknown
// register the effect with GSAP:
gsap.registerEffect({
  name: "fade",
  effect: (targets, config) => {
    return gsap.to(targets, { duration: config.duration, opacity: 0 });
  },
  defaults: { duration: 2 }, //defaults get applied to any "config" object passed to the effect
  extendTimeline: true, //now you can call the effect directly on any GSAP timeline to have the result immediately inserted in the position you define (default is sequenced at the end)
});

// now we can use it like this:
gsap.effects.fade(".box");

// or directly on timelines:
let tl = gsap.timeline();
tl.fade(".box", { duration: 3 })
  .fade(".box2", { duration: 1 }, "+=2")
  .to(".box3", { x: 100 });
```

Example 3 (unknown):
```unknown
//with extendTimeline: true
var tl = gsap.timeline();
tl.yourEffect(".class", { configProp: "value" }, "+=position");

//without extendTimeline: true, you'd have to do this to add an instance to the timeline:
tl.add(
  gsap.effects.yourEffect(".class", { configProp: "value" }),
  "+=position"
);
```

---

## lines

**URL:** https://gsap.com/docs/v3/Plugins/SplitText/lines.md

**Contents:**
  - lines : Array
  - Details[‚Äã](#details "Direct link to Details")

An array containing all of the lines' raw DOM element that were split apart.

An array containing all of the lines' raw DOM element that were split apart. For example, if the original text was broken onto 4 lines vertically, the `lines` array would contain 4 elements.

---

## y

**URL:** https://gsap.com/docs/v3/Plugins/Observer/y.md

**Contents:**
  - y : Number
  - Details[‚Äã](#details "Direct link to Details")

the `clientY` from the most recent touch/pointer event, which refers to the vertical distance from the top edge of the viewport. This only gets updated if you set the `type` to include "touch" and/or "pointer".

the `clientY` from the most recent touch/pointer event, which refers to the vertical distance from the top edge of the viewport. This only gets updated if you set the `type` to include "touch" and/or "pointer".

---

## Get the scroll position associated with a particular ScrollTriggered animation

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/getScrollPosition.md

**Contents:**
    - loading...

Perhaps you want to scroll the page to the exact spot where a particular scroll-triggered animation starts (or ends or any progress value) - just feed this helper function your animation (it must have a ScrollTrigger of course) and optionally a progress value (0 is when the animation starts, 0.5 is halfway through, 1 is the end) and it'll return the scroll position which you could feed into a scrollTo tween, for example:

It even works with the "containerAnimation" feature:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/xxPNyyO?default-tab=result\&theme-id=41164)

**Examples:**

Example 1 (unknown):
```unknown
function getScrollPosition(animation, progress) {
  let p = gsap.utils.clamp(0, 1, progress || 0),
    st = animation.scrollTrigger,
    containerAnimation = st.vars.containerAnimation;
  if (containerAnimation) {
    let time = st.start + (st.end - st.start) * p;
    st = containerAnimation.scrollTrigger;
    return (
      st.start + (st.end - st.start) * (time / containerAnimation.duration())
    );
  }
  return st.start + (st.end - st.start) * p;
}
```

---

## lockAxis

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/lockAxis.md

**Contents:**
  - lockAxis : Boolean
  - Details[‚Äã](#details "Direct link to Details")

Locks movement to one axis based on the how it is moved initially.

*Boolean* - If `true`, dragging more than 2 pixels in either direction (horizontally or vertically) will lock movement into that axis so that the element can only be dragged that direction (horizontally or vertically, whichever had the most initial movement). No diagonal movement will be allowed. Obviously this is only applicable for `type: "x,y"` and `type: "top,left"` and `type: "scroll"` Draggables. If you only want to allow vertical movement, you should set the `type` to `"y"`, `"top"`, or `"scrollTop"`. If you only want to allow horizontal movement, you should set the `type` to `"x"`, `"left"`, or `"scrollLeft"`.

---

## .end

**URL:** https://gsap.com/docs/v3/Plugins/ScrollTrigger/end.md

**Contents:**
  - .end : Number
  - Details[‚Äã](#details "Direct link to Details")

\[read-only] The ScrollTrigger's ending scroll position (numeric, in pixels).

\[read-only] The ScrollTrigger's ending scroll position (numeric, in pixels). This value gets calculated when the ScrollTrigger is refreshed, so anytime the window/scroller gets resized it'll be recalculated.

For example, if the trigger element is 100px below the bottom of the viewport (out of view), and the ScrollTrigger's [vars](/docs/v3/Plugins/ScrollTrigger/vars.md) had `end: "top bottom"`, then the ScrollTrigger's calculated `end` property would be 100 (meaning it'd have to scroll 100px to hit the ending point).

The ScrollTrigger's `start` and `end` properties will always be numeric and reflect the scroll position in pixels.

---

## Calculate progress values for anchor points along a path

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/anchorsToProgress.md

**Contents:**
- Demo[‚Äã](#demo "Direct link to Demo")
    - loading...

Calculate all the progress values for the anchor points on a path so that, for example, you could use DrawSVG to animate point-by-point (requires [MotionPathPlugin](/docs/v3/Plugins/MotionPathPlugin.md)):

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/mdyxvGX?default-tab=result\&theme-id=41164)

**Examples:**

Example 1 (unknown):
```unknown
// returns an array with the progress value (between 0 and 1) for each anchor along the path
function anchorsToProgress(rawPath, resolution) {
  resolution = ~~resolution || 12;
  if (!Array.isArray(rawPath)) {
    rawPath = MotionPathPlugin.getRawPath(rawPath);
  }
  MotionPathPlugin.cacheRawPathMeasurements(rawPath, resolution);
  let progress = [0],
    length,
    s,
    i,
    e,
    segment,
    samples;
  for (s = 0; s < rawPath.length; s++) {
    segment = rawPath[s];
    samples = segment.samples;
    e = segment.length - 6;
    for (i = 0; i < e; i += 6) {
      length = samples[(i / 6 + 1) * resolution - 1];
      progress.push(length / rawPath.totalLength);
    }
  }
  return progress;
}
```

---

## start

**URL:** https://gsap.com/docs/v3/Plugins/ScrollTrigger/start.md

**Contents:**
  - start : Number
  - Details[‚Äã](#details "Direct link to Details")

\[read-only] The ScrollTrigger's starting scroll position (numeric, in pixels).

\[read-only] The ScrollTrigger's starting scroll position (numeric, in pixels). This value gets calculated when the ScrollTrigger is refreshed, so anytime the window/scroller gets resized it'll be recalculated.

For example, if the trigger element is 100px below the bottom of the viewport (out of view), and the ScrollTrigger's [vars](/docs/v3/Plugins/ScrollTrigger/vars.md) had `start: "top bottom"`, then the ScrollTrigger's calculated `start` property would be 100 (meaning it'd have to scroll 100px to hit the starting point).

The ScrollTrigger's `start` and `end` properties will always be numeric and reflect the scroll position in pixels.

---

## startY

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/startY.md

**Contents:**
  - startY : Number
  - Details[‚Äã](#details "Direct link to Details")

\[read-only] The starting `y` (vertical) position of the Draggable instance when the most recent drag began.

\[read-only] The starting `y` (vertical) position of the Draggable instance when the most recent drag began. For a Draggable of `type: "x,y"`, it would be the `y` transform translation, as in the CSS `transform: translateY(...)`. For `type: "top,left"`, the Draggable's `y` would refer to the CSS `top` value that's applied. This is not the global coordinate - it is the inline CSS-related value applied to the element.

---

## .trigger

**URL:** https://gsap.com/docs/v3/Plugins/ScrollTrigger/trigger.md

**Contents:**
  - .trigger : Element | undefined
  - Returns : Element | undefined[‚Äã](#returns--element--undefined "Direct link to Returns : Element | undefined")
  - Details[‚Äã](#details "Direct link to Details")
- Example[‚Äã](#example "Direct link to Example")

\[read-only] The trigger element (if one was defined). If selector text was used, like ".trigger", the `trigger` will be the element itself (not selector text)

The trigger element (if one was defined)

\[read-only] The trigger element (if one was defined). If selector text was used, like ".trigger", the `trigger` will be the element itself (not selector text). Also note that it is possible to define a ScrollTrigger *without* a trigger because `start` and `end` can be **numbers** which are specific scroll values that aren't based on where a trigger element is in the document flow.

**Examples:**

Example 1 (unknown):
```unknown
let st = ScrollTrigger.create({
  trigger: ".trigger",
  start: "top center",
  end: "+=500",
});

console.log(st.trigger); // trigger element (not selector text)
```

---

## GSAP

**URL:** https://gsap.com/docs/v3/GSAP.md

**Contents:**
    - Minimal usage
  - What's a Tween?[‚Äã](#whats-a-tween "Direct link to What's a Tween?")
    - Common methods for creating a Tween:[‚Äã](#common-methods-for-creating-a-tween "Direct link to Common methods for creating a Tween:")
    - loading...
  - What's a Timeline?[‚Äã](#whats-a-timeline "Direct link to What's a Timeline?")
    - Method for creating a Timeline:[‚Äã](#method-for-creating-a-timeline "Direct link to Method for creating a Timeline:")
- Sequencing[‚Äã](#sequencing "Direct link to Sequencing")
    - loading...
- Positioning[‚Äã](#positioning "Direct link to Positioning")
  - Labels[‚Äã](#labels "Direct link to Labels")

or via a package manager like npm

The `gsap` object serves as the access point for most of GSAP's functionality. It's just a generic object with various methods and properties that create and control [Tweens](/docs/v3/GSAP/Tween.md) and [Timelines](/docs/v3/GSAP/Timeline.md), two of the most important concepts to understand.

For a quick overview of the GSAP object, check out this video from the ["GSAP 3 Express" course](https://courses.snorkl.tv/courses/gsap-3-express?ref=44f484) by Snorkl.tv - one of the best ways to learn the basics.

To get the most out of GSAP, it's crucial that you understand what Tweens and Timelines are:

A [Tween](/docs/v3/GSAP/Tween.md) is what does all the animation work - think of it like a **high-performance property setter**. You feed in targets (the objects you want to animate), a duration, and any properties you want it to animate and then when the Tween's playhead moves to a new position, figures out what the property values should be at that point applies them accordingly.

* [gsap.to()](/docs/v3/GSAP/gsap.to\(\).md)
* [gsap.from()](/docs/v3/GSAP/gsap.from\(\).md)
* [gsap.fromTo()](/docs/v3/GSAP/gsap.fromTo\(\).md)

For simple animations (no fancy sequencing), the methods above are all you need! For example:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/663f83b218082c4181ae23fd42d59cb5?default-tab=result\&theme-id=41164)

You can do basic sequencing by using the `delay` special property, but Timelines make sequencing and complex choreography much, much easier.

A [Timeline](/docs/v3/GSAP/Timeline.md) is a **container for Tweens.** It's the ultimate sequencing tool that lets you position animations in time wherever you want and then control the whole sequence easily with methods like [pause()](/docs/v3/GSAP/Timeline/pause\(\).md), [play()](/docs/v3/GSAP/Timeline/play\(\).md), [progress()](/docs/v3/GSAP/Timeline/progress\(\).md), [reverse()](/docs/v3/GSAP/Timeline/reverse\(\).md), [timeScale()](/docs/v3/GSAP/Timeline/timeScale\(\).md), etc.

Create as many Timelines as you want. You can even **nest them** which is fantastic for modularizing your animation code! Every animation (Tween and Timeline) gets placed onto a parent timeline (the [globalTimeline](/docs/v3/GSAP/gsap.globalTimeline\(\)) by default). Moving a Timeline's playhead cascades down through its children so that the playheads stay aligned. A Timeline is purely about grouping things and coordinating time/playheads - it never actually sets properties on targets (Tweens handle that).

* [gsap.timeline()](/docs/v3/GSAP/gsap.timeline\(\).md)

GSAP's API lets you control virtually anything on-the-fly, such as the playhead position, the [startTime](/docs/v3/GSAP/Tween/startTime\(\).md) of any child, even play/pause/reverse the timeline or alter the timeScale itself.

First, create a Timeline:

Then add a tween using one of the convenience methods - [to()](/docs/v3/GSAP/Timeline/to\(\).md), [from()](/docs/v3/GSAP/Timeline/from\(\).md), or [fromTo()](/docs/v3/GSAP/Timeline/fromTo\(\).md):

Do that as many times as you want. Notice we're calling `.to()` **on the timeline instance** (the variable `tl` in this case), not the `gsap` object. This creates a tween and immediately puts it into that particular Timeline. `gsap.to()`, on the other hand, creates a standalone tween. By default, the animations will be sequenced one-after-the-other. You can even use method chaining to simplify your code like this:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/d0b24f699d5bee2305cb8223de580a62?default-tab=result\&theme-id=41164)

The whole GSAP platform is object-oriented and you could create individual tween instances with [gsap.to()](/docs/v3/GSAP/gsap.to\(\).md), for example, and then [timeline.add()](/docs/v3/GSAP/Timeline/add\(\).md) each one but it's just easier to call .to(), .from(), or .fromTo() directly on the Timeline instance to do the same thing in fewer steps.

Define **exactly** where you want your animations to be placed into the timeline by using the optional [position parameter](/resources/position-parameter.md). A number indicates an absolute time (in seconds), or a string with a `"+="` or `"-="` prefix indicates an offset relative to the END of the timeline. For example, `"+=2"` would be 2 seconds after the end, creating a 2-second gap. `"-=2"` would create a 2-second overlap.

Use labels to mark certain spots on the timeline so that you can place animations there or navigate there during playback.

[Tween](/docs/v3/GSAP/Tween.md) and [Timeline](/docs/v3/GSAP/Timeline.md) both extend an Animation class that exposes a myriad of useful methods and properties. Here are some of the most frequently used:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/OJLgdyg?default-tab=result\&theme-id=41164)

Reference the Tween or Timeline instance with a variable, and then control it whenever you want:

**Examples:**

Example 1 (unknown):
```unknown
npm install gsap
```

Example 2 (unknown):
```unknown
import { gsap } from "gsap"
```

Example 3 (unknown):
```unknown
// This is a Tween
gsap.to(".box", { rotation: 27, x: 100, duration: 1 });

// And this is a Timeline, containing three sequenced tweens
let tl = gsap.timeline();
tl.to("#green", {duration: 1, x: 786})
  .to("#blue", {duration: 2, x: 786})
  .to("#orange", {duration: 1, x: 786})
```

Example 4 (unknown):
```unknown
//rotate and move elements with a class of "box" ("x" is a shortcut for a translateX() transform) over the course of 1 second.
gsap.to(".box", { rotation: 27, x: 100, duration: 1 });
```

---

## words

**URL:** https://gsap.com/docs/v3/Plugins/SplitText/words.md

**Contents:**
  - words : Array
  - Details[‚Äã](#details "Direct link to Details")

An array containing all of the words' raw DOM elements that were split apart.

An array containing all of the words' raw DOM elements that were split apart. For example, if the original text was "my split text", the `words` array would contain 3 elements.

---

## progress

**URL:** https://gsap.com/docs/v3/Plugins/ScrollTrigger/progress.md

**Contents:**
  - progress : Number
  - Details[‚Äã](#details "Direct link to Details")
- Example[‚Äã](#example "Direct link to Example")

\[read-only] The overall progress of the ScrollTrigger instance where 0 is at the start, 0.5 is in the middle, and 1 is at the end.

\[read-only] The overall progress of the ScrollTrigger instance where 0 is at the start, 0.5 is in the middle, and 1 is at the end.

**Examples:**

Example 1 (unknown):
```unknown
ScrollTrigger.create({
  trigger: ".trigger",
  start: "top center",
  end: "+=500",
  onUpdate: (self) => console.log("progress:", self.progress),
});
```

---

## Flip

**URL:** https://gsap.com/docs/v3/Plugins/Flip.md

**Contents:**
    - CDN Link
    - Minimal usage
- What people are saying:
- Video[‚Äã](#video "Direct link to Video")
    - loading...
- Features[‚Äã](#features "Direct link to Features")
- How does Flip work?[‚Äã](#how-does-flip-work "Direct link to How does Flip work?")
- Simple example[‚Äã](#simple-example "Direct link to Simple example")
    - loading...
- Flex example[‚Äã](#flex-example "Direct link to Flex example")

added in v<!-- -->3.9.0

Flip involves a whole different way of thinking about animation. Once you get it, you'll be wowed.

Flip plugin lets you seamlessly transition between two states even if there are sweeping changes to the structure of the DOM that would normally cause elements to jump.

Flip records the current position/size/rotation of your elements, you make whatever changes you want, and then Flip applies offsets to make them ***look*** like they never moved... Lastly FLIP animates the **removal** of those offsets! UI transitions become remarkably simple to code. Flip does all the heavy lifting.

> *Experimenting more with GSAP's flip plugin and I'm blown away by how much this accelerates development! What a powerful tool!*&#xD83D;&#xDCAA;*"* - Manoela Ilic, Codrops

> *"HOW DOES IT KNOW WHAT TO DO?* ÔøΩ&#xDD2F;*"* - @georgedoescode

> *"I'm truly amazed at the power of GSAP and FLIP."* - @Alex.Marti

> *"My 'Wow' of the week goes to the Flip Plugin. Star-struck. It's soooo smart!"* - @PeHaa

Of course like all GreenSock tools, there's a rich API for finessing effects and getting exactly the look you want.

"**FLIP**" is an animation technique that stands for "**F**irst", "**L**ast", "**I**nvert", "**P**lay" and was coined [by Paul Lewis](https://aerotwist.com/blog/flip-your-animations/). Here's a demo of how it works:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/ad75564d0ac3e9c6dcaf26e85838ee2a?default-tab=result\&theme-id=41164)

* **Nested transforms? No problem!** Most FLIP libraries only calculate basic offsets assuming no transforms beyond x/y, so a scaled parent breaks things. Rotations certainly aren't allowed. GSAP's Flip plugin **just works**!
* Set `absolute: true` to **make elements use `position: absolute` during the flip**. This solves layout challenges with flexbox, grid, etc. You can even define a subset of targets, like `absolute: ".box"`
* One flip can handle **multiple elements** and even stagger them.
* **Resize via width/height properties** (default) **or scaleX/scaleY** (`scale: true`)
* You get the **full power of GSAP under the hood**, so you can use any `ease`, define special properties like `onComplete`, `onUpdate`, `repeat`, `yoyo`, and even `add()` other animations with total control of timing, etc.

* **Apply a CSS class during the flip with `toggleClass`**. It'll be removed at the end of the flip.
* **[Flip.fit()](/docs/v3/Plugins/Flip/static.fit\(\).md) repositions/resizes one element to fit perfectly on top another (or even a previous state of the same element)**.
* **Compensate for nested offsets**. If a container element is getting flipped along with some of its children, set `nested: true` to prevent the offsets from compounding.
* **Smoothly handles interruptions**.
* **Flip one element to another**; even have them cross-fade (`fade: true`). Just give them the same `data-flip-id` attribute to correlate them.
* **`onEnter` and `onLeave` callbacks** for when elements enter or leave (like if the flip senses a `display: none` toggle and there's no matching target to swap), making it easy to elegantly animate on/off elements.
* **Batch** multiple Flip animations so they don't step on each other's toes, like in a React app with multiple independent components that need to work together.

There are typically 3 steps to a "FLIP" animation:

1. ### Get the current state[‚Äã](#get-the-current-state "Direct link to Get the current state")

This merely captures some data about the current state. Use selector text, an Element, an Array of Elements, or NodeList. [Flip.getState()](/docs/v3/Plugins/Flip/static.getState\(\).md) doesn't alter anything (unless there's an active flip animation affecting any of the targets in which case it will force it to completion to capture the final state accurately). By default, Flip only concerns itself with position, size, rotation, and skew. If you want your Flip animations to affect other CSS properties, you can define a configuration object with a comma-delimited list of `props`, like:

2. ### Make your state changes[‚Äã](#make-your-state-changes "Direct link to Make your state changes")

Perform DOM edits, styling updates, add/remove classes, or whatever is necessary to get things in their final state. There's no need to do that through the plugin (unless you're [batching](/docs/v3/Plugins/Flip/static.batch\(\).md)). For example, we'll toggle a class:

3. ### Call `Flip.from(state, options)`[‚Äã](#call-flipfromstate-options "Direct link to call-flipfromstate-options")

Flip will look at the `state` object, compare the recorded positions/sizes to the current ones, immediately reposition/resize them to *appear* where they were in that previous state, and then animate the *removal* of those offsets. You can specify almost any standard tween special properties like `duration`, `ease`, `onComplete`, etc. [Flip.from()](/docs/v3/Plugins/Flip/static.from\(\).md) returns a timeline that you can `add()` things to or control in any way:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/5e9998b2c467309c357987dde1a9a21b?default-tab=result\&theme-id=41164)

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/02b5ff28e7175110cad7d24a1dce7201?default-tab=result\&theme-id=41164)

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/eed66252fd3d05b32ba336fbabb38e94?default-tab=result\&theme-id=41164)

The [Flip.from()](/docs/v3/Plugins/Flip/static.from\(\).md) options object (2nd parameter) can contain any of the following optional properties **in addition to any standard tween properties like `duration`, `ease`, `onComplete`**, etc. as described [here](/docs/v3/GSAP/gsap.to\(\).md):

Boolean | String | Array | NodeList | Element - specifies which of the targets should have `position: absolute` applied during the course of the FLIP animation. If `true`, **all** of the targets are affected, or use selector text like `".box"` (or an Array/NodeList of Elements, or even a single Element) to specify a subset of the targets. This can solve layout challenges with flex and grid layouts, for example. If things aren't behaving in a seamless way, try setting `absolute: true`. Beware, that `position: absolute` removes the elements from document flow, so things below can collapse. In that case, just define a subset that doesn't include the container element so it props the layout open. *(added in 3.9.0)*

* #### absoluteOnLeave[](#absoluteOnLeave)

Boolean - if `true`, any "leaving" Elements (ones passed to the `onLeave()`) will be set to `position: absolute` during the flip animation. This can be very useful when you set elements to `display: none` to hide them in the final state, but you want to animate them out (fade, scale, whatever). It's critical that they not affect layout but you still want them visible during the animation. *(added in 3.9.0)*

Boolean - by default, if the target element associated with a particular `data-flip-id` in the previous state is a **different element** than the one with the same `data-flip-id` in the end state, it will get swapped immediately but if you'd prefer that they cross-fade, set `fade: true`. Again, this only applies when swapping elements. If the "swapping out" (leaving) element is `display: none` (CSS), obviously it won't be visible for fading but if you set the Flip to `absolute: true`, it will force the element to the previous display state *during* the flip so that it can cross-fade. The reason `absolute: true` is necessary in this case is because otherwise the element would affect document flow and throw off the positioning of other elements but if it is `position: absolute` (CSS), it's removed from the document flow and won't contaminate positioning.

* #### nested[](#nested)

Boolean - if the Flip has any *nested* targets (like a parent and its child are both in the `targets`), set `nested: true` to have Flip perform extra calculations to prevent those movements from compounding. A parent's movement affects its children, so if both are mapped to end up 200px from their original position and Flip moves them both 200px, the child would end up moving 400px unless `nested: true` is set.

* #### onEnter[](#onEnter)

Function - A callback that's called if/when a target either isn't found in the original `state` or it was not in the document flow in that original state (like `display: none`), but it *IS* in the document flow in the **end** state. Since there is no position/size data to compare to in the original state, it won't be included in the flip animation, but the callback receives an Array of the entering elements as a parameter so that you can animate them as you please (like fade them in). Any animation returned by this callback will get added to the flip timeline so that it gets forced to completion if a competing flip interrupts it. For example:

* #### onLeave[](#onLeave)

Function - A callback that's called if/when a target is in the original `state` but not the end state, or if it isn't in the document flow in the end state (like `display: none`). Since there is no position/size data to compare to in the end state, it won't be included in the flip animation, but the callback receives an Array of the leaving elements as a parameter so that you can animate them as you please (like fade them out). **IMPORTANT:** these elements won't be visible unless you also set `absolute: true` (otherwise, it'd throw off document flow). If `absolute: true` is set, it will force `display` to whatever it was in the previous state and then revert it back at the end of the flip. Any animation returned by this callback will get added to the flip timeline so that it gets forced to completion if a competing flip interrupts it. For example:

* #### props[](#props)

String - a comma-delimited list of *camelCased* CSS properties that should be included in the flip animation beyond the standard positioning/size/rotation/skew ones. For example, `"backgroundColor,color"`. This will only work, however, if the props exist in the `state` object (first parameter) because otherwise there's no corresponding data to pull from. By default, Flip will use the `props` that were captured in the state with [Flip.getState(targets, props)](/docs/v3/Plugins/Flip/static.getState\(\).md), so it's very rare that you'd need to define `props` in [Flip.from()](/docs/v3/Plugins/Flip/static.from\(\).md). It's only useful if you want to *LIMIT* them to a subset of the ones captured in the state.

* #### prune[](#prune)

Boolean - if `true`, Flip will remove any targets from the animation that match the previous state (position/size) in order to conserve resources. This requires a little more processing up-front, but it may improve performance during the animation when several get removed, plus it also makes staggering more intuitive since you may not want non-animating targets to be factored into the staggering. *(added in 3.9.0)*

* #### scale[](#scale)

Boolean - by default, Flip will affect the `width` and `height` CSS properties to alter the size, but if you'd rather scale the element instead (typically better performance), set `scale: true`.

* #### simple[](#simple)

Boolean - if `true`, Flip will skip the extra calculations that would be necessary to accommodate rotation/scale/skew in determining positions. It's like telling Flip *"I promise that there aren't any rotated/scaled/skewed containers for the Flipping elements"* which makes things **faster**. In most cases, the performance difference isn't noticeable, but if you're flipping a lot of elements it can help keep things snappy.

Boolean | Number | Function -

if `true`, the elements will spin an extra 360 degrees during the flip animation which makes it look a little more fun. Or you can define a **number** of full rotations, including a negative number, so `-1` would spin in the opposite direction once. If you provide a **function**, it will be called once for each target so that you can return whatever value you'd like for each individual element's spin. This allows you to, for example, have certain targets spin one direction, other elements spin another direction, or return 0 to not spin at all. Sample code: ...

* #### targets[](#targets)

String | Element | Array | NodeList - by default, Flip will use the targets from the `state` object (first parameter), but you can specify a subset of those as either selector text (`".class, #id"`), an Element, an Array of Elements, or a NodeList. If any of the targets provided is NOT found in the `state` object, it will be passed to the `onEnter` and *not* included in the flip animation because there's no previous state from which to pull position/size data.

* #### toggleClass[](#toggleClass)

String - adds a CSS class to the targets while the flip animation is in progress. For example `"flipping"`.

* #### zIndex[](#zIndex)

Number - immediately sets the zIndex CSS property to this value for the entire course of the flip animation and then reverts at the end. This makes it easy to ensure that your flipping elements are on top of other elements during the animation, for example.

Flip looks for a `data-flip-id` attribute on every element it interacts with (via [Flip.getState()](/docs/v3/Plugins/Flip/static.getState\(\).md) or [Flip.from()](/docs/v3/Plugins/Flip/static.from\(\).md), etc.) and if one isn't found, Flip assigns an incremented one automatically ("auto-1", "auto-2", etc.). It lets you correlate targets (the target with the `data-flip-id` of `"5"` in the "from" state gets matched up with the target with a `data-flip-id` of `"5"` in the end state). The `data-flip-id` can be any string, not just a number.

So if you want to flip between two different targets, make sure the data-flip-id attribute in the end state matches the one in the "from" state. When Flip sees that there are two with the same value in the from/end state, it will automatically figure out which one is disappearing (typically with `display: none`) and base things off of that to "swap" the elements. If you want them to crossfade, simply set `fade: true`, otherwise they'll immediately swap. And it is typically best to set `absolute: true` so that when Flip alters the `display` value, it doesn't affect the document flow.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/0268e6a4e9d646eba82f852a869677ca?default-tab=result\&theme-id=41164)

What if you need to create **multiple** coordinated Flip animations (perhaps in various React components)? They'd need to all [.getState()](/docs/v3/Plugins/Flip/static.getState\(\).md) *BEFORE* any of them make their changes to the DOM/styling because doing so could alter the position/size of the other elements. See the docs for [Flip.batch()](/docs/v3/Plugins/Flip/static.batch\(\).md) for details.

* Flip does not accommodate 3D transforms (like rotationX, rotationY, or z).
* It is strongly recommended that you use `box-sizing: border-box` on your elements to ensure accurate width/height calculations.
* When `absolute: true` is set, remember that coordinates will be calculated based on the current viewport, so if the viewport size changes or the user scrolls DURING the flip, it may affect positioning (but once the flip is done and the offsets are removed, things will be where they should be). In other words, in-progress flipping isn't always responsive.
* Set any transform-related values (x, y, scale, rotation, etc.) [directly via GSAP](/resources/mistakes.md#transforms) whenever possible (instead of just in CSS classes or inline) because GSAP caches transform-related data to supercharge performance and maximize accuracy. To clear GSAP's cache on a particular element (which you'd never need to do if you're making all your changes via GSAP), `gsap.set(element, {clearProps: "transform"});`

Deep Dive - Using a framework like Vue, React or Angular?

Beware that frameworks often **DON'T** render changes immediately, so you should wait until the render occurs *before* initiating the [Flip.from()](/docs/v3/Plugins/Flip/static.from\(\).md). [Batching](/docs/v3/Plugins/Flip/static.batch\(\).md) may be an excellent option because you can `batch.getState(true)` and then perhaps a `useLayoutEffect(() => batch.run(true), [...])` in React. Another hack would be to use requestAnimationFrame() to wait one tick: `requestAnimationFrame(() => Flip.from(...));`

When you `Flip.getState(".your-class")`, it records position/size data for the elements with ".your-class" at that time, remembering **those particular elements** and their `data-flip-id` attribute values. Then, if you `Flip.from(yourState)`, and don't specify any `targets`, it will default to using the elements that were captured in the getState() but your framework may have re-rendered entirely new element instances (even if they look the same), thus they won't animate because Flip doesn't know to look at those new elements. The original ones were completely removed from the DOM, hence the need to tell the Flip *"use these new targets and search the state object for the IDs that match..."*. So make sure you define `targets` like this:

And don't forget that you'll probably need to set a `data-flip-id` on those elements to make sure Flip knows which target matches up with which one from the captured state.

|                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| #### [Flip.batch](/docs/v3/Plugins/Flip/static.batch\(\).md)( id:String ) : FlipBatch                                                                                | Coordinates the creation of multiple Flip animations in the properly sequenced set of steps to avoid cross-contamination.                                                                                                                                                                                                                                                                                                                                                          |
| #### [Flip.fit](/docs/v3/Plugins/Flip/static.fit\(\).md)( targetToResize:String \| Element, destinationTargetOrState:String \| Element \| FlipState, vars:Object ) ; | Repositions/resizes one element so that it appears to fit exactly into the same area as another element. Using the `fitChild` special property, you can even scale/reposition an element so that one if its *child* elements is used for the fitting calculations instead! By default it alters the transforms (x, y, rotation, and skewX) as well as the width and height of the element, but if you set `scale: true` it will use scaleX and scaleY instead of width and height. |
| #### [Flip.from](/docs/v3/Plugins/Flip/static.from\(\).md)( state:FlipState, vars:Object ) : Timeline                                                                | Immediately moves/resizes the targets to match the provided `state` object, and then animates backwards to remove those offsets to end up at the current state. By default, `width` and `height` properties are used for the resizing, but you can set `scale: true` to scale instead (transform). It returns a timeline animation, so you can control it or add() other animations.                                                                                               |
| #### [Flip.getState](/docs/v3/Plugins/Flip/static.getState\(\).md)( targets:String \| Element \| Array, vars:Object ) : Object                                       | Captures information about the current state of the `targets` so that they can be Flipped later. By default, this information includes the dimensions, rotation, skew, opacity, and the position of the targets in the viewport. Other properties can be captured by configuring the `vars` parameter.                                                                                                                                                                             |
| #### [Flip.isFlipping](/docs/v3/Plugins/Flip/static.isFlipping\(\).md)( target:String \| Element ) : Boolean                                                         | Returns `true` if the given target is currently being Flipped. Otherwise returns `false`.                                                                                                                                                                                                                                                                                                                                                                                          |
| #### [Flip.killFlipsOf](/docs/v3/Plugins/Flip/static.killFlipsOf\(\).md)( targets:String \| Array \| NodeList \| Element, complete:boolean ) ;                       | Immediately kills the Flip animation associated with any of the targets provided.                                                                                                                                                                                                                                                                                                                                                                                                  |
| #### [Flip.makeAbsolute](/docs/v3/Plugins/Flip/static.makeAbsolute\(\).md)( targets:String \| Element \| Array \| NodeList \| FlipState ) : Array                    | Sets all of the provided target elements to `position: absolute` while retaining their current positioning.                                                                                                                                                                                                                                                                                                                                                                        |
| #### [Flip.to](/docs/v3/Plugins/Flip/static.to\(\).md)( state:FlipState, vars:Object ) : Timeline                                                                    | Identical to [Flip.from()](/docs/v3/Plugins/Flip/static.from\(\).md) except inverted, so this would animate **to** the provided state (from the current one).                                                                                                                                                                                                                                                                                                                      |

Check out the full collection of [How-to demos](https://codepen.io/collection/4a605f253549434210c139fa331704cb) and our favourite [inspiring community demos](https://codepen.io/collection/d725bcacb2f44bbdf0f44718f7ebbf55) on CodePen.

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(Flip)
```

Example 2 (unknown):
```unknown
// grab state
const state = Flip.getState(squares);
  
// Make DOM or styling changes
switchItUp();
  
// Animate from the initial state to the end state
Flip.from(state, {duration: 2, ease: "power1.inOut"});
```

Example 3 (unknown):
```unknown
// returns a state object containing data about the elements' current position/size/rotation in the viewport
   const state = Flip.getState(".targets");
```

Example 4 (unknown):
```unknown
// record some extra properties (optional)
   const state = Flip.getState(".targets", { props: "backgroundColor,color" });
```

---

## deltaX

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/deltaX.md

**Contents:**
  - deltaX : Number
  - Details[‚Äã](#details "Direct link to Details")

The change in the x-related value since the last drag event.

*Number* - The change in the x-related value since the last drag event. The x-related value is typically `x` (`translateX`) or `left`, but if type is "rotation" it applies to the change in rotation.

---

## isEnabled

**URL:** https://gsap.com/docs/v3/Plugins/Observer/isEnabled.md

**Contents:**
  - isEnabled : Boolean
  - Details[‚Äã](#details "Direct link to Details")

Indicates whether or not the Observer is enabled. Use the `enable()` and `disable()` methods to set the state. When an Observer is disabled, it removes all of its event listeners from the target and obviously won't trigger any callbacks. There are `onEnable` and `onDisable` callbacks, though, which of course would be called when you enable/disable the Observer.

Indicates whether or not the Observer is enabled. Use the `enable()` and `disable()` methods to set the state. When an Observer is disabled, it removes all of its event listeners from the target and obviously won't trigger any callbacks. There are `onEnable` and `onDisable` callbacks, though, which of course would be called when you enable/disable the Observer.

---

## RoughEase

**URL:** https://gsap.com/docs/v3/Eases/RoughEase.md

**Contents:**
    - CDN Link
    - Minimal usage
  - Description[‚Äã](#description "Direct link to Description")
  - Config Object[‚Äã](#config-object "Direct link to Config Object")
  - Example code[‚Äã](#example-code "Direct link to Example code")

Not included in the Core

This ease is in the EasePack file. To learn how to include this in your project, see [the Installation page](/docs/v3/Installation).

Most easing equations give a smooth, gradual transition between the start and end values, but `RoughEase` provides an easy way to get a rough, jagged effect instead, or you can also get an evenly-spaced back-and-forth movement if you prefer. `RoughEase` is in the EasePack file. Configure the `RoughEase` with any of these optional properties:

Boolean - Setting `clamp` to `true` will prevent points from exceeding the end value or dropping below the starting value. For example, if you‚Äôre tweening the x property from 0 to 100, the RoughEase would force all random points to stay between 0 and 100 if `clamp` is `true`, but if it is `false`, x could potentially jump above 100 or below 0 at some point during the tween (it would always end at 100 though in this example). Default: `false`.

* #### points[](#points)

Number - The number of points to be plotted along the ease, making it jerk more or less frequently. Default: `20`.

* #### randomize[](#randomize)

Boolean - By default, the placement of points will be randomized (creating the roughness) but you can set `randomize` to `false` to make the points zig-zag evenly across the ease. Using this in conjunction with a `taper` value can create a nice effect. Default: `true`.

* #### strength[](#strength)

Number - Controls how far from the template ease the points are allowed to wander (a small number like 0.1 keeps it very close to the template ease whereas a larger number like 5 creates much bigger variations). Default: `1`.

* #### taper[](#taper)

String (`"in"` | `"out"` | `"both"` | `"none"`) - To make the strength of the roughness taper towards the end or beginning or both, use `"out"`, `"in"`, or `"both"` respectively. Default: `"none"`.

* #### template[](#template)

String - An ease that should be used as a template, like a general guide. The RoughEase will plot points that wander from that template. You can use this to influence the general shape of the RoughEase. Default: `"none"`.

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(EasePack)
```

Example 2 (unknown):
```unknown
// we're starting at a scale of 1 and animating to 2, so pass those into config()...
gsap.to("#image", { duration: 1, scale: 2, ease: "expoScale(1, 2)" });
```

Example 3 (unknown):
```unknown
//use the default values
gsap.from(element, {duration: 1, opacity: 0, ease: "rough"});

//or customize the configuration
gsap.to(element, {duration: 2, y: 300, ease: "rough({strength: 3, points: 50, template: strong.inOut, taper: both, randomize: false})" });
```

---

## .vars

**URL:** https://gsap.com/docs/v3/Plugins/ScrollTrigger/vars.md

**Contents:**
  - .vars : Object
  - Details[‚Äã](#details "Direct link to Details")
- Example[‚Äã](#example "Direct link to Example")

\[read-only] The vars configuration object used to create the ScrollTrigger instance

\[read-only] The vars configuration object used to create the ScrollTrigger instance.

You can store arbitrary data in the `vars` object if you want; ScrollTrigger will just ignore the properties it doesn't recognize. So, for example, you could add a "group" property so that you could group your ScrollTriggers and then later to kill() all the ScrollTrigger instances from a particular group, you could do:

**Examples:**

Example 1 (unknown):
```unknown
let st = ScrollTrigger.create({
  trigger: ".trigger",
  start: "top center",
  end: "+=500",
});

console.log(st.vars); // {trigger: ".trigger", start: "top center", end: "+=500"}
```

Example 2 (unknown):
```unknown
// helper function (reusable):
let getGroup = (group) =>
  ScrollTrigger.getAll().filter((t) => t.vars.group === group);

// then, to kill() anything with a group of "my-group":
getGroup("my-group").forEach((t) => t.kill());
```

---

## MotionPath

**URL:** https://gsap.com/docs/v3/Plugins/MotionPathPlugin.md

**Contents:**
    - CDN Link
    - Minimal usage
- Other features[‚Äã](#other-features "Direct link to Other features")
- **Config Object**[‚Äã](#usage "Direct link to usage")
- Demo[‚Äã](#demo "Direct link to Demo")
    - loading...
- Animating through other properties (not coordinates)[‚Äã](#animating-through-other-properties-not-coordinates "Direct link to Animating through other properties (not coordinates)")
    - loading...
- Video[‚Äã](#video "Direct link to Video")
- **Methods**[‚Äã](#methods "Direct link to methods")

[YouTube video player](https://www.youtube.com/embed/3FbYrkDzgd4)

Animate any object along a path (or even through arbitrary property values). The motionPath can be defined as any of the following:

* An SVG **`<path>`** element (selector text or direct reference) like:

* A **string of SVG path data** like:

* An **Array of objects with x,y coordinates**. By default, it will draw a curved path **through** these coordinates, but set `type: "cubic"` if they describe a cubic bezier:

* An **Array of objects defining *other* properties** (doesn't need to be "x" and "y"). This will basically smooth out the velocity changes as it hits each value:

* A **configuration object** that has a `path` property with any of the above formats, plus other [configuration details](#usage) like:

* **Magical `align` capabilities** that bend coordinate systems in order to position the target exactly on top of the path (or move the path to the target), regardless of how deeply nested they are inside different transformed containers! This is insanely convenient and no other tool on the web offers this functionality.

* `**autoRotate**` makes the target rotate automatically in the direction of the path as it moves.

* Define specific **`start`** and/or **`end`** positions on the path (progress values from 0-1). Even wrap around or go backwards!

* A separate [MotionPathHelper](/docs/v3/Plugins/MotionPathHelper) tool enables **interactive editing of the path directly in the browser!**

* No need to supply an SVG path - you can provide raw coordinates through which to **plot a curved path, complete with adjustable curviness**

* Loads of **helper methods** for doing advanced things like:

* Convert native SVG shapes like `<circle>`, `<rect>`, etc. into an equivalent `<path>` ([convertToPath()](/docs/v3/Plugins/MotionPathPlugin/static.convertToPath\(\).md))
  * Calculate the relative position data between any two DOM elements so that you can move one to align perfectly with another, even if they're inside different containers that have various transforms applied! ([getRelativePosition()](/docs/v3/Plugins/MotionPathPlugin/static.getRelativePosition\(\).md))
  * Convert SVG `<path>` data into raw cubic bezier data/numbers (or the other way around) ([stringToRawPath()](/docs/v3/Plugins/MotionPathPlugin/static.stringToRawPath\(\).md)/[rawPathToString()](/docs/v3/Plugins/MotionPathPlugin/static.rawPathToString\(\).md))
  * Convert between coordinate spaces ([convertCoordinates()](/docs/v3/Plugins/MotionPathPlugin/static.convertCoordinates\(\).md)/[getGlobalMatrix()](/docs/v3/Plugins/MotionPathPlugin/static.getGlobalMatrix\(\).md)/[getAlignMatrix()](/docs/v3/Plugins/MotionPathPlugin/static.getAlignMatrix\(\).md))

The `motionPath` can be used as either a shorthand for the `path` (described below) or as a configuration object with any of the following properties: The below code would align a div to an SVG `<path>`. It assumes that there is a DOM element with an `id` of `"div"` and an SVG `<path>` with an `id` of `"#path"`.

String | Element | Array \[required] The motion path along which to animate the target(s). This can be any of the following:

* An SVG **``**&#x65;lement (selector text or direct reference) like:
    
  * A **string of SVG path data** like:
    
  * An **Array of objects with x,y coordinates**. A curved path will be plotted **through** these coordinates, or set `type: "cubic"` to have them interpreted as sequential cubic bezier coordinates (ordered like: *anchor, two control points, anchor, two control points*, etc.):
    
  * An **Array of objects defining *other* properties** (doesn't need to be "x" and "y"). This will basically smooth out the velocity changes as it hits each value:

* #### align[](#align)

String | Element - By default, the raw coordinate values from the `path` data are plugged directly into the target's x/y transforms but the `align` property bends coordinate spaces in order to position the target exactly on top of the path (or move the path to the target) regardless of how deeply nested they are inside different transformed containers! You can align to the `path` too. In other words, `path` and `align` can point to the same element. `align` can be any of the following:

* **Selector text**, like `"#path"` would select the element with the ID of "path" and move the tween's target so that its top left corner is aligned perfectly with that "#path" element. If you'd rather center the target on the spot, use `alignOrigin: [0.5, 0.5]`
  * **Element**, like a reference to a DOM element.
  * **`"self"`** moves the path to the tween's targets so that they don't jump initially. In other words, it's as if the path was drawn from their current position(s).

You can also use `offsetX` and `offsetY` to fine-tune alignment.

* #### alignOrigin[](#alignOrigin)

Array - Determines the point on the target that gets aligned with the path. `alignOrigin` is an Array with progress values along the x and y axis, so `[0.5, 0.5]` would be in the center, `[1, 0]` would be the top right corner, etc. Setting an `alignOrigin` also automatically sets the `transformOrigin` to the corresponding place on the target for convenience. *(added in GSAP 3.2.0)*

* #### autoRotate[](#autoRotate)

Boolean | Number - Rotates the element in the direction of the path. `true` matches the angle of the path exactly, but you can offset the angle by any amount by defining `autoRotate` as a **number** (in degrees). For example, `autoRotate: 90` would add 90 degrees to the rotation as it moves along the path. If you‚Äôd like the element to rotate from its center, simply set `transformOrigin: "50% 50%"`. To align the path with the center of the target, either use `alignOrigin: [0.5, 0.5]` or set `xPercent: -50, yPercent: -50` on the target before the motionPath tween.

* #### start[](#start)

Number - The position along the path at which to start, where 0 is the beginning and 1 is the end and 0.5 is the middle. It can be any positive or negative decimal number. For example, `0.3` would start the element at the 30% point along the curve. Default is 0.

Number - The position along the path at which to end, where 0 is the beginning, 1 is the end, and 0.5 is in the middle. It can be any positive or negative decimal number, including a value that's less than the start (which would make the object travel backwards). For example, `0.3` would have the element end at the 30% point along the curve. 1.5 would make it loop around back to the beginning and stop at the halfway point. Default is 1.

* #### curviness[](#curviness)

Number - Only applies when the `path` is an Array of points through which to plot a curve. This determines how "curvy" the resulting path is. So 0 would make straight lines (hard corners), 1 (the default) creates a nicely curved path, and 2 would make it much more curvy. Think of it like pulling the control points further and further outward from the anchors as the number goes higher. Default is 1.

* #### offsetX[](#offsetX)

Number - An amount to add to the x coordinate(s) for fine-tuning alignment. Default is 0.

* #### offsetY[](#offsetY)

Number - An amount to add to the y coordinate(s) for fine-tuning alignment. Default is 0.

* #### fromCurrent[](#fromCurrent)

Boolean - When `false`, causes it **NOT** to include the current property values in an Array that's passed in for the `path`. For example, if the target is currently at `x: 0`, `y: 0` and then you do a `motionPath: {path: [{x: 100, y: 100}, {x: 200, y: 0}, {x: 300, y: 200}]}` tween, by default it would add `{x: 0, y: 0}` to the *start* of that Array so that it animates smoothly from wherever it **currently** is but you can set `fromCurrent: false` to avoid that and just have it *jump* to x: 100, y: 100 at the start of that tween. *(added in 3.7.0)*

* #### relative[](#relative)

Boolean - Only applies when `path` is an Array. If `true`, each successive value is interpreted as **relative** to the previous one. For example, if the target's x starts at 100 and the path is `[{x:5}, {x:10}, {x:-2}] `, it would first move to 105, then 115, and finally end at 113.

String - Only applies when `path` is an Array of objects with x/y properties - set `type: "cubic"` to have them interpreted as a sequence of cubic beziers in the following order: anchor, two control points, anchor, two control points, anchor, etc. for as many iterations as you want but obviously make sure that it starts and ends with anchors.

* #### resolution[](#resolution)

Number - Only applies when `path` is an Array. Due to the nature of bezier curves, plotting the progression of an object on the path over time can make it appear to speed up or slow down based on the placement of the control points and the length of each successive segment on the path. So MotionPathPlugin implements a technique that reduces or eliminates that variance, but it involves breaking the segments down into a certain number of pieces which is what `resolution` controls. The greater the number, the more accurate the time remapping. But there is a processing price to pay for greater precision. The default value of 12 is typically perfect, but if you notice slight pace changes on the path you can increase the `resolution` value. Or, if you want to prioritize speed you could reduce the number.

* #### useRadians[](#useRadians)

Boolean - If true, the the value passed to the rotation will use radians instead of degrees. This is particularly helpful when working with other scripts or libraries that default to radians like Pixi.js. Default is false.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/9bdac66e1cb0ad0aa24396565f340e9c?default-tab=result\&theme-id=41164)

When you `align` the motionPath, those calculations are done at the very start of the animation - it is **NOT** responsive, so if the screen gets resized in a way that affects the path, the alignment won't get re-applied. Why? It would be too expensive CPU-wise to constantly be checking and re-calculating on each tick. But you could definitely set up your own resize listeners and handle it manually in that case (store the progress of the tween, `progress(0).kill()` it, create a new tween and jump to the recorded progress).

You can pass in an Array of objects defining *other* properties (doesn't need to be "x" and "y") and it will basically smooth out the velocity changes as it hits each value. In the example below, we animate through various `scale` values with a curviness of 0 and 2; notice how the velocity changes are smoother with a higher curviness:

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/vYBVQap?default-tab=result\&theme-id=41164)

|                                                                                                                                                                                                                                                         |                                                                                                                                                                                                                                                                                                   |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| #### [MotionPathPlugin.arrayToRawPath](/docs/v3/Plugins/MotionPathPlugin/static.arrayToRawPath\(\).md)( values:Array, vars:Object ) : RawPath Array                                                                                                     | Takes an Array of coordinates and plots a curve through them, returning a corresponding RawPath Array. If `type: "cubic"` is declared in the `vars` parameter object, they will be interpreted as cubic bezier points like anchor, two control points, anchor, two control points, anchor, etc.)  |
| #### [MotionPathPlugin.convertCoordinates](/docs/v3/Plugins/MotionPathPlugin/static.convertCoordinates\(\).md)( fromElement:Element \| window, toElement:Element \| window, point:Object ) : Object (point or Matrix2D)                                 | Converts a point from one element's local coordinates into where that point lines up in a different element's local coordinate system regardless of how many nested transforms are affecting the elements!                                                                                        |
| #### [MotionPathPlugin.convertToPath](/docs/v3/Plugins/MotionPathPlugin/static.convertToPath\(\).md)( shape:String \| Element, swap:Boolean ) : Array                                                                                                   | Converts SVG shapes like `<circle>`, `<rect>`, `<ellipse>`, or `<line>` into `<path>`                                                                                                                                                                                                             |
| #### [MotionPathPlugin.getAlignMatrix](/docs/v3/Plugins/MotionPathPlugin/static.getAlignMatrix\(\).md)( fromElement:Element \| window, toElement:Element \| window, fromOrigin:Array, toOrigin:Array \| String ) : Matrix2D                             | Gets a Matrix2D for translating between coordinate spaces, typically so that you can move the `fromElement` to align it with the `toElement` while factoring in all transforms (even nested ones). The matrix allows you to convert any point/coordinate using its apply() method.                |
| #### [MotionPathPlugin.getGlobalMatrix](/docs/v3/Plugins/MotionPathPlugin/static.getGlobalMatrix\(\).md)( element:Element, inverse:Boolean, adjustGOffset:Boolean ) : Matrix2D                                                                          | Gets the Matrix2D that would be used to convert the element's local coordinate space into the global coordinate space. So, for example, if you take a point `{x:0, y:0}` and `apply()` the matrix to it, the resulting point would be the viewport coordinates of that element's top left corner. |
| #### [MotionPathPlugin.getLength](/docs/v3/Plugins/MotionPathPlugin/static.getLength\(\).md)( path:Element \| String \| RawPath ) : Number                                                                                                              | Returns the length of a path                                                                                                                                                                                                                                                                      |
| #### [MotionPathPlugin.getPositionOnPath](/docs/v3/Plugins/MotionPathPlugin/static.getPositionOnPath\(\).md)( rawPath:Array, progress:Number, includeAngle:Boolean ) : Object                                                                           | Calculates the x/y position (and optionally the angle) corresponding to a particular progress value along the RawPath                                                                                                                                                                             |
| #### [MotionPathPlugin.getRawPath](/docs/v3/Plugins/MotionPathPlugin/static.getRawPath\(\).md)( value:String \| Element ) : RawPath (Array)                                                                                                             | Gets the RawPath (Array) for the provided element or raw SVG \<path> data. A RawPath is essentially an Array containing one Array for each contiguous segment with alternating x, y, x, y cubic bezier data.                                                                                      |
| #### [MotionPathPlugin.getRelativePosition](/docs/v3/Plugins/MotionPathPlugin/static.getRelativePosition\(\).md)( fromElement:Element \| window, toElement:Element \| window, fromOrigin:Array \| Object, toOrigin:Array \| Object \| String ) : Object | Gets the x and y distances between two elements regardless of nested transforms! feed two elements to this method and it'll return the gap between them as a point {x, y} according to the coordinate system of the fromElement's parent.                                                         |
| #### [MotionPathPlugin.pointsToSegment](/docs/v3/Plugins/MotionPathPlugin/methods/static-pointsToSegment.md)( points:Array, curviness:Number ) : Array                                                                                                  | Plots a curved cubic bezier path through the provided x,y point coordinates, returning a segment Array that's typically dropped into a RawPath Array                                                                                                                                              |
| #### [MotionPathPlugin.rawPathToString](/docs/v3/Plugins/MotionPathPlugin/static.rawPathToString\(\).md)( rawPath:Array ) : String                                                                                                                      |                                                                                                                                                                                                                                                                                                   |
| #### [MotionPathPlugin.sliceRawPath](/docs/v3/Plugins/MotionPathPlugin/static.sliceRawPath\(\).md)( rawPath:Array, start:Number, end:Number ) : RawPath                                                                                                 | Slices the provided RawPath Array at the designated start/end positions and returns the resulting (new, sliced) RawPath                                                                                                                                                                           |
| #### [MotionPathPlugin.stringToRawPath](/docs/v3/Plugins/MotionPathPlugin/static.stringToRawPath\(\).md)( data:String ) : RawPath                                                                                                                       |                                                                                                                                                                                                                                                                                                   |

Check out the full collection of [SVG animation demos](https://codepen.io/collection/NqewVd) on CodePen.

**Examples:**

Example 1 (unknown):
```unknown
gsap.registerPlugin(MotionPathPlugin)
```

Example 2 (unknown):
```unknown
gsap.to("#div", {
  motionPath: {
    path: "#path",
  },
  transformOrigin: "50% 50%",
  duration: 5,
});
```

Example 3 (unknown):
```unknown
motionPath: "#pathID";
```

Example 4 (unknown):
```unknown
motionPath: "M9,100c0,0,18-41,49-65";
```

---

## autoRemoveChildren

**URL:** https://gsap.com/docs/v3/GSAP/Timeline/autoRemoveChildren.md

**Contents:**
  - autoRemoveChildren : Boolean
  - Details[‚Äã](#details "Direct link to Details")

If `true`, child tweens and timelines will be removed as soon as they complete.

If `true`, child tweens/timelines will be removed as soon as they complete. (`false` by default except on the globalTimeline)

---

## startX

**URL:** https://gsap.com/docs/v3/Plugins/Observer/startX.md

**Contents:**
  - startX : Number
  - Details[—Ç–ê–õ](#details "Direct link to Details")

The `clientX` from the most recent `onPress` touch/pointer event, which refers to the horizontal distance from the left edge of the viewport. This only gets updated if you set the `type` to include "touch" and/or "pointer". It's quite useful for dragging logic.

The `clientX` from the most recent `onPress` touch/pointer event, which refers to the horizontal distance from the left edge of the viewport. This only gets updated if you set the `type` to include "touch" and/or "pointer". It's quite useful for dragging logic.

---

## tween

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/tween.md

**Contents:**
  - tween : Tween
  - Details[—Ç–ê–õ](#details "Direct link to Details")

\[read-only] The Tween instance that gets created as soon as the mouse (or touch) is released (when `inertia` is `true`). This allows you to check its `duration`, `.pause()` or `.resume()` it, change its `timeScale`, or whatever you want.

*Tween* - The tween instance that gets created as soon as the mouse (or touch) is released (when `inertia` is `true`) - this allows you to check its `duration`, `pause()` it, `resume()` it, change its `timeScale`, or whatever you want. Keep in mind that a new tween is created each time the element is "thrown". You can easily get it when the user releases the mouse (or touch) by referencing `this.tween` inside the `onDragEnd` callback.

---

## maxRotation

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/maxRotation.md

**Contents:**
  - maxRotation : Number
  - Details[‚Äö√Ñ√£](#details "Direct link to Details")

When bounds are applied, `maxRotation` refers to the maximum "legal" rotation.

*Number* - \[only applies to `type: "rotation"`] When bounds are applied, `maxRotation` refers to the maximum "legal" rotation. This makes it easier to run your own custom logic inside the `snap`, `liveSnap`, or callback function(s) if you so choose.

---

## y

**URL:** https://gsap.com/docs/v3/Plugins/Draggable/y.md

**Contents:**
  - y : Number
  - Details[‚Äã](#details "Direct link to Details")

\[read-only] The current y (vertical) position of the Draggable instance.

*Number* - The current y (vertical) position of the Draggable instance. For a Draggable of `type: "x,y"`, it would be the `y` transform translation, as in the CSS `transform: translateY(...)`. For `type: "top,left"`, the Draggable's `y` would refer to the CSS `top` value that's applied. This is not the global coordinate - it is the inline CSS-related value applied to the element.

This value is updated each time the Draggable is dragged interactively and during the momentum-based tween that Draggable applies when the user releases their mouse/touch, but if you manually change (or tween) the element's position you can force Draggable to look at the "real" value and record it to its own `y` property by calling the Draggable's `update()` method. Basically that re-synchronizes it. Again, this is not necessary unless other code (outside Draggable) alters the target element's position.

---

## trackDirection

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/trackDirection.md

**Contents:**
- Need an onReverse()? Track the playhead direction of any animation[‚Äã](#need-an-onreverse-track-the-playhead-direction-of-any-animation "Direct link to Need an onReverse()? Track the playhead direction of any animation")
- Usage[‚Äã](#usage "Direct link to Usage")
- Demo[‚Äã](#demo "Direct link to Demo")
    - loading...

If you find yourself needing an onReverse() callback (which doesn't exist) or a way to get notified when the playhead changes direction, this is a very useful helper function. What makes it special is that it works no matter how deeply-nested the animation is. Remember, the parent or parent's parent could get reversed or a negative timeScale which directly affects how the playhead sweeps across the descendants.

Choose from any of the following:

1. Directly as a callback (it returns a function):

2. Assigned to the animation:

You can add configuration options (onToggle and/or onUpdate):

Or when assigned to the animation:

since "direction" is set whenever the playhead changes position, it won't update immediately. For example, if you call tween.reverse() and then immediately check (before the next tick), tween.direction will still report as 1 because the playhead hasn't moved yet.

[GSAP Basic Tween](https://codepen.io/GreenSock/embed/rNyrGjB?default-tab=result\&theme-id=41164)

**Examples:**

Example 1 (unknown):
```unknown
function trackDirection(value) {
  typeof value !== "object" && (value = { onUpdate: value });
  let prevTime = 0,
    prevReversed = false,
    anim = value.eventCallback ? value : value.animation,
    onUpdate = value.onUpdate,
    onToggle = value.onToggle;
  return anim
    ? anim.eventCallback(
        "onUpdate",
        trackDirection({ onUpdate: onUpdate, onToggle: onToggle })
      )
    : function () {
        let time = this.totalTime(),
          reversed = time < prevTime;
        this.direction = reversed ? -1 : 1;
        if (reversed !== prevReversed) {
          onToggle && onToggle.call(this, this.direction);
          prevReversed = reversed;
        }
        prevTime = time;
        onUpdate && onUpdate.call(this, this.direction);
      };
}
```

Example 2 (unknown):
```unknown
gsap.to(... {onUpdate: trackDirection(), ...})
```

Example 3 (unknown):
```unknown
let tl = gsap.timeline();
   trackDirection(tl);
```

Example 4 (unknown):
```unknown
gsap.to(
  ...{
    x: 100,
    onUpdate: trackDirection({
      onToggle: (direction) => console.log("toggled direction to", direction),
      onUpdate: (direction) => console.log("updated animation"),
    }),
  }
);
```

---

## "Compensated" skews

**URL:** https://gsap.com/docs/v3/HelperFunctions/helpers/compensatedSkew.md

This is a special method that you can apply via an onUpdate to make a tween render skews in the old `skewType: "compensated"` way from GSAP 2. Note that it affects an element's scaleX/scaleY (hence "compensated")! This assumes skews are degree-based, and only works in GSAP 3. This is not an "officially supported" method.:

**Examples:**

Example 1 (unknown):
```unknown
function compensatedSkew() {
  var targets = this.targets(),
    i = targets.length,
    DEG2RAD = Math.PI / 180,
    target,
    scaleY,
    scaleX,
    cache;
  while (i--) {
    target = targets[i];
    cache = target._gsap;
    scaleY = cache.scaleY;
    scaleX = cache.scaleX;
    cache.scaleY *= Math.cos(parseFloat(cache.skewX) * DEG2RAD);
    cache.scaleX *= Math.cos(parseFloat(cache.skewY) * DEG2RAD);
    cache.renderTransform(1, cache);
    cache.scaleY = scaleY;
    cache.scaleX = scaleX;
  }
}

// usage:
gsap.set(target, { skewX: -30, onUpdate: compensatedSkew });
```

---
